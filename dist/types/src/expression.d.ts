import type { Interpreter } from "./interpreter";
import { LISP } from "./types";
export declare const procedures: {
    quote: import("./interpreter").BuiltInProcedureDefinition<"value", ({ value }: Partial<Record<"value", LISP.Object | LISP.Object[] | null>>) => LISP.Object>;
    lambda: import("./interpreter").BuiltInProcedureDefinition<"body" | "formals", ({ formals, body }: Partial<Record<"body" | "formals", LISP.Object | LISP.Object[] | null>>, _itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => LISP.Procedure>;
    If: import("./interpreter").BuiltInProcedureDefinition<"alternate" | "test" | "consequent", ({ test, consequent, alternate }: Partial<Record<"alternate" | "test" | "consequent", LISP.Object | LISP.Object[] | null>>) => LISP.Object>;
    setD: import("./interpreter").BuiltInProcedureDefinition<"expr" | "variable", ({ variable, expr }: Partial<Record<"expr" | "variable", LISP.Object | LISP.Object[] | null>>, itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => ["<undefined>"]>;
    cond: import("./interpreter").BuiltInProcedureDefinition<"clause" | "clauses", ({ clause, clauses }: Partial<Record<"clause" | "clauses", LISP.Object | LISP.Object[] | null>>) => [className: "<symbol>", value: string] | [className: "<symbol>", value: string, ns: LISP.StaticNS | null, key: string | null] | LISP.IString | LISP.INumber | LISP.IBoolean | LISP.ICharacter | LISP.IPair | LISP.INull | LISP.IVector | LISP.IByteVector | LISP.IEndOfFile | [className: "<procedure>", type: "built-in", name: string] | [className: "<procedure>", type: "lambda", parameters: LISP.ProcedureParameter<string, "optional" | "head" | "variadic" | "tail">[], body: LISP.Object, isMacro: boolean, env: LISP.Env] | LISP.IContinuation | LISP.IParameter | [className: "<port>", type: "built-in", name: string, mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: string | number[]] | [className: "<port>", type: "string", content: string, mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: string] | [className: "<port>", type: "bytevector", content: number[], mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: number[]] | [className: "<port>", type: "file", discriptor: number, mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: string | number[]] | LISP.IRecordType | LISP.IRecord | LISP.IMultiValue | LISP.ISyntaxRules | LISP.IException | LISP.IUndefined | LISP.IPromise | LISP.IError | LISP.IEnvironmentSpec | ["<js>", "built-in", string] | ["<js>", "inline", any]>;
    Case: import("./interpreter").BuiltInProcedureDefinition<"clauses" | "key", ({ key, clauses }: Partial<Record<"clauses" | "key", LISP.Object | LISP.Object[] | null>>) => [className: "<symbol>", value: string] | [className: "<symbol>", value: string, ns: LISP.StaticNS | null, key: string | null] | LISP.IString | LISP.INumber | LISP.IBoolean | LISP.ICharacter | LISP.IPair | LISP.INull | LISP.IVector | LISP.IByteVector | LISP.IEndOfFile | [className: "<procedure>", type: "built-in", name: string] | [className: "<procedure>", type: "lambda", parameters: LISP.ProcedureParameter<string, "optional" | "head" | "variadic" | "tail">[], body: LISP.Object, isMacro: boolean, env: LISP.Env] | LISP.IContinuation | LISP.IParameter | [className: "<port>", type: "built-in", name: string, mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: string | number[]] | [className: "<port>", type: "string", content: string, mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: string] | [className: "<port>", type: "bytevector", content: number[], mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: number[]] | [className: "<port>", type: "file", discriptor: number, mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: string | number[]] | LISP.IRecordType | LISP.IRecord | LISP.IMultiValue | LISP.ISyntaxRules | LISP.IException | LISP.IUndefined | LISP.IPromise | LISP.IError | LISP.IEnvironmentSpec | ["<js>", "built-in", string] | ["<js>", "inline", any]>;
    and: import("./interpreter").BuiltInProcedureDefinition<"rest" | "first", ({ first, rest }: Partial<Record<"rest" | "first", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean | LISP.List>;
    or: import("./interpreter").BuiltInProcedureDefinition<"rest" | "first", ({ first, rest }: Partial<Record<"rest" | "first", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean | LISP.List>;
    when: import("./interpreter").BuiltInProcedureDefinition<"expr" | "test" | "exprs", ({ test, expr, exprs }: Partial<Record<"expr" | "test" | "exprs", LISP.Object | LISP.Object[] | null>>) => LISP.Object>;
    unless: import("./interpreter").BuiltInProcedureDefinition<"expr" | "test" | "exprs", ({ test, expr, exprs }: Partial<Record<"expr" | "test" | "exprs", LISP.Object | LISP.Object[] | null>>) => LISP.Object>;
    Let: import("./interpreter").BuiltInProcedureDefinition<"args", ({ args }: Partial<Record<"args", LISP.Object | LISP.Object[] | null>>, _itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => LISP.List>;
    LetStar: import("./interpreter").BuiltInProcedureDefinition<"body" | "bindings", ({ bindings, body }: Partial<Record<"body" | "bindings", LISP.Object | LISP.Object[] | null>>, _itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => [className: "<symbol>", value: string] | [className: "<symbol>", value: string, ns: LISP.StaticNS | null, key: string | null] | LISP.IString | LISP.INumber | LISP.IBoolean | LISP.ICharacter | LISP.IPair | LISP.INull | LISP.IVector | LISP.IByteVector | LISP.IEndOfFile | [className: "<procedure>", type: "built-in", name: string] | [className: "<procedure>", type: "lambda", parameters: LISP.ProcedureParameter<string, "optional" | "head" | "variadic" | "tail">[], body: LISP.Object, isMacro: boolean, env: LISP.Env] | LISP.IContinuation | LISP.IParameter | [className: "<port>", type: "built-in", name: string, mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: string | number[]] | [className: "<port>", type: "string", content: string, mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: string] | [className: "<port>", type: "bytevector", content: number[], mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: number[]] | [className: "<port>", type: "file", discriptor: number, mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: string | number[]] | LISP.IRecordType | LISP.IRecord | LISP.IMultiValue | LISP.ISyntaxRules | LISP.IException | LISP.IUndefined | LISP.IPromise | LISP.IError | LISP.IEnvironmentSpec | ["<js>", "built-in", string] | ["<js>", "inline", any]>;
    letrecStar: import("./interpreter").BuiltInProcedureDefinition<"body" | "bindings", ({ bindings, body }: Partial<Record<"body" | "bindings", LISP.Object | LISP.Object[] | null>>, itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => LISP.List>;
    letrec: import("./interpreter").BuiltInProcedureDefinition<"body" | "bindings", ({ bindings, body }: Partial<Record<"body" | "bindings", LISP.Object | LISP.Object[] | null>>, itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => LISP.List>;
    letValues: import("./interpreter").BuiltInProcedureDefinition<"body" | "bindings", ({ bindings, body }: Partial<Record<"body" | "bindings", LISP.Object | LISP.Object[] | null>>, _itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => LISP.List>;
    letStarValues: import("./interpreter").BuiltInProcedureDefinition<"body" | "bindings", ({ bindings, body }: Partial<Record<"body" | "bindings", LISP.Object | LISP.Object[] | null>>, _itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => [className: "<symbol>", value: string] | [className: "<symbol>", value: string, ns: LISP.StaticNS | null, key: string | null] | LISP.IString | LISP.INumber | LISP.IBoolean | LISP.ICharacter | LISP.IPair | LISP.INull | LISP.IVector | LISP.IByteVector | LISP.IEndOfFile | [className: "<procedure>", type: "built-in", name: string] | [className: "<procedure>", type: "lambda", parameters: LISP.ProcedureParameter<string, "optional" | "head" | "variadic" | "tail">[], body: LISP.Object, isMacro: boolean, env: LISP.Env] | LISP.IContinuation | LISP.IParameter | [className: "<port>", type: "built-in", name: string, mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: string | number[]] | [className: "<port>", type: "string", content: string, mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: string] | [className: "<port>", type: "bytevector", content: number[], mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: number[]] | [className: "<port>", type: "file", discriptor: number, mode: "r" | "w" | "rw" | null, elementClass: number | null, buffer: string | number[]] | LISP.IRecordType | LISP.IRecord | LISP.IMultiValue | LISP.ISyntaxRules | LISP.IException | LISP.IUndefined | LISP.IPromise | LISP.IError | LISP.IEnvironmentSpec | ["<js>", "built-in", string] | ["<js>", "inline", any]>;
    begin: import("./interpreter").BuiltInProcedureDefinition<"last" | "exprs", ({ exprs, last }: Partial<Record<"last" | "exprs", LISP.Object | LISP.Object[] | null>>, _itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => LISP.Object | LISP.CallStack>;
    Do: import("./interpreter").BuiltInProcedureDefinition<"clause" | "specs" | "commands", ({ specs, clause, commands }: Partial<Record<"clause" | "specs" | "commands", LISP.Object | LISP.Object[] | null>>) => LISP.List>;
    makeParameter: import("./interpreter").BuiltInProcedureDefinition<"init" | "converter", ({ init, converter }: Partial<Record<"init" | "converter", LISP.Object | LISP.Object[] | null>>, itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => LISP.IParameter>;
    parameterize: import("./interpreter").BuiltInProcedureDefinition<"body" | "assocs", ({ assocs, body }: Partial<Record<"body" | "assocs", LISP.Object | LISP.Object[] | null>>, itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => LISP.CallStack>;
    defineParameter: import("./interpreter").BuiltInProcedureDefinition<"param" | "value", ({ param, value }: Partial<Record<"param" | "value", LISP.Object | LISP.Object[] | null>>, itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => LISP.Object>;
    defineParameter1: import("./interpreter").BuiltInProcedureDefinition<"param" | "value", ({ param, value }: Partial<Record<"param" | "value", LISP.Object | LISP.Object[] | null>>, itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => LISP.IUndefined>;
    guard: import("./interpreter").BuiltInProcedureDefinition<"body" | "arg1", ({ arg1, body }: Partial<Record<"body" | "arg1", LISP.Object | LISP.Object[] | null>>, _itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => LISP.List>;
    quasiquote: import("./interpreter").BuiltInProcedureDefinition<"template", ({ template }: Partial<Record<"template", LISP.Object | LISP.Object[] | null>>) => LISP.List>;
    quasiquote1: import("./interpreter").BuiltInProcedureDefinition<"template" | "exprs" | "marks", ({ template, marks, exprs }: Partial<Record<"template" | "exprs" | "marks", LISP.Object | LISP.Object[] | null>>) => LISP.Object>;
    letSyntax: import("./interpreter").BuiltInProcedureDefinition<"body" | "bindings", ({ bindings, body }: Partial<Record<"body" | "bindings", LISP.Object | LISP.Object[] | null>>, _itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => LISP.List>;
    letrecSyntax: import("./interpreter").BuiltInProcedureDefinition<"body" | "bindings", ({ bindings, body }: Partial<Record<"body" | "bindings", LISP.Object | LISP.Object[] | null>>, itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => LISP.List>;
    syntaxRules: import("./interpreter").BuiltInProcedureDefinition<"args" | "arg1" | "arg2", ({ arg1, arg2, args }: Partial<Record<"args" | "arg1" | "arg2", LISP.Object | LISP.Object[] | null>>, itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => LISP.ISyntaxRules>;
    applySyntaxRules: import("./interpreter").BuiltInProcedureDefinition<"args" | "spec", ({ spec, args }: Partial<Record<"args" | "spec", LISP.Object | LISP.Object[] | null>>, itrp: Interpreter | undefined, stack: LISP.CallStack | undefined) => LISP.Object>;
    syntaxError: import("./interpreter").BuiltInProcedureDefinition<"message" | "args", ({ message, args }: Partial<Record<"message" | "args", LISP.Object | LISP.Object[] | null>>) => never>;
};
