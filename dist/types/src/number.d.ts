import { LISP } from "./types";
export declare const procedures: {
    numberQ: import("./interpreter").BuiltInProcedureDefinition<"obj", ({ obj }: Partial<Record<"obj", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    realQ: import("./interpreter").BuiltInProcedureDefinition<"obj", ({ obj }: Partial<Record<"obj", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    integerQ: import("./interpreter").BuiltInProcedureDefinition<"obj", ({ obj }: Partial<Record<"obj", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    exactQ: import("./interpreter").BuiltInProcedureDefinition<"z", ({ z }: Partial<Record<"z", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    inexactQ: import("./interpreter").BuiltInProcedureDefinition<"z", ({ z }: Partial<Record<"z", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    exactIntegerQ: import("./interpreter").BuiltInProcedureDefinition<"z", ({ z }: Partial<Record<"z", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    finiteQ: import("./interpreter").BuiltInProcedureDefinition<"z", ({ z }: Partial<Record<"z", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    infiniteQ: import("./interpreter").BuiltInProcedureDefinition<"z", ({ z }: Partial<Record<"z", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    eq: import("./interpreter").BuiltInProcedureDefinition<"z1" | "z2" | "zs", ({ z1, z2, zs }: Partial<Record<"z1" | "z2" | "zs", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    lt: import("./interpreter").BuiltInProcedureDefinition<"z1" | "z2" | "zs", ({ z1, z2, zs }: Partial<Record<"z1" | "z2" | "zs", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    gt: import("./interpreter").BuiltInProcedureDefinition<"z1" | "z2" | "zs", ({ z1, z2, zs }: Partial<Record<"z1" | "z2" | "zs", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    le: import("./interpreter").BuiltInProcedureDefinition<"z1" | "z2" | "zs", ({ z1, z2, zs }: Partial<Record<"z1" | "z2" | "zs", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    ge: import("./interpreter").BuiltInProcedureDefinition<"z1" | "z2" | "zs", ({ z1, z2, zs }: Partial<Record<"z1" | "z2" | "zs", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    nanQ: import("./interpreter").BuiltInProcedureDefinition<"z", ({ z }: Partial<Record<"z", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    zeroQ: import("./interpreter").BuiltInProcedureDefinition<"z", ({ z }: Partial<Record<"z", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    positiveQ: import("./interpreter").BuiltInProcedureDefinition<"z", ({ z }: Partial<Record<"z", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    negativeQ: import("./interpreter").BuiltInProcedureDefinition<"z", ({ z }: Partial<Record<"z", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    oddQ: import("./interpreter").BuiltInProcedureDefinition<"n", ({ n }: Partial<Record<"n", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    evenQ: import("./interpreter").BuiltInProcedureDefinition<"n", ({ n }: Partial<Record<"n", LISP.Object | LISP.Object[] | null>>) => LISP.IBoolean>;
    max: import("./interpreter").BuiltInProcedureDefinition<"xs", ({ xs }: Partial<Record<"xs", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    min: import("./interpreter").BuiltInProcedureDefinition<"xs", ({ xs }: Partial<Record<"xs", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    add: import("./interpreter").BuiltInProcedureDefinition<"zs", ({ zs }: Partial<Record<"zs", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    sub: import("./interpreter").BuiltInProcedureDefinition<"z1" | "zs", ({ z1, zs }: Partial<Record<"z1" | "zs", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    mul: import("./interpreter").BuiltInProcedureDefinition<"zs", ({ zs }: Partial<Record<"zs", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    div: import("./interpreter").BuiltInProcedureDefinition<"z1" | "zs", ({ z1, zs }: Partial<Record<"z1" | "zs", LISP.Object | LISP.Object[] | null>>) => LISP.INumber | LISP.IError>;
    abs: import("./interpreter").BuiltInProcedureDefinition<"x", ({ x }: Partial<Record<"x", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    floorS: import("./interpreter").BuiltInProcedureDefinition<"n1" | "n2", ({ n1, n2 }: Partial<Record<"n1" | "n2", LISP.Object | LISP.Object[] | null>>) => LISP.IMultiValue>;
    floorQuotient: import("./interpreter").BuiltInProcedureDefinition<"n1" | "n2", ({ n1, n2 }: Partial<Record<"n1" | "n2", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    floorRemainder: import("./interpreter").BuiltInProcedureDefinition<"n1" | "n2", ({ n1, n2 }: Partial<Record<"n1" | "n2", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    truncateS: import("./interpreter").BuiltInProcedureDefinition<"n1" | "n2", ({ n1, n2 }: Partial<Record<"n1" | "n2", LISP.Object | LISP.Object[] | null>>) => LISP.IMultiValue>;
    truncateQuotient: import("./interpreter").BuiltInProcedureDefinition<"n1" | "n2", ({ n1, n2 }: Partial<Record<"n1" | "n2", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    truncateRemainder: import("./interpreter").BuiltInProcedureDefinition<"n1" | "n2", ({ n1, n2 }: Partial<Record<"n1" | "n2", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    quotient: import("./interpreter").BuiltInProcedureDefinition<"n1" | "n2", ({ n1, n2 }: Partial<Record<"n1" | "n2", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    remainder: import("./interpreter").BuiltInProcedureDefinition<"n1" | "n2", ({ n1, n2 }: Partial<Record<"n1" | "n2", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    modulo: import("./interpreter").BuiltInProcedureDefinition<"n1" | "n2", ({ n1, n2 }: Partial<Record<"n1" | "n2", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    gcd: import("./interpreter").BuiltInProcedureDefinition<"ns", ({ ns }: Partial<Record<"ns", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    lcm: import("./interpreter").BuiltInProcedureDefinition<"ns", ({ ns }: Partial<Record<"ns", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    floor: import("./interpreter").BuiltInProcedureDefinition<"x", ({ x }: Partial<Record<"x", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    ceiling: import("./interpreter").BuiltInProcedureDefinition<"x", ({ x }: Partial<Record<"x", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    truncate: import("./interpreter").BuiltInProcedureDefinition<"x", ({ x }: Partial<Record<"x", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    rationalize: import("./interpreter").BuiltInProcedureDefinition<"y" | "x", () => never>;
    round: import("./interpreter").BuiltInProcedureDefinition<"x", ({ x }: Partial<Record<"x", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    square: import("./interpreter").BuiltInProcedureDefinition<"x", ({ x }: Partial<Record<"x", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    exactIntegerSqrt: import("./interpreter").BuiltInProcedureDefinition<"k", ({ k }: Partial<Record<"k", LISP.Object | LISP.Object[] | null>>) => LISP.IMultiValue>;
    expt: import("./interpreter").BuiltInProcedureDefinition<"z1" | "z2", ({ z1, z2 }: Partial<Record<"z1" | "z2", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    inexact: import("./interpreter").BuiltInProcedureDefinition<"z", ({ z }: Partial<Record<"z", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    exact: import("./interpreter").BuiltInProcedureDefinition<"z", ({ z }: Partial<Record<"z", LISP.Object | LISP.Object[] | null>>) => LISP.INumber>;
    numberToString: import("./interpreter").BuiltInProcedureDefinition<"z" | "radix", ({ z, radix }: Partial<Record<"z" | "radix", LISP.Object | LISP.Object[] | null>>) => LISP.IString>;
    stringToNumber: import("./interpreter").BuiltInProcedureDefinition<"str" | "radix", ({ str, radix }: Partial<Record<"str" | "radix", LISP.Object | LISP.Object[] | null>>) => LISP.INumber | LISP.IBoolean>;
};
