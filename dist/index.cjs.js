"use strict";var e=Object.defineProperty,r=Object.defineProperties,t=Object.getOwnPropertyDescriptors,n=Object.getOwnPropertySymbols,a=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable,i=(r,t,n)=>t in r?e(r,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):r[t]=n,l=(e,r)=>{for(var t in r||(r={}))a.call(r,t)&&i(e,t,r[t]);if(n)for(var t of n(r))o.call(r,t)&&i(e,t,r[t]);return e},s=(e,n)=>r(e,t(n)),c=("undefined"!=typeof require&&require,(e,r,t)=>(i(e,"symbol"!=typeof r?r+"":r,t),t));Object.defineProperty(exports,"__esModule",{value:!0}),exports[Symbol.toStringTag]="Module";const u="cumalis-lisp",m={quote:"'",quasiquote:"`",unquote:",","unquote-splicing":",@"},d=/^(?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+$/,p={"":"\\a","\b":"\\b","\t":"\\t","\n":"\\n","\r":"\\r",'"':'\\"',"\\":"\\\\","|":"\\|"},f=e=>{let r="",t="";for(const n of e){const e=n.length>2&&0===n.indexOf('""')?n.replace(/^""/,"").replace(/""$/,""):n;r=r+(""===r||"("===t.slice(-1)||")"===n||Object.values(m).indexOf(t)>=0||/^#\d+=$/.test(t)&&"("===n?"":" ")+e,t=n}return r},b=e=>{const r=e=>{const t=[];for(const n of e)if("string"==typeof n)t.push(n);else if(n instanceof Array)if("string"==typeof n[0]&&Object.values(m).includes(n[0]))t.push(...r(n));else if("#"===n[0]||"#u8"===n[0]){if(2!==n.length||!(n[1]instanceof Array))throw new Error("Illegal token tree: #/#u8 must have only one token array");t.push(`${n[0]}(`),t.push(...r(n[1])),t.push(")")}else if("string"==typeof n[0]&&/^#\d+=/.exec(n[0])){if(2!==n.length)throw new Error("Illegal token tree: datum label must have the content");t.push(n[0],...r(n.splice(1)))}else t.push("("),t.push(...r(n)),t.push(")");return t};return r(e)},y=(e,r)=>{const{extended:t=!1,style:n="write",labels:a="cyclic",maxdepth:o=1/0}=null!=r?r:{},i=new Set,l=new Set,s=(e,r,n)=>{if(z.Object(e),!t&&r>o)return;if(!t&&("cyclic"===a&&n.has(e)||"shared"===a&&i.has(e)))return void l.add(e);i.add(e);const c=new Set(n);c.add(e),$.Pair(e)?(s(e[1],r+1,c),s(e[2],r+1,c)):$.Vector(e)&&e[1].forEach((e=>s(e,r+1,c)))};s(e,0,new Set);const c=new Map,u=(e,r,a=!1)=>{var i;if(z.Object(e),!t&&r>o)return"...";if(!a&&!t&&l.has(e)){if(c.has(e))return`#${c.get(e)}#`;{const t=c.size+1;c.set(e,t);return[`#${t}=`,u(e,r,!0)]}}switch(e[0]){case"<symbol>":return t||d.test(e[1])?e[1]:"|"+e[1].replace(/[\x00-\x1f\x7f"|\\]/g,(e=>{var r,t;return null!=(t=p[e])?t:`\\x${null==(r=e.codePointAt(0))?void 0:r.toString(16)}`}))+"|";case"<null>":return t?null:[];case"<string>":return t?e[1]:"display"!==n?'"'+e[1].replace(/[\x00-\x1f\x7f]"|\\/g,(e=>{var r,t;return null!=(t=p[e])?t:`\\x${null==(r=e.codePointAt(0))?void 0:r.toString(16)}`}))+'"':'""'+e[1]+'""';case"<number>":return t?v(e):`${e[1]}`;case"<boolean>":return t?e[1]:e[1]?"#t":"#f";case"<character>":if(t)return e[1];if("display"!==n){const[r]=null!=(i=Object.entries(te).find((([,r])=>r===e[1])))?i:[];return`#\\${null!=r?r:e[1]}`}return'""'+e[1]+'""';case"<vector>":return["#",[...e[1].map((e=>u(e,r+1)))]];case"<bytevector>":return["#u8",[...e[1].map((e=>`${e}`))]];case"<pair>":const[,a,o]=e;if("<null>"===o[0])return[u(a,r+1)];if("<pair>"!==o[0])return[u(a,r+1),".",u(o,r+1)];if("<symbol>"===a[0]&&m[a[1]]){const e=u(o,r+1);return e instanceof Array&&!$.Object(e)?[m[a[1]],...e]:[m[a[1]],e]}{const e=u(a,r+1),t=u(o,r+1);return t instanceof Array&&!$.Object(t)?[e,...t]:[e,".",t]}case"<js>":return t?["&",e[1]]:`#<$js[${null===e[1]?"null":typeof e[1]}]>`;case"<procedure>":return t?e:"built-in"===e[1]?`#<procedure[built-in/${e[2]}]>`:`#<procedure[${e[1]}]>`;default:return t?e:`#${e[0]}`}};return u(e,0)},h=(e,r={})=>{try{const t=y(e,s(l({maxdepth:8},r),{extended:!1})),n=b([t]);return f(n)}catch(t){return"<!!WRITE-ERROR!!>"}},g=(e,r={})=>{const t=y(e,s(l({},r),{extended:!1}));if(!(t instanceof Array&&"begin"===t[0]))throw new Error('fromASTToText error: The top of AST is must be a "begin" expression.');const n=b(t.slice(1));return f(n)},v=e=>"number"==typeof e[1]?e[1]:"+inf.0"===e[1]?1/0:"-inf.0"===e[1]?-1/0:NaN,S=e=>C.Number(Number.isFinite(e)?Number.isNaN(e)?"+nan.0":e:e<0?"-inf.0":"+inf.0"),w=e=>e[2],x=e=>e[1],j=e=>e[2],P=e=>{const r=[];for(let t=e;t;t=j(t))r.push(t);return r},E=e=>e[1],N=e=>["#CALL-STACK#",{depth:0,env:{static:C.StaticNS({},null),dynamic:C.DynamicNS({},null)},expr:e,want:null,oper:null,args:null,before:null,after:null,handler:null,info:$.Pair(e)&&e[4]||null},null],I=(e,r,t={})=>{var n,a,o;const{env:i,handler:l,depth:s,info:c}=E(e);return["#CALL-STACK#",{depth:s+1,env:null!=(n=t.env)?n:i,expr:r,want:null,oper:null,args:null,before:null!=(a=t.before)?a:null,after:null!=(o=t.after)?o:null,handler:l,info:$.Pair(r)&&r[4]||c},e]},B=(e,r,t={})=>{var n,a,o;const{env:i,handler:l,depth:s,info:c,before:u,after:m}=E(e);return["#CALL-STACK#",{depth:s,env:null!=(n=t.env)?n:i,expr:r,want:null!=(a=t.want)?a:null,oper:null!=(o=t.oper)?o:null,args:null,before:void 0===t.before?u:t.before,after:void 0===t.after?m:t.after,handler:void 0!==t.handler?t.handler:l,info:$.Pair(r)&&r[4]||c},j(e)]},O=e=>[e[0],{},e],C={Symbol:(...e)=>["<symbol>",...e],String:(...e)=>["<string>",...e],Number:(...e)=>["<number>",...e],Boolean:(...e)=>["<boolean>",...e],Character:(...e)=>["<character>",...e],Pair:(e,r,t=!1,n)=>n?["<pair>",e,r,t,n]:["<pair>",e,r,t],Null:()=>["<null>"],Vector:(...e)=>["<vector>",...e],ByteVector:(...e)=>["<bytevector>",...e],EndOfFile:(...e)=>["<end-of-file>",...e],Procedure:(...e)=>["<procedure>",...e],Port:(...e)=>["<port>",...e],RecordType:(...e)=>["<record-type>",...e],Record:(...e)=>["<record>",...e],SyntaxRules:(...e)=>["<syntax-rules>",...e],Parameter:(...e)=>["<parameter>",...e],MultiValue:(...e)=>["<multi-value>",...e],Exception:(...e)=>["<exception>",...e],Undefined:(...e)=>["<undefined>",...e],Promise:(...e)=>["<promise>",...e],Error:(e,r,t=[])=>["<error>",e,r,t],Continuation:(...e)=>["<continuation>",...e],EnvironmentSpec:(...e)=>["<environment-spec>",...e],Library:(...e)=>["<library>",...e],JS:(...e)=>["<js>",...e],List:(...e)=>e.reverse().reduce(((e,r)=>["<pair>",r,e,!1]),["<null>"]),Suspend:(...e)=>["#SUSPEND#",...e],JSPromiseContinuation:(...e)=>["#JS-PROMISE-CONTINUATION#",...e],Exit:(...e)=>["#EXIT#",...e],StaticNS:(...e)=>["#STATIC-NS-STACK#",...e],DynamicNS:(...e)=>["#DYNAMIC-NS-STACK#",...e],HandlerStack:(...e)=>["#HANDLER-STACK#",...e]},A={Call:(e,...r)=>C.List(e,...r),CallBuiltIn:(e,...r)=>C.List(C.Procedure("built-in",e),...r),Lambda:(...e)=>$.List(e[0])?A.CallBuiltIn("lambda",...e):A.CallBuiltIn("lambda",J(e[0],e[1]),...e.slice(2)),CallThunk:(...e)=>A.Call(A.CallBuiltIn("lambda",["<null>"],...e)),Begin:(...e)=>A.CallBuiltIn("begin",...e),Quote:e=>A.CallBuiltIn("quote",e),Set:(e,r)=>A.CallBuiltIn("set!",e,r),Raise:e=>A.CallBuiltIn("raise",e),RaiseContinuable:e=>A.CallBuiltIn("raise-continuable",e),Let:(e,...r)=>A.CallBuiltIn("let",C.List(...e.map((e=>C.List(...e)))),...r),If:(e,r,t)=>t?A.CallBuiltIn("if",e,r,t):A.CallBuiltIn("if",e,r),And:(...e)=>A.CallBuiltIn("and",...e),Or:(...e)=>A.CallBuiltIn("or",...e),Cond:(e,...r)=>A.CallBuiltIn("cond",e,...r),Case:(e,r)=>A.CallBuiltIn("case",e,C.List(...r.map((e=>C.List(...e))))),Define:(...e)=>A.CallBuiltIn("define",...e),DefineValues:(e,r)=>A.CallBuiltIn("define-values",$.List(e)?e:C.List(...e),r),Append:(...e)=>A.CallBuiltIn("append",...e),Cons:(...e)=>A.CallBuiltIn("cons",...e),Values:(...e)=>A.CallBuiltIn("values",...e),BeginIfMultiple:(...e)=>0===e.length?["<undefined>"]:1===e.length?e[0]:A.Begin(...e)},$={Symbol:e=>e instanceof Array&&"<symbol>"===e[0],String:e=>e instanceof Array&&"<string>"===e[0],Number:e=>e instanceof Array&&"<number>"===e[0],Boolean:e=>e instanceof Array&&"<boolean>"===e[0],Character:e=>e instanceof Array&&"<character>"===e[0],Pair:e=>e instanceof Array&&"<pair>"===e[0],Null:e=>e instanceof Array&&"<null>"===e[0],Vector:e=>e instanceof Array&&"<vector>"===e[0],ByteVector:e=>e instanceof Array&&"<bytevector>"===e[0],EndOfFile:e=>e instanceof Array&&"<end-of-file>"===e[0],Port:e=>e instanceof Array&&"<port>"===e[0],RecordType:e=>e instanceof Array&&"<record-type>"===e[0],Record:e=>e instanceof Array&&"<record>"===e[0],MultiValue:e=>e instanceof Array&&"<multi-value>"===e[0],SyntaxRules:e=>e instanceof Array&&"<syntax-rules>"===e[0],SyntaxRulePattern:e=>e instanceof Array&&"<syntax-rule-pattern>"===e[0],Parameter:e=>e instanceof Array&&"<parameter>"===e[0],EnvironmentSpec:e=>e instanceof Array&&"<environment-spec>"===e[0],Exception:e=>e instanceof Array&&"<exception>"===e[0],Undefined:e=>e instanceof Array&&"<undefined>"===e[0],Promise:e=>e instanceof Array&&"<promise>"===e[0],Error:e=>e instanceof Array&&"<error>"===e[0],Continuation:e=>e instanceof Array&&"<continuation>"===e[0],Library:e=>e instanceof Array&&"<library>"===e[0],JS:e=>e instanceof Array&&"<js>"===e[0],List:e=>$.Pair(e)||$.Null(e),Procedure:e=>e instanceof Array&&("<procedure>"===e[0]||"<continuation>"===e[0]||"<parameter>"===e[0]),Object:e=>e instanceof Array&&"string"==typeof e[0]&&/^<.*>/.test(e[0]),Evaluatable:e=>$.List(e)||$.Symbol(e),False:e=>$.Boolean(e)&&!1===e[1],RealNumber:e=>$.Number(e)&&"number"==typeof e[1],IntegerNumber:e=>$.Number(e)&&"number"==typeof e[1]&&Number.isInteger(e[1]),Objects:e=>e instanceof Array&&e.every((e=>$.Object(e))),Suspend:e=>e instanceof Array&&"#SUSPEND#"===e[0],JSPromiseContinuation:e=>e instanceof Array&&"#JS-PROMISE-CONTINUATION#"===e[0],Exit:e=>e instanceof Array&&"#EXIT#"===e[0],CallStack:e=>e instanceof Array&&"#CALL-STACK#"===e[0],SpecialObject:e=>e instanceof Array&&"string"==typeof e[0]&&/^#.+#$/.test(e[0]),Dictionary:e=>"object"==typeof e&&!!e&&e.constructor===Object,Stack:e=>e instanceof Array&&3===e.length&&"string"==typeof e[0]&&/^#.*-STACK#$/.test(e[0])},L=(e,r)=>(t,n)=>{if(!e(t))throw C.Error("domain-error",null!=n?n:r)},k=(e,r)=>(t,n)=>{if(!(t instanceof Array))throw C.Error("domain-error",null!=n?n:r);for(const a of t)if(!e(a))throw C.Error("domain-error",null!=n?n:r)},z={List:L($.List,"A <pair> or <null> is expected."),Pair:L($.Pair,"A <pair> is expected."),Symbol:L($.Symbol,"A <symbol> is expected."),Number:L($.Number,"A <number> is expected."),Boolean:L($.Boolean,"A <boolean> is expected."),Object:L($.Object,"A Scheme object is expected."),String:L($.String,"A <string> is expected."),Vector:L($.Vector,"A <vector> is expected."),ByteVector:L($.ByteVector,"A <bytevector> is expected."),Character:L($.Character,"A <character> is expected."),Promise:L($.Promise,"A <promise> is expected."),Error:L($.Error,"A <error> is expected."),Procedure:L($.Procedure,"A <procedure> is expected."),SyntaxRules:L($.SyntaxRules,"A <syntax-rules> is expected."),Parameter:L($.Parameter,"A <parameter> is expected."),EnvironmentSpec:L($.EnvironmentSpec,"A <environment-spec> is expected."),RecordType:L($.RecordType,"A <record-type> is expected."),Record:L($.Record,"A <record> is expected."),MultiValue:L($.MultiValue,"A <multi-value> is expected."),Port:L($.Port,"A <port> is expected."),Library:L($.Library,"A <library> is expected."),Lists:k($.List,"An array of <pair>/<null> is expected."),Pairs:k($.Pair,"An array of <pair> is expected."),Symbols:k($.Symbol,"An array of <symbol> is expected."),Numbers:k($.Number,"An array of <number> is expected."),Booleans:k($.Boolean,"An array of <boolean> is expected."),Objects:k($.Object,"An array of Scheme object is expected."),Strings:k($.String,"An array of <string> is expected."),Vectors:k($.Vector,"An array of <vector> is expected."),ByteVectors:k($.ByteVector,"An array of  <bytevector> is expected."),Characters:k($.Character,"An array of <character> is expected."),RealNumber:L($.RealNumber,"A real <number> (not infinite, not NaN) is expected."),IntegerNumber:L($.IntegerNumber,"A integer <number> is expected."),RealNumbers:k($.RealNumber,"An array of real <number> is expected."),IntegerNumbers:k($.IntegerNumber,"An array of integer <number> is expected.")},V=(e,r)=>{if(null==e)throw C.Error("program-error",null!=r?r:"Required object.")},M=e=>"object"==typeof e&&null!==e&&"Object"===e.constructor.name,q=e=>!!e&&"object"==typeof e&&e.language===u&&!!e.version&&($.Object(e.content)||$.SpecialObject(e.content)),T=e=>q(e)&&$.Suspend(e.content),D=e=>q(e)&&$.JSPromiseContinuation(e.content),R=D,Q=Object.prototype.hasOwnProperty,U=e=>{const r=new Set,t=e=>{if($.Pair(e)){const[,n,a]=e;if(r.has(a))throw new Error("Circular list detected.");return r.add(a),[n,...t($.List(a)?a:["<null>"])]}return[]};return t(e)},F=e=>{const r=new Set;return(e=>{const[,t,n]=e;if($.Pair(n)){if(r.has(n))throw new Error("Circular list detected.");r.add(n);const[e,a]=F(n);return[[t,...e],a]}return[[t],n]})(e)},J=(e,r,t=!1,n)=>e.reverse().reduce(((r,a,o)=>n&&o===e.length-1?C.Pair(a,r,t,n):C.Pair(a,r,t)),r||["<null>"]),_=(()=>{let e=0,r=0,t=0;return()=>"::"+"T-S-XXXXXXX".replace(/[TSX]/g,(n=>(r=Date.now(),"T"===n?`0000000000000${r.toString(16)}`.slice(-14):"S"===n?`000${(e===r?(e=r,t=0):t++).toString(16)}`.slice(-4):`000${(65536*Math.random()|0).toString(16)}`.slice(-4))))})(),X=(e,r,t,n=!1,a=!1)=>{if(r.filter((e=>"variadic"===e.type)).length>1)throw new Error("Only one variadic parameter is allowed.");return{name:e,parameters:r,body:t,isMacro:n,hidden:a}},Z=(e,r)=>s(l({},r),{name:e}),K=(e,r)=>e.length===r.length&&e.every(((e,t)=>e===r[t])),W=e=>{var r,t;if($.List(e)){if($.Null(e))return[[],null];{const[t,n]=F(e);return z.Symbols(t),$.Null(n)||z.Symbol(n),[t.map((e=>{var r;return{name:null!=(r=e[3])?r:e[1]}})),$.Null(n)?null:{name:null!=(r=n[3])?r:n[1],type:"variadic"}]}}return z.Symbol(e),[[],{name:null!=(t=e[3])?t:e[1],type:"variadic"}]},G={"µ":"μ","ͅ":"ι","ς":"σ","ϐ":"β","ϑ":"θ","ϕ":"φ","ϖ":"π","ϰ":"κ","ϱ":"ρ","ϵ":"ε","ᏸ":"Ᏸ","ᏹ":"Ᏹ","ᏺ":"Ᏺ","ᏻ":"Ᏻ","ᏼ":"Ᏼ","ᏽ":"Ᏽ","ᲀ":"в","ᲁ":"д","ᲂ":"о","ᲃ":"с","ᲄ":"т","ᲅ":"т","ᲆ":"ъ","ᲇ":"ѣ","ᲈ":"ꙋ","ẛ":"ṡ","ι":"ι","ꭰ":"Ꭰ","ꭱ":"Ꭱ","ꭲ":"Ꭲ","ꭳ":"Ꭳ","ꭴ":"Ꭴ","ꭵ":"Ꭵ","ꭶ":"Ꭶ","ꭷ":"Ꭷ","ꭸ":"Ꭸ","ꭹ":"Ꭹ","ꭺ":"Ꭺ","ꭻ":"Ꭻ","ꭼ":"Ꭼ","ꭽ":"Ꭽ","ꭾ":"Ꭾ","ꮀ":"Ꮀ","ꮁ":"Ꮁ","ꮂ":"Ꮂ","ꮃ":"Ꮃ","ꮄ":"Ꮄ","ꮅ":"Ꮅ","ꮆ":"Ꮆ","ꮇ":"Ꮇ","ꮈ":"Ꮈ","ꮉ":"Ꮉ","ꮊ":"Ꮊ","ꮋ":"Ꮋ","ꮌ":"Ꮌ","ꮍ":"Ꮍ","ꮎ":"Ꮎ","ꮐ":"Ꮐ","ꮑ":"Ꮑ","ꮒ":"Ꮒ","ꮓ":"Ꮓ","ꮔ":"Ꮔ","ꮕ":"Ꮕ","ꮖ":"Ꮖ","ꮗ":"Ꮗ","ꮘ":"Ꮘ","ꮙ":"Ꮙ","ꮚ":"Ꮚ","ꮛ":"Ꮛ","ꮜ":"Ꮜ","ꮝ":"Ꮝ","ꮞ":"Ꮞ","ꮠ":"Ꮠ","ꮡ":"Ꮡ","ꮢ":"Ꮢ","ꮣ":"Ꮣ","ꮤ":"Ꮤ","ꮥ":"Ꮥ","ꮦ":"Ꮦ","ꮧ":"Ꮧ","ꮨ":"Ꮨ","ꮩ":"Ꮩ","ꮪ":"Ꮪ","ꮫ":"Ꮫ","ꮬ":"Ꮬ","ꮭ":"Ꮭ","ꮮ":"Ꮮ","ꮰ":"Ꮰ","ꮱ":"Ꮱ","ꮲ":"Ꮲ","ꮳ":"Ꮳ","ꮴ":"Ꮴ","ꮵ":"Ꮵ","ꮶ":"Ꮶ","ꮷ":"Ꮷ","ꮸ":"Ꮸ","ꮹ":"Ꮹ","ꮺ":"Ꮺ","ꮻ":"Ꮻ","ꮼ":"Ꮼ","ꮽ":"Ꮽ","ꮾ":"Ꮾ"},H=new RegExp("["+Object.keys(G).join("")+"]","gu"),Y=e=>e.replace(H,(e=>G[e])).toLowerCase(),ee=new RegExp("(?:"+[/\s+/.source,/;[^\n]*(?:\n|$)/.source,/(?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+/.source,/\|(?:[^|\\]|\n|\\(?:.|\n))+\|/.source,/#!(?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+/.source,/"(?:[^"\\]|\n|\\(?:.|\n))*"/.source,/(?:[()[\]{}'`]|,(?!@)|,@)/.source,/#(?:t(?:rue)?|f(?:alse)?|\(|u8\(|\d+[#=]|;)/.source,/#[dDbBoOxXeEiI](?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+/.source,/#\\(?:(?:[^A-Za-z]|\n)|[A-Za-z](?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])*)/.source,Array(16).fill(/#\|(?:[^|#]|\|[^#]|#[^|]|\n|(?:NEST))*\|#/.source).reduce(((e,r)=>e.replace("NEST",r)))].join("|")+")","y"),re={a:"",b:"\b",t:"\t",n:"\n",r:"\r"},te={alarm:"",backspace:"\b",delete:"",escape:"",newline:"\n",null:"\0",return:"\r",space:" ",tab:"\t"},ne=(e,r)=>{var t;const n=(e=>{const r=[0],t=/\n/g;for(let n;n=t.exec(e);)r.push(n.index+1);return t=>{var n;const a=r.filter((e=>e<=t)).slice(-1)[0],o=e.slice(a,t);return[r.indexOf(a)+1,o.length+(null!=(n=o.match(/[^\x01-\x7E\xA1-\xDF]/g))?n:[]).length+1]}})(e),a=[];ee.lastIndex=0;let o=!1;for(;ee.lastIndex<e.length;){const i=ee.lastIndex,[l,s]=n(i),c=r?{filename:r,line:l,column:s}:{line:l,column:s};let[u]=null!=(t=ee.exec(e))?t:[];if(null==u){const r=e.slice(i).split(/(\s|\n)+/,2)[0]||e[i],t=r.length>10?r.slice(0,10)+"...":r;throw new Error(`Tokenize failed. Unexpected token is: "${t}": ${JSON.stringify(c)}`)}"#!fold-case"!==u&&"#!no-fold-case"!==u?(o&&(u.match(/^(?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+$/)||u.match(/#\\(?:(?:[^A-Za-z]|\n)|[A-Za-z](?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])*)/))&&(u=Y(u)),a.push([u,c])):o=!u.includes("#!no-")}return a},ae=e=>{const r=e.filter((e=>!e[0].match(/^(\s|;|#\||#!(no-)?fold-case)/))),t=()=>{const e=[];for(let n=r.shift();n;n=r.shift()){const[r,a]=n;if(!r.match(/^(\s|;|#\|)/))if("("===r)e.push(t().concat(a));else if(["#(","#u8("].includes(r))e.push([r.slice(0,-1),t(),a]);else{if(["'","`",",",",@","#;"].includes(r)||r.match(/^#\d+=$/)){const n=t(),o=n.shift();if(null==o)throw`Unexpected end of source after quoting/datum label "${r}": ${JSON.stringify(a)}`;return"#;"!==r&&e.push([r,o]),e.push(...n),e}if(")"===r)return e;e.push(r)}}return e};return[t(),r]},oe=(e,r=null,t,n=new Map)=>{var a;if("string"==typeof e){let t;if(t=/^([+-])(nan|inf)\.0$/i.exec(e))return C.Number(t[0].toLowerCase());if(t=/^(?:#d)?[-+]?\d+(?:\.\d*)?(?:e[-+]?\d+)?$/i.exec(e))return S(Number(e.replace(/^(#d)?0*/i,"")));if(t=/^(?:#b[-+]?[01]+|#o[-+]?[0-7]+|#x[-+]?[0-9A-Fa-f]+)/i.exec(e))return S(Number(e.replace(/^#([xob])([+-]?)/i,"0$1"))*(e.includes("-")?-1:1));if(/^#[dboxei]/i.exec(e))throw new Error(`Unsupported type of number literal: ${e}: ${JSON.stringify(r)}`);if(t=/^"((?:.|\n)*)"$/.exec(e)){const e=t[1].replace(/\\(x[0-9a-fA-F]+;|[ \t]*\n[ \t]*|[^x \t\n])/g,(e=>{var r;return"x"===e[1]?String.fromCodePoint(Number(`0x${e.replace(/;$/,"").slice(2)}`)):/\s|\n/.test(e[1])?"":null!=(r=re[e[1]])?r:e[1]}));return C.String(e,!0)}if(t=/^#([tf])/.exec(e))return C.Boolean("t"===t[1]);if(t=/^#\\((.|\n)*)$/.exec(e)){const e=1===t[1].length?t[1]:t[1].match(/^x[0-9A-Fa-f]+$/)?String.fromCodePoint(Number(`0x${t[1].slice(1)}`)):te[t[1]];if(!e)throw new Error(`Illegal character literal: ${e}: ${JSON.stringify(r)}`);return C.Character(e)}if("."!==e&&(t=/^(([A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+)$/.exec(e)))return C.Symbol(t[1]);if("."!==e&&(t=/^\|(([^\\]|\n|\\(.|\n))+)\|$/.exec(e))){const e=t[1].replace(/\\(x[0-9a-fA-F]+;|\s*\n\s*|[^x\s\n])/g,(e=>{var r;return"x"===e[1]?String.fromCodePoint(Number(`0x${e.replace(/;$/,"").slice(2)}`)):/\s|\n/.test(e[1])?"":null!=(r=re[e[1]])?r:e[1]}));return C.Symbol(e)}if(t=/^#(\d+)#$/.exec(e)){const a=t[1];if(!n.has(a))throw new Error(`Invalid datum reference (${e}): ${JSON.stringify(r)}`);return n.get(a)}throw new Error(`Parse error: unexpected token: "${e}": ${JSON.stringify(r)}`)}if(e instanceof Array&&"&"!==e[0]){r=null!=(a=e.find((e=>M(e))))?a:r;const o=e.filter((e=>!M(e)));if(0===o.length)return C.Null();if(2===o.length&&"."===o[0])return oe(o[1],r,t,n);if("#"===o[0]){if(2!==o.length)throw new Error(`Illegal vector literal. No datum: ${JSON.stringify(r)}`);if(!(o[1]instanceof Array))throw new Error(`Illegal vector literal. Datum is not an array: ${JSON.stringify(r)}`);return C.Vector(o[1].map((e=>oe(e,r,t,n))),!0)}if("#u8"===o[0]){if(2!==o.length)throw new Error(`Illegal byte vector literal. No datum: ${JSON.stringify(r)}`);if(!(o[1]instanceof Array))throw new Error(`Illegal byte vector literal. Byte vector must have an array: ${JSON.stringify(r)}`);const e=o[1].map((e=>oe(e,r,t,n)));if(!e.every((e=>$.RealNumber(e)&&Number.isInteger(e[1])&&e[1]>=0&&e[1]<=255)))throw new Error(`Illegal byte vector literal. All the contents of a byte vector must be 0-255.: ${JSON.stringify(r)}`);return C.ByteVector(e.map(v),!0)}if("string"==typeof o[0]&&["'","`",",",",@"].includes(o[0])){if(2!==o.length)throw new Error(`Illegal quote "${o[0]}". Quoted item must be a datum: ${JSON.stringify(r)}`);const e={"'":"quote","`":"quasiquote",",":"unquote",",@":"unquote-splicing"}[o[0]];return C.Pair(C.Symbol(e),C.Pair(oe(o[1],r,t,n),C.Null(),!0),!0,(null==t?void 0:t.removeLineInfo)?null:r)}if("string"==typeof o[0]&&/^#(\d+)=$/.exec(o[0])){const[,e]=/^#(\d+)=$/.exec(o[0]);if(2!==o.length)throw new Error(`Illegal datum label. No next datum: ${JSON.stringify(r)}`);const a=C.Symbol(o[0]);n.set(e,a);const i=oe(o[1],r,t,n);return a.splice(0,a.length,...i),a}if((null==t?void 0:t.extended)&&$.Object(e))return e;if((null==t?void 0:t.extended)&&"&"===e[0]){if(2!=e.length)throw new Error(`Parse error: JS Node must be like ["&", <object>]: ${typeof e} value: ${e}`);return C.JS("inline",e[1])}return C.Pair(oe(o[0],r,t,n),oe(o.slice(1),r,t,n),!0,(null==t?void 0:t.removeLineInfo)?null:r)}if((null==t?void 0:t.extended)&&null===e)return C.Null();if((null==t?void 0:t.extended)&&"number"==typeof e)return S(e);if((null==t?void 0:t.extended)&&"boolean"==typeof e)return C.Boolean(e);throw new Error(`Parse error: unexpected node type: ${typeof e} value: ${e}`)},ie=(e,r=null,t)=>oe(e,r,s(l({},null!=t?t:{}),{extended:!0})),le=(e,r)=>{const t=ne(e,null==r?void 0:r.filename),[n,a]=ae(t);if(a.length>0)throw new Error(`Parse error: extra tokens. (missing right curly?), ${JSON.stringify(a[0][1])}`);return oe(["begin",...n],null,r)},se=X("not",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.False(e))))),ce=X("boolean?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.Boolean(e))))),ue=X("boolean=?",[{name:"boolean1"},{name:"boolean2"},{name:"booleans",type:"variadic"}],(({boolean1:e,boolean2:r,booleans:t})=>(z.Boolean(e),z.Boolean(r),z.Booleans(t),C.Boolean([r,...t].every((r=>r[1]===e[1])))))),me={not:se,booleanQ:ce,booleanEQ:ue},de=X("bytevector?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.ByteVector(e))))),pe=X("make-bytevector",[{name:"k"},{name:"byte",type:"optional"}],(({k:e,byte:r})=>(z.IntegerNumber(e),r&&z.IntegerNumber(r),C.ByteVector(Array(e[1]).fill(r?r[1]:0),!1)))),fe=X("bytevector",[{name:"bytes",type:"variadic"}],(({bytes:e})=>(z.IntegerNumbers(e),C.ByteVector(e.map((e=>e[1])),!1)))),be=X("bytevector-length",[{name:"bvec"}],(({bvec:e})=>(z.ByteVector(e),C.Number(e[1].length)))),ye=X("bytevector-u8-ref",[{name:"bvec"},{name:"k"}],(({bvec:e,k:r})=>{if(z.ByteVector(e),z.IntegerNumber(r),!(r[1]in e[1]))throw C.Error("out-of-range","Index is out of range.");return C.Number(e[1][r[1]])})),he=X("bytevector-u8-set!",[{name:"bvec"},{name:"k"},{name:"byte"}],(({bvec:e,k:r,byte:t})=>{if(z.ByteVector(e),z.IntegerNumber(r),z.IntegerNumber(t),!(r[1]in e[1]))throw C.Error("out-of-range","Index is out of range.");return e[1][r[1]]=t[1],["<undefined>"]})),ge=X("bytevector-copy",[{name:"bvec"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({bvec:e,start:r,end:t})=>{z.ByteVector(e);const n=e[1];if(0===n.length)return C.ByteVector([],!1);const a=$.Number(r)?r[1]:0,o=$.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw C.Error("domain-error","Index must be integer.");return C.ByteVector(n.slice(a,o),!1)})),ve=X("bytevector-copy!",[{name:"to"},{name:"at"},{name:"from"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({to:e,at:r,from:t,start:n,end:a})=>{z.ByteVector(e),z.IntegerNumber(r),z.ByteVector(t);const o=$.Number(n)?n[1]:0,i=$.Number(a)?a[1]:t[1].length;if("number"!=typeof o||!Number.isInteger(o)||"number"!=typeof i||!Number.isInteger(i))throw C.Error("domain-error","Index must be integer.");if(!(r[1]in e[1]))throw C.Error("out-of-range","Index is out of range.");if(e[1].length-r[1]<i-o)throw C.Error("out-of-range","Index is out of range.");const l=t[1].slice(o,i);return e[1].splice(r[1],l.length,...l),["<undefined>"]})),Se=X("bytevector-append",[{name:"vecs",type:"variadic"}],(({vecs:e})=>(z.ByteVectors(e),C.ByteVector(e.map((e=>e[1])).flat(),!1)))),we=X("utf8->string",[{name:"bvec"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({bvec:e,start:r,end:t})=>{z.ByteVector(e);const n=e[1],a=$.Number(r)?r[1]:0,o=$.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw C.Error("domain-error","Index must be integer.");const i=new Uint8Array(n.slice(a,o));return C.String((new TextDecoder).decode(i),!1)})),xe=X("string->utf8",[{name:"str"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,start:r,end:t})=>{z.String(e);const n=Array.from(e[1]),a=$.Number(r)?r[1]:0,o=$.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw C.Error("domain-error","Index must be integer.");const i=(new TextEncoder).encode(n.slice(a,o).join(""));return C.ByteVector(Array.from(i),!1)})),je={bytevectorQ:de,makeBytevector:pe,bytevector:fe,bytevectorLength:be,bytevectorU8Ref:ye,bytevectorU8SetD:he,bytevectorCopy:ge,bytevectorCopyD:ve,bytevectorAppend:Se,utf8ToString:we,stringToUtf8:xe},Pe=X("char?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.Character(e))))),Ee=X("char=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>(z.Character(e),z.Character(r),z.Characters(t),C.Boolean([r,...t].every((r=>r[1]===e[1])))))),Ne=X("char<?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{z.Character(e),z.Character(r),z.Characters(t);const n=[e,r,...t].map((e=>e[1]));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]<e)))})),Ie=X("char>?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{z.Character(e),z.Character(r),z.Characters(t);const n=[e,r,...t].map((e=>e[1]));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]>e)))})),Be=X("char<=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{z.Character(e),z.Character(r),z.Characters(t);const n=[e,r,...t].map((e=>e[1]));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]<=e)))})),Oe=X("char>=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{z.Character(e),z.Character(r),z.Characters(t);const n=[e,r,...t].map((e=>e[1]));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]>=e)))})),Ce=X("char->integer",[{name:"char"}],(({char:e})=>{z.Character(e);const r=e[1].codePointAt(0);if(void 0===r)throw C.Error("out-of-range","Can't convert character to codepoint.");return C.Number(r)})),Ae=X("integer->char",[{name:"n"}],(({n:e})=>(z.IntegerNumber(e),C.Character(String.fromCodePoint(e[1]))))),$e={charQ:Pe,charEQ:Ee,charLtQ:Ne,charGtQ:Ie,charLeQ:Be,charGeQ:Oe,charToInteger:Ce,integerToChar:Ae},Le=X("procedure?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.Procedure(e)))),!0),ke=X("apply",[{name:"proc"},{name:"args",type:"variadic"}],(({proc:e,args:r},t,n)=>{let a;if(z.Procedure(e),z.Objects(r),V(t),V(n),0===r.length)a=[];else{const[e,t]=[r.slice(0,r.length-1),r[r.length-1]];z.List(t),a=[...e,...U(t)]}return A.Call(e,C.MultiValue(a))}),!0),ze=X("map",[{name:"proc"},{name:"list1"},{name:"lists",type:"variadic"}],(({proc:e,list1:r,lists:t})=>{z.Procedure(e),z.List(r),z.Lists(t);const n=[r,...t];return n.every((e=>$.Pair(e)))?A.Cons(A.Call(e,C.MultiValue(n.map((e=>e[1])))),A.CallBuiltIn("map",C.MultiValue([e,...n.map((e=>e[2]))]))):A.Quote(["<null>"])}),!0),Ve=X("string-map",[{name:"proc"},{name:"str1"},{name:"strs",type:"variadic"}],(({proc:e,str1:r,strs:t})=>{z.Procedure(e),z.String(r),z.Strings(t);const n=[Array.from(r[1]),...t.map((e=>Array.from(e[1])))];return n.every((e=>e.length>1))?A.CallBuiltIn("string-append",A.CallBuiltIn("string",A.Call(e,...n.map((e=>C.Character(e[0]))))),A.CallBuiltIn("string-map",e,...n.map((e=>C.String(e.slice(1).join(""),!1))))):n.every((e=>e.length>=1))?A.CallBuiltIn("string",A.Call(e,...n.map((e=>C.Character(e[0]))))):C.String("",!1)}),!0),Me=X("vector-map",[{name:"proc"},{name:"vector1"},{name:"vectors",type:"variadic"}],(({proc:e,vector1:r,vectors:t})=>{z.Procedure(e),z.Vector(r),z.Vectors(t);const n=[r,...t];return n.every((e=>e[1].length>1))?A.CallBuiltIn("vector-append",A.CallBuiltIn("vector",A.Call(e,C.MultiValue(n.map((e=>e[1][0]))))),A.CallBuiltIn("vector-map",e,...n.map((e=>C.Vector(e[1].slice(1),!1))))):n.every((e=>e[1].length>=1))?A.CallBuiltIn("vector",A.Call(e,C.MultiValue(n.map((e=>e[1][0]))))):C.Vector([],!1)}),!0),qe=X("for-each",[{name:"proc"},{name:"list1"},{name:"lists",type:"variadic"}],(({proc:e,list1:r,lists:t})=>{z.Procedure(e),z.List(r),z.Lists(t);const n=[r,...t];return n.every((e=>$.Pair(e)))?A.Begin(A.Call(e,C.MultiValue(n.map((e=>e[1])))),A.CallBuiltIn("for-each",C.MultiValue([e,...n.map((e=>e[2]))]))):["<undefined>"]}),!0),Te=X("string-for-each",[{name:"proc"},{name:"str1"},{name:"strs",type:"variadic"}],(({proc:e,str1:r,strs:t})=>{z.Procedure(e),z.String(r),z.Strings(t);const n=[Array.from(r[1]),...t.map((e=>Array.from(e[1])))];return n.every((e=>e.length>1))?A.Begin(A.Call(e,...n.map((e=>C.Character(e[0])))),A.CallBuiltIn("string-for-each",e,...n.map((e=>C.String(e.slice(1).join(""),!1))))):n.every((e=>e.length>=1))?A.Call(e,...n.map((e=>C.Character(e[0])))):["<undefined>"]}),!0),De=X("vector-for-each",[{name:"proc"},{name:"vector1"},{name:"vectors",type:"variadic"}],(({proc:e,vector1:r,vectors:t})=>{z.Procedure(e),z.Vector(r),z.Vectors(t);const n=[r,...t];return n.every((e=>e[1].length>1))?A.Begin(A.Call(e,C.MultiValue(n.map((e=>e[1][0])))),A.CallBuiltIn("vector-for-each",e,...n.map((e=>C.Vector(e[1].slice(1),!1))))):n.every((e=>e[1].length>=1))?A.Call(e,C.MultiValue(n.map((e=>e[1][0])))):A.Quote(["<null>"])}),!0),Re=X("call-with-current-continuation",[{name:"proc"}],(({proc:e},r,t)=>(z.Procedure(e),V(t),A.Call(e,C.Continuation(j(t))))),!0),Qe=Z("call/cc",Re),Ue=X("values",[{name:"objs",type:"variadic"}],(({objs:e})=>(z.Objects(e),1===e.length?e[0]:C.MultiValue(e)))),Fe=X("call-with-values",[{name:"producer"},{name:"consumer"}],(({producer:e,consumer:r},t,n)=>{z.Procedure(e),z.Procedure(r),V(n);const a=B(n,C.List(r),{want:"args",oper:r});return I(a,C.List(e))})),Je=X("dynamic-wind",[{name:"before"},{name:"thunk"},{name:"after"}],(({before:e,thunk:r,after:t},n,a)=>{z.Procedure(e),z.Procedure(r),z.Procedure(t),V(a);const o=C.Continuation(j(a));return I(a,A.Begin(A.Call(e),A.Call(o,A.Call(r))),{before:e,after:t})})),_e={procedureQ:Le,apply:ke,map:ze,stringMap:Ve,vectorMap:Me,forEach:qe,stringForEach:Te,vectorForEach:De,callWithCurrentContinuation:Re,callCC:Qe,values:Ue,callWithValues:Fe,dynamicWind:Je},Xe=X("eqv?",[{name:"obj1"},{name:"obj2"}],(({obj1:e,obj2:r})=>{z.Object(e),z.Object(r);const t=e=>$.String(e)||$.ByteVector(e)||$.Vector(e)?e.slice(0,e.length-1):$.Pair(e)?e.slice(0,3):$.Symbol(e)?e.slice(0,2):e;return C.Boolean(e===r||K(t(e),t(r)))})),Ze=Z("eq?",Xe),Ke=X("equal?",[{name:"obj1"},{name:"obj2"}],(({obj1:e,obj2:r})=>{z.Object(e),z.Object(r);const t=(e,r)=>e===r||($.Pair(e)&&$.Pair(r)?t(e[1],r[1])&&t(e[2],r[2]):$.Vector(e)&&$.Vector(r)?e[1]===r[1]||e[1].length===r[1].length&&e[1].every(((e,n)=>t(e,r[1][n]))):$.ByteVector(e)&&$.ByteVector(r)?K(e[1],r[1]):Xe.body({obj1:e,obj2:r})[1]);return C.Boolean(t(e,r))})),We={eqvQ:Xe,eqQ:Ze,equalQ:Ke},Ge=X("with-exception-handler",[{name:"handler"},{name:"thunk"}],(({handler:e,thunk:r},t,n)=>(z.Procedure(e),z.Procedure(r),V(n),B(n,A.Call(r),{handler:C.HandlerStack(e,E(n).handler)})))),He=X("raise",[{name:"obj"}],(({obj:e},r,t)=>{throw z.Object(e),V(t),C.Exception(t,e,!1)})),Ye=X("raise-continuable",[{name:"obj"}],(({obj:e},r,t)=>{throw z.Object(e),V(t),C.Exception(t,e,!0)})),er=X("error",[{name:"message"},{name:"objs",type:"variadic"}],(({message:e,objs:r},t,n)=>{throw z.String(e),z.Objects(r),V(n),C.Exception(n,C.Error("error",e[1],r),!0)})),rr=X("error-object?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.Error(e))))),tr=X("error-object-message",[{name:"err"}],(({err:e})=>{var r;return z.Error(e),C.String(null!=(r=e[2])?r:e[1],!1)})),nr=X("error-object-irritants",[{name:"err"}],(({err:e})=>(z.Error(e),C.List(...e[3])))),ar=X("read-error?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.Error(e)&&"read-error"===e[1])))),or=X("file-error?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.Error(e)&&"file-error"===e[1])))),ir={withExceptionHandler:Ge,raise:He,raiseContinuable:Ye,error:er,errorObjectQ:rr,errorObjectMessage:tr,errorObjectIrritants:nr,readErrorQ:ar,fileErrorQ:or},lr=X("suspend",[{name:"obj",type:"optional"}],(({obj:e},r,t)=>{throw V(t),e&&z.Object(e),C.Suspend(C.Continuation(j(t)),null!=e?e:C.Undefined())})),sr=X("read-file",[{name:"filename"},{name:"cli",type:"optional"}],(({filename:e,cli:r},t)=>{if(V(t),z.String(e),r&&z.Boolean(r),!(null==t?void 0:t.fs))throw C.Error("program-error",'No interpreter object or No Node.js "fs" object set on Interpreter.');let n,a;try{n=t.fs.readFileSync(e[1]).toString()}catch{throw C.Error("read-error",`Can't read file from ${e[1]}.`)}try{a=le(r&&r[1]?"#!fold-case "+n:n,{filename:e[1]})}catch(o){throw o instanceof Error?C.Error("read-error",o.message):C.Error("read-error","Error occured while reading.")}return a}),!1,!0),cr={suspend:lr,readFile:sr},ur=X("features",[],(()=>C.List(C.Symbol("r7rs"),C.Symbol(u),C.Symbol(u+"-0.6.0")))),mr={features:ur},dr=X("quote",[{name:"value",evaluate:!1}],(({value:e})=>(z.Object(e),e))),pr=X("lambda",[{name:"formals",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({formals:e,body:r},t,n)=>{z.Object(e),z.Objects(r),V(n);const[a,o]=W(e);return C.Procedure("lambda",o?[...a,o]:a,A.BeginIfMultiple(...r),!1,E(n).env)})),fr=X("if",[{name:"test"},{name:"consequent",evaluate:!1},{name:"alternate",type:"optional",evaluate:!1}],(({test:e,consequent:r,alternate:t})=>(z.Object(e),z.Object(r),$.False(e)?t?(z.Object(t),t):["<undefined>"]:r)),!0),br=X("set!",[{name:"variable",evaluate:!1},{name:"expr"}],(({variable:e,expr:r},t,n)=>{if(V(t),V(n),z.Symbol(e),z.Object(r),$.Undefined(r))throw C.Error("undefined-variable",`Attempt to set undefined value to a variable "${e[1]}"`);if(!t.setStatic(E(n).env.static,e,r))throw C.Error("unbound-variable",`Attempt to set value to an unbound variable "${e[1]}"`);return["<undefined>"]})),yr=X("include",[{name:"str1"},{name:"strs",type:"variadic"}],(({str1:e,strs:r},t,n)=>{V(t),V(n),z.String(e),z.Strings(r);const a=[e,...r].map((e=>sr.body({filename:e},t)));return 1===a.length?a[0]:A.Begin(...a)}),!0),hr=X("include-cli",[{name:"str1"},{name:"strs",type:"variadic"}],(({str1:e,strs:r},t,n)=>{V(t),V(n),z.String(e),z.Strings(r);const a=[e,...r].map((e=>sr.body({filename:e,cli:C.Boolean(!0)},t)));return 1===a.length?a[0]:A.Begin(...a)}),!0),gr=X("cond",[{name:"clause",evaluate:!1},{name:"clauses",type:"variadic",evaluate:!1}],(({clause:e,clauses:r})=>{z.Pair(e),z.Pairs(r);const t=0===r.length?["<undefined>"]:A.Cond(r[0],...r.splice(1)),[n,a,...o]=U(e);if($.Symbol(n)&&"else"===n[1])return A.BeginIfMultiple(a,...o);if(a){if($.Symbol(a)&&"=>"===a[1]){if(1!==o.length)throw C.Error("syntax-error","Illegal cond syntax (test => expression).");const e=C.Symbol(_());return A.Let([[e,n]],A.If(e,A.Call(o[0],e),t))}return A.If(n,A.BeginIfMultiple(a,...o),t)}return A.Or(n,t)}),!0),vr=X("case",[{name:"key"},{name:"clauses",type:"variadic",evaluate:!1}],(({key:e,clauses:r})=>{z.Object(e),z.Pairs(r);const t=r.find(((t,n)=>{if($.Symbol(t[1])&&"else"===t[1][1]){if(n!==r.length-1)throw C.Error("syntax-error","Illegal case syntax (else placement).");return!0}return z.Pair(t[1]),U(t[1]).some((r=>Xe.body({obj1:r,obj2:e})[1]))}));if(t){const[,r,...n]=U(t);if(r){if($.Symbol(r)&&"=>"===r[1]){if(1!==n.length)throw C.Error("syntax-error","Illegal cond syntax (test => expression).");return A.Call(n[0],C.MultiValue([e]))}return A.BeginIfMultiple(r,...n)}throw C.Error("syntax-error","Illegal cond syntax (short clause).")}return["<undefined>"]}),!0),Sr=X("and",[{name:"first",type:"optional"},{name:"rest",type:"variadic",evaluate:!1}],(({first:e,rest:r})=>e?(z.Object(e),z.Objects(r),0===r.length||$.False(e)?A.Quote(e):A.And(...r)):C.Boolean(!0)),!0),wr=X("or",[{name:"first",type:"optional"},{name:"rest",type:"variadic",evaluate:!1}],(({first:e,rest:r})=>e?(z.Object(e),z.Objects(r),0!==r.length&&$.False(e)?A.Or(...r):A.Quote(e)):C.Boolean(!1)),!0),xr=X("when",[{name:"test"},{name:"expr",evaluate:!1},{name:"exprs",type:"variadic",evaluate:!1}],(({test:e,expr:r,exprs:t})=>(z.Object(e),z.Object(r),z.Objects(t),$.False(e)?["<undefined>"]:A.BeginIfMultiple(r,...t))),!0),jr=X("unless",[{name:"test"},{name:"expr",evaluate:!1},{name:"exprs",type:"variadic",evaluate:!1}],(({test:e,expr:r,exprs:t})=>(z.Object(e),z.Object(r),z.Objects(t),$.False(e)?A.BeginIfMultiple(r,...t):["<undefined>"])),!0),Pr=X("cond-expand",[{name:"clause1",evaluate:!1},{name:"clauses",type:"variadic",evaluate:!1}],(({clause1:e,clauses:r},t,n)=>{z.Pair(e),z.Pairs(r),V(t),V(n);const a=[e,...r],o=U(ur.body()),i=e=>{if($.Symbol(e))return o.some((r=>$.Symbol(r)&&r[1]===e[1]));if($.Pair(e)){const[,r,a]=e;if($.Symbol(r)&&$.List(a)){if("and"===r[1])return U(a).every((e=>i(e)));if("or"===r[1])return U(a).some((e=>i(e)));if("not"===r[1]){if($.Pair(a))return!i(a[1])}else if("library"===r[1]&&$.Pair(a)){const e=h(a[1]);if(t.getBuiltInLibrary(e))return!0;{const r=t.getStatic(E(n).env.static,C.Symbol(e));return $.Library(r)}}}}return!1},l=a.find((e=>i(e[1])));return l?C.Pair(C.Procedure("built-in","begin"),l[2]):C.Undefined()}),!0),Er=X("let",[{name:"args",type:"variadic",evaluate:!1}],(({args:e},r,t)=>{z.Objects(e);const[n,a,...o]=$.Symbol(e[0])?e:[null,...e];z.List(a),z.Objects(o),V(t);const i=U(a).map((e=>{z.Pair(e),z.Symbol(e[1]),z.Pair(e[2]);const[,r,[,t]]=e;return[r,t]})),l=i.map((([e])=>e)),s=i.map((([,e])=>e)),c=A.Lambda(l,null,...o);return n?(z.Symbol(n),A.CallThunk(A.Define(n,c),A.Call(n,...s))):A.Call(c,...s)}),!0),Nr=X("let*",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{if(z.List(e),z.Objects(r),V(n),$.Pair(e)){z.Pair(e[1]),z.Pair(e[1][2]);const[,[,t,[,n]],a]=e;return z.Symbol(t),A.Call(A.Lambda([t],null,A.CallBuiltIn("let*",a,...r)),n)}return A.BeginIfMultiple(...r)}),!0),Ir=X("letrec",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{z.List(e),z.Objects(r),V(t),V(n);const a=U(e).map((e=>{z.Pair(e),z.Symbol(e[1]),z.Pair(e[2]);const[,r,[,t]]=e;return[r,t]})),{static:o,dynamic:i}=E(n).env,l=O(o);return a.forEach((([e])=>t.defineStatic(l,e,["<undefined>"]))),A.Call(C.Procedure("lambda",[],A.Begin(A.DefineValues(a.map((([e])=>e)),A.Values(...a.map((([,e])=>e)))),...r),!1,{static:l,dynamic:i}))}),!0),Br=X("letrec*",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{z.List(e),z.Objects(r),V(t),V(n);const a=U(e).map((e=>{z.Pair(e),z.Symbol(e[1]),z.Pair(e[2]);const[,r,[,t]]=e;return[r,t]})),{static:o,dynamic:i}=E(n).env,l=O(o);return a.forEach((([e])=>t.defineStatic(l,e,["<undefined>"]))),A.Call(C.Procedure("lambda",[],A.Begin(...a.map((([e,r])=>A.Set(e,r))),...r),!1,{static:l,dynamic:i}))}),!0),Or=X("let-values",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>(z.List(e),z.Objects(r),V(n),A.CallThunk(...U(e).map((e=>{z.Pair(e),z.Pair(e[2]);const[,r,[,t]]=e,a=C.Procedure("lambda",[],t,!1,E(n).env);return A.CallBuiltIn("define-values",r,A.Call(a))})),...r))),!0),Cr=X("let*-values",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{if(z.List(e),z.Objects(r),V(n),$.Pair(e)){z.Pair(e[1]),z.Pair(e[1][2]);const[,[,t,[,n]],a]=e;return A.CallThunk(A.CallBuiltIn("define-values",t,n),A.CallBuiltIn("let*-values",a,...r))}return A.BeginIfMultiple(...r)}),!0),Ar=X("begin",[{name:"exprs",type:"variadic",evaluate:!0},{name:"last",type:"tail",evaluate:!1}],(({exprs:e,last:r},t,n)=>(((e,r)=>{if(!(e instanceof Array))throw C.Error("program-error",null!=r?r:"An array is expected.")})(e),z.Object(r),V(n),0===E(n).depth?I(n,r):r)),!0),$r=X("do",[{name:"specs",evaluate:!1},{name:"clause",evaluate:!1},{name:"commands",type:"variadic",evaluate:!1}],(({specs:e,clause:r,commands:t})=>{z.List(e),z.List(r),z.Objects(t);const n=U(e).map((e=>{z.Pair(e),z.Pair(e[2]),z.Symbol(e[1]);const[,r,[,t,n]]=e;return[r,t,$.Pair(n)?n[1]:null]})),[,a,o]=r;return z.Object(a),z.List(o),A.Let(n.map((([e,r])=>[e,r])),A.If(a,$.Null(o)?C.Undefined():A.Begin(...U(o)),A.Begin(...t,A.CallBuiltIn("do",C.List(...n.map((([e,,r])=>C.List(e,null!=r?r:e,null!=r?r:e)))),r,...t))))}),!0),Lr=X("make-parameter",[{name:"init"},{name:"converter",type:"optional"}],(({init:e,converter:r},t,n)=>{z.Object(e),V(t),V(n);let a=_();for(;a in E(n).env.dynamic[1];)a=_();return r&&z.Procedure(r),t.defineDynamic(E(n).env.dynamic,a,e),C.Parameter(a,null!=r?r:null)})),kr=X("parameterize",[{name:"assocs",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({assocs:e,body:r},t,n)=>{z.Pair(e),z.Pairs(r),V(t),V(n);const{env:a}=E(n),o=U(e).map((e=>{z.Pair(e),z.Pair(e[2]);const[,r,[,t]]=e;return[r,t]})),i={static:a.static,dynamic:C.DynamicNS({},a.dynamic)},l=A.BeginIfMultiple(...o.map((([e,r])=>A.CallBuiltIn("define-parameter",e,r))),...r);return B(n,l,{env:i})})),zr=X("define-parameter",[{name:"param"},{name:"value",evaluate:!1}],(({param:e,value:r},t,n)=>{z.Parameter(e),z.Object(r),V(t),V(n);const[,,a]=e;return A.CallBuiltIn("define-parameter-1",e,a?A.Call(a,r):r)}),!0,!0),Vr=X("define-parameter-1",[{name:"param"},{name:"value"}],(({param:e,value:r},t,n)=>{var a;if(z.Parameter(e),z.Object(r),V(t),V(n),!$.Undefined(null!=(a=x(E(n).env.dynamic)[e[1]])?a:["<undefined>"]))throw C.Error("redefine-variable",null);return t.defineDynamic(E(n).env.dynamic,e[1],r),["<undefined>"]}),!1,!0),Mr=X("guard",[{name:"arg1",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({arg1:e,body:r},t,n)=>{z.Pair(e),z.Objects(r),z.Symbol(e[1]),z.Pair(e[2]),V(n);const[,a,o]=e,i=C.Continuation(j(n)),l=C.Procedure("lambda",[{name:a[1]}],A.Call(i,A.CallBuiltIn("cond",...U(o),C.List(C.Symbol("else"),A.RaiseContinuable(a)))),!1,E(n).env);return A.CallBuiltIn("with-exception-handler",l,A.Lambda([],null,...r))}),!0),qr=X("quasiquote",[{name:"template",evaluate:!1}],(({template:e})=>{z.Object(e);const r=[],t=[],n=(e,a)=>{if($.Pair(e)){const[,o,i]=e;if($.Symbol(o)&&"quasiquote"===o[1])return C.Pair(o,n(i,a+1));if($.Symbol(o)&&"unquote"===o[1]||"unquote-splicing"===o[1]){if(0!==a)return C.Pair(o,n(i,a-1));{const e=C.Symbol("unquote-splicing"===o[1]?"@"+_():_());return z.Pair(i),r.push(e),t.push(i[1]),e}}return C.Pair(n(o,a),n(i,a))}return $.Vector(e)?C.Vector(e[1].map((e=>n(e,a))),!1):e},a=n(e,0);return A.CallBuiltIn("quasiquote-1",a,C.List(...r),...t)}),!0),Tr=X("quasiquote-1",[{name:"template",evaluate:!1},{name:"marks",evaluate:!1},{name:"exprs",type:"variadic"}],(({template:e,marks:r,exprs:t})=>{z.Object(e),z.List(r),z.Objects(t);const n=U(r);z.Symbols(n);const a=new Map;if(n.length!==t.length)throw C.Error("arity-error","quasiquote-1: marks and exprs unmatch.");n.forEach(((e,r)=>a.set(e[1],t[r])));const o=e=>{if($.Pair(e)){const[,r,t]=e;if($.Symbol(r)&&"@"===r[1][0]&&a.has(r[1])){const e=a.get(r[1]);if($.List(e))return $.Null(e)?o(t):J(U(e),o(t));throw C.Error("error","unquote-splicing evaluated as non-list object.")}return C.Pair(o(r),o(t))}return $.Vector(e)?C.Vector(e[1].map((e=>{if($.Symbol(e)&&"@"===e[1][0]&&a.has(e[1])){const r=a.get(e[1]);if($.List(r))return $.Null(r)?[]:U(r);throw C.Error("error","unquote-splicing evaluated as non-list object.")}return[o(e)]})).flat(),!1):$.Symbol(e)&&a.has(e[1])&&"@"!==e[1][0]?a.get(e[1]):e};return o(e)}),!1,!0),Dr=X("let-syntax",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{z.List(e,"aa"),z.Objects(r),V(n);const a=U(e).map((e=>{z.Pair(e),z.Pair(e[2]),z.Symbol(e[1]);const[,r,[,t]]=e;return[r,C.Procedure("lambda",[],t,!1,E(n).env)]}));return A.CallThunk(...a.map((([e,r])=>A.CallBuiltIn("define-syntax",e,A.Call(r)))),...r)}),!0),Rr=X("letrec-syntax",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{z.List(e),z.Objects(r),V(t),V(n);const a=U(e).map((e=>{z.Pair(e),z.Pair(e[2]),z.Symbol(e[1]);const[,r,[,t]]=e;return[r,t]})),{static:o,dynamic:i}=E(n).env,l=O(o);return a.forEach((([e])=>t.defineStatic(l,e,["<undefined>"]))),A.Call(C.Procedure("lambda",[],A.Begin(...a.map((([e,r])=>A.CallBuiltIn("define-syntax",e,r))),...r),!1,{static:l,dynamic:i}))}),!0),Qr=(e,r,t=!0)=>{var n;const[a,o]=F(e),i=a.findIndex((e=>$.Symbol(e)&&e[1]===r)),l=t?i<0?a.slice(1):a.slice(1,i-1):i<0?a:a.slice(0,i-1),s=i<0?[]:a.slice(i+1),c=i<0?null:null!=(n=a[i-1])?n:null;return["<syntax-rule-pattern>",l.map((e=>$.Pair(e)?Qr(e,r,!1):e)),c?$.Pair(c)?Qr(c,r,!1):c:null,s.map((e=>$.Pair(e)?Qr(e,r,!1):e)),$.Null(o)?null:o]},Ur=X("syntax-rules",[{name:"arg1",evaluate:!1},{name:"arg2",evaluate:!1},{name:"args",type:"variadic",evaluate:!1}],(({arg1:e,arg2:r,args:t},n,a)=>{z.Object(e),z.Object(r),z.Objects(t),V(n),V(a);const[o,i,l]=$.Symbol(e)?[e[1],r,t]:["...",e,[r,...t]];z.List(i);const s=U(i).map((e=>(z.Symbol(e),e[1]))),c=(e,r=new Map)=>{var t;if($.Pair(e))return C.Pair(c(e[1],r),c(e[2],r));if($.Symbol(e)){if(n.getStatic(E(a).env.static,e))return C.Symbol(e[1],E(a).env.static,null!=(t=e[3])?t:null);if(s.includes(e[1])||o===e[1]||"_"===e[1])return e;if(r.has(e[1]))return r.get(e[1]);{const t=C.Symbol(e[1],null,_());return r.set(e[1],t),t}}return e};z.Pairs(l);const u=[];for(const m of l){const e=c(m);z.Pair(e),z.Pair(e[2]);const[,r,[,t]]=e;z.Pair(r);const[n,a]=F(r);if(!$.Null(a)&&n.some((e=>$.Symbol(e)&&e[1]===o)))throw C.Error("syntax-error","The root of a syntax-rules pattern with ellipsis must be a proper list.");u.push([Qr(r,o),t])}return C.SyntaxRules(o,s,u)})),Fr=(e,r)=>{if($.SyntaxRulePattern(e)){const[,t,n,a,o]=e;return[...t,...n?[n]:[],...a,...o?[o]:[]].map((e=>Fr(e,r))).flat()}return $.Symbol(e)&&!r.includes(e[1])?"_"===e[1]?[]:[e[1]]:[]},Jr=(e,r,t,n,a,o)=>{if($.SyntaxRulePattern(e)){if(!$.List(r))return null;const[,i,l,s,c]=e;if($.Null(r))return 0!==i.length||l||0!==s.length||c?null:new Map;const[u,m]=F(r);if(l||c){if(u.length<i.length+s.length)return null}else if(u.length!==i.length+s.length)return null;let d;if(l){const e=u.length-i.length-s.length;d=[...i,...Array(e).fill(l),...s],c&&(d.push(c),u.push(m))}else d=[...i],c&&(d.push(c),u.push(J(u.slice(i.length),m)));const p=new Map;l&&Fr(l,o).forEach((e=>p.set(e,[])));for(let e=0;e<d.length;e++){const[r,i]=[d[e],u[e]],s=Jr(r,i,t,n,a,o);if(!s)return null;if(r===l)for(const[e,t]of s.entries()){const r=p.get(e);if(!r||$.Object(r))throw C.Error("syntax-error",`Internal error: illegal behavior of syntax-rules. No array prepared for variadic variable "${e}".`);$.Object(t)?p.set(e,[...r,t]):p.set(e,[...r,...t])}else for(const[e,t]of s.entries()){if(p.has(e))throw C.Error("syntax-error","The same pattern variable appeared more than once in a pattern.");p.set(e,t)}}return p}if($.Symbol(e)&&o.includes(e[1])){if(!$.Symbol(r))return null;const o=t.getStatic(a,e),i=t.getStatic(n,e);return e[1]===r[1]&&o===i?new Map:null}return $.Symbol(e)?"_"===e[1]?new Map:new Map([[e[1],r]]):Ke.body({obj1:e,obj2:r})[1]?new Map:null},_r=X("use-syntax-rules",[{name:"spec"},{name:"args"}],(({spec:e,args:r},t,n)=>{z.SyntaxRules(e),z.List(r),V(t),V(n);const[,a,o,i]=e,l=E(j(n)).env.static,s=E(n).env.static;let c,u;{let e,n;for(const a of i)if(e=Jr(a[0],r,t,l,s,o)){n=a[1];break}if(!e||!n)throw C.Error("syntax-error","No rules match arguments.");[c,u]=[e,n]}const m=e=>{if($.Pair(e)){const[,r,t]=e;if($.Symbol(r)&&c.has(r[1])&&$.Symbol(t[1])&&t[1][1]===a){const e=c.get(r[1]);if(!e||$.Object(e))throw C.Error("syntax-error",`Pattern variable "${r[1]} is not variadic." `);return J(e,m(t[2]))}return $.Pair(r)&&$.Symbol(r[1])&&r[1][1]===a&&$.Pair(r[2])?C.Pair(m(r[2][1]),m(t)):C.Pair(m(r),m(t))}if($.Symbol(e)&&c.has(e[1])){const r=c.get(e[1]);if(!$.Object(r))throw C.Error("syntax-error",`Pattern variable "${e[1]}" must be variadic. (add "${a}" after the symbol)" `);return r}return e};return m(u)}),!1,!0),Xr=X("syntax-error",[{name:"message"},{name:"args",type:"variadic"}],(({message:e,args:r})=>{throw z.String(e),z.Objects(r),C.Error("syntax-error",e[1],r)})),Zr={quote:dr,lambda:pr,If:fr,setD:br,include:yr,includeCli:hr,cond:gr,Case:vr,and:Sr,or:wr,when:xr,unless:jr,condExpand:Pr,Let:Er,LetStar:Nr,letrecStar:Br,letrec:Ir,letValues:Or,letStarValues:Cr,begin:Ar,Do:$r,makeParameter:Lr,parameterize:kr,defineParameter:zr,defineParameter1:Vr,guard:Mr,quasiquote:qr,quasiquote1:Tr,letSyntax:Dr,letrecSyntax:Rr,syntaxRules:Ur,applySyntaxRules:_r,syntaxError:Xr},Kr=X("pair?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.Pair(e))))),Wr=X("cons",[{name:"obj1"},{name:"obj2"}],(({obj1:e,obj2:r})=>(z.Object(e),z.Object(r),C.Pair(e,r)))),Gr=X("car",[{name:"pair"}],(({pair:e})=>(z.Pair(e),e[1]))),Hr=X("cdr",[{name:"pair"}],(({pair:e})=>(z.Pair(e),e[2]))),Yr=X("set-car!",[{name:"pair"},{name:"obj"}],(({pair:e,obj:r})=>{if(z.Pair(e),z.Object(r),e[3])throw C.Error("immutable-object","Specified list is immutable");return e[1]=r,e})),et=X("set-cdr!",[{name:"pair"},{name:"obj"}],(({pair:e,obj:r})=>{if(z.Pair(e),z.Object(r),e[3])throw C.Error("immutable-object","Specified list is immutable");return e[2]=r,e})),rt=X("caar",[{name:"pair"}],(({pair:e})=>(z.Pair(e),z.Pair(e[1]),e[1][1]))),tt=X("cadr",[{name:"pair"}],(({pair:e})=>(z.Pair(e),z.Pair(e[2]),e[2][1]))),nt=X("cdar",[{name:"pair"}],(({pair:e})=>(z.Pair(e),z.Pair(e[1]),e[1][2]))),at=X("cddr",[{name:"pair"}],(({pair:e})=>(z.Pair(e),z.Pair(e[2]),e[2][2]))),ot=X("null?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.Null(e))))),it=X("list?",[{name:"obj"}],(({obj:e})=>{if(z.Object(e),!$.List(e))return C.Boolean(!1);if($.Null(e))return C.Boolean(!0);try{const[,r]=F(e);return C.Boolean($.Null(r))}catch(r){return C.Boolean(!1)}})),lt=X("make-list",[{name:"k"},{name:"fill",type:"optional"}],(({k:e,fill:r})=>(z.IntegerNumber(e),r?(z.Object(r),C.List(...Array.from({length:e[1]},(()=>r)))):C.List(...Array.from({length:e[1]},(()=>["<undefined>"])))))),st=X("list",[{name:"objs",type:"variadic"}],(({objs:e})=>(z.Objects(e),C.List(...e)))),ct=X("length",[{name:"list"}],(({list:e})=>(z.List(e),C.Number(U(e).length)))),ut=X("append",[{name:"args",type:"variadic"}],(({args:e})=>{if(z.Objects(e),0===e.length)return["<null>"];if(1===e.length)return e[0];{const[r,t]=[e.slice(0,e.length-1),e[e.length-1]];return z.Lists(r),J(r.map((e=>U(e))).flat(),t)}})),mt=X("reverse",[{name:"list"}],(({list:e})=>(z.List(e),C.List(...U(e).reverse())))),dt=X("list-tail",[{name:"list"},{name:"k"}],(({list:e,k:r})=>{if(z.Object(e),z.IntegerNumber(r),0===r[1])return e;z.List(e);for(let t=e,n=0;$.Pair(t);t=t[2],n++)if(n===r[1])return t;throw C.Error("out-of-range",`Specified list is shorter than specified number ${r[1]}`)})),pt=X("list-ref",[{name:"list"},{name:"k"}],(({list:e,k:r})=>{z.Pair(e),z.IntegerNumber(r);for(let t=e,n=0;$.Pair(t);t=t[2],n++)if(n===r[1])return t[1];throw C.Error("out-of-range",`Specified list is shorter than specified number ${r[1]}`)})),ft=X("list-set!",[{name:"list"},{name:"k"},{name:"obj"}],(({list:e,k:r,obj:t})=>{z.Pair(e),z.IntegerNumber(r),z.Object(t);for(let n=e,a=0;$.Pair(n);n=n[2],a++)if(a===r[1]){if(n[3])throw C.Error("immutable-object","Specified list is immutable");return n[1]=t,["<undefined>"]}throw C.Error("out-of-range",`Specified list is shorter than specified number ${r[1]}`)})),bt=X("memq",[{name:"obj"},{name:"list"}],(({obj:e,list:r})=>{z.Object(e),z.List(r);const t=U(r).findIndex((r=>Ze.body({obj1:e,obj2:r})[1]));return t<0?C.Boolean(!1):dt.body({list:r,k:C.Number(t)})})),yt=X("memv",[{name:"obj"},{name:"list"}],(({obj:e,list:r})=>{z.Object(e),z.List(r);const t=U(r).findIndex((r=>Xe.body({obj1:e,obj2:r})[1]));return t<0?C.Boolean(!1):dt.body({list:r,k:C.Number(t)})})),ht=X("member",[{name:"obj"},{name:"list"},{name:"compare",type:"optional"}],(({obj:e,list:r,compare:t})=>{if(z.Object(e),z.List(r),$.Null(r))return C.Boolean(!1);if(t){z.Procedure(t);const[,n,a]=r;return A.If(A.Call(t,C.MultiValue([n,e])),A.Quote(r),A.CallBuiltIn("member",C.MultiValue([e,a,t])))}{const t=U(r).findIndex((r=>Ke.body({obj1:e,obj2:r})[1]));return t<0?C.Boolean(!1):A.Quote(dt.body({list:r,k:C.Number(t)}))}}),!0),gt=X("assq",[{name:"obj"},{name:"alist"}],(({obj:e,alist:r})=>{z.Object(e),z.List(r);const t=U(r).find((r=>(z.Pair(r),Ze.body({obj1:e,obj2:r[1]})[1])));return null!=t?t:C.Boolean(!1)})),vt=X("assv",[{name:"obj"},{name:"alist"}],(({obj:e,alist:r})=>{z.Object(e),z.List(r);const t=U(r).find((r=>(z.Pair(r),Xe.body({obj1:e,obj2:r[1]})[1])));return null!=t?t:C.Boolean(!1)})),St=X("assoc",[{name:"obj"},{name:"alist"},{name:"compare",type:"optional"}],(({obj:e,alist:r,compare:t})=>{if(z.Object(e),z.List(r),$.Null(r))return C.Boolean(!1);if(t){z.Procedure(t);const[,n,a]=r;return z.Pair(n),A.If(A.Call(t,C.MultiValue([n[1],e])),A.Quote(n),A.CallBuiltIn("assoc",C.MultiValue([e,a,t])))}{const t=U(r).find((r=>(z.Pair(r),Ke.body({obj1:e,obj2:r[1]})[1])));return t?A.Quote(t):C.Boolean(!1)}}),!0),wt=X("list-copy",[{name:"obj"}],(({obj:e})=>{if(z.Object(e),$.List(e)){if($.Null(e))return["<null>"];{const[r,t]=F(e);return J(r,t)}}return e})),xt={pairQ:Kr,cons:Wr,car:Gr,cdr:Hr,setCarD:Yr,setCdrD:et,caar:rt,cadr:tt,cdar:nt,cddr:at,nullQ:ot,listQ:it,makeList:lt,list:st,length:ct,append:ut,reverse:mt,listTail:dt,listRef:pt,listSetD:ft,memq:bt,memv:yt,member:ht,assq:gt,assv:vt,assoc:St,listCopy:wt},jt=X("number?",[{name:"obj"}],(({obj:e})=>C.Boolean($.Number(e)))),Pt=X("real?",[{name:"obj"}],(({obj:e})=>C.Boolean($.Number(e)))),Et=X("integer?",[{name:"obj"}],(({obj:e})=>C.Boolean($.Number(e)&&Number.isInteger(v(e))))),Nt=X("exact?",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e);return C.Boolean(Number.isSafeInteger(r))})),It=X("inexact?",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e);return C.Boolean(!Number.isSafeInteger(r))})),Bt=Z("exact-integer?",Nt),Ot=X("=",[{name:"z1"},{name:"z2"},{name:"zs",type:"variadic"}],(({z1:e,z2:r,zs:t})=>{z.Number(e),z.Number(r),z.Numbers(t);const n=[e,r,...t].map(v);return C.Boolean(n.slice(1).every((e=>n[0]===e)))})),Ct=X("<",[{name:"z1"},{name:"z2"},{name:"zs",type:"variadic"}],(({z1:e,z2:r,zs:t})=>{z.Number(e),z.Number(r),z.Numbers(t);const n=[e,r,...t].map(v);return C.Boolean(n.every(((e,r)=>0===r||n[r-1]<e)))})),At=X(">",[{name:"z1"},{name:"z2"},{name:"zs",type:"variadic"}],(({z1:e,z2:r,zs:t})=>{z.Number(e),z.Number(r),z.Numbers(t);const n=[e,r,...t].map(v);return C.Boolean(n.every(((e,r)=>0===r||n[r-1]>e)))})),$t=X("<=",[{name:"z1"},{name:"z2"},{name:"zs",type:"variadic"}],(({z1:e,z2:r,zs:t})=>{z.Number(e),z.Number(r),z.Numbers(t);const n=[e,r,...t].map(v);return C.Boolean(n.every(((e,r)=>0===r||n[r-1]<=e)))})),Lt=X(">=",[{name:"z1"},{name:"z2"},{name:"zs",type:"variadic"}],(({z1:e,z2:r,zs:t})=>{z.Number(e),z.Number(r),z.Numbers(t);const n=[e,r,...t].map(v);return C.Boolean(n.every(((e,r)=>0===r||n[r-1]>=e)))})),kt=X("nan?",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e);return C.Boolean(Number.isNaN(r))})),zt=X("zero?",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e);return C.Boolean(0===r)})),Vt=X("positive?",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e);return C.Boolean(r>0)})),Mt=X("negative?",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e);return C.Boolean(r<0)})),qt=X("odd?",[{name:"n"}],(({n:e})=>{z.Number(e);const r=v(e);return C.Boolean(Number.isInteger(r)&&1===Math.abs(r%2))})),Tt=X("even?",[{name:"n"}],(({n:e})=>{z.Number(e);const r=v(e);return C.Boolean(Number.isInteger(r)&&0===Math.abs(r%2))})),Dt=X("max",[{name:"xs",type:"variadic"}],(({xs:e})=>(z.Numbers(e),S(Math.max(...e.map(v)))))),Rt=X("min",[{name:"xs",type:"variadic"}],(({xs:e})=>(z.Numbers(e),S(Math.min(...e.map(v)))))),Qt=X("+",[{name:"zs",type:"variadic"}],(({zs:e})=>(z.Numbers(e),S(e.map(v).reduce(((e,r)=>e+r),0))))),Ut=X("-",[{name:"z1"},{name:"zs",type:"variadic"}],(({z1:e,zs:r})=>{z.Number(e),z.Numbers(r);const t=v(e),n=r.map(v);return S(0===n.length?-t:n.reduce(((e,r)=>e-r),t))})),Ft=X("*",[{name:"zs",type:"variadic"}],(({zs:e})=>(z.Numbers(e),S(e.map(v).reduce(((e,r)=>e*r),1))))),Jt=X("/",[{name:"z1"},{name:"zs",type:"variadic"}],(({z1:e,zs:r})=>{z.Number(e),z.Numbers(r);const t=v(e),n=r.map(v);return n.includes(0)?C.Error("division-by-zero",null):S(0===n.length?1/t:n.reduce(((e,r)=>e/r),t))})),_t=X("abs",[{name:"x"}],(({x:e})=>{z.Number(e);const r=v(e);return S(Math.abs(r))})),Xt=X("floor/",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{z.Number(e),z.Number(r);const t=v(e),n=v(r),a=(t%n+n)%n,o=(t-a)/n;return C.MultiValue([S(o),S(a)])})),Zt=X("floor-quotient",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{z.Number(e),z.Number(r);const t=v(e),n=v(r);return S((t-(t%n+n)%n)/n)})),Kt=X("floor-remainder",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{z.Number(e),z.Number(r);const t=v(e),n=v(r);return S((t%n+n)%n)})),Wt=X("truncate/",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{z.Number(e),z.Number(r);const t=v(e),n=v(r),a=t%n,o=(t-a)/n;return C.MultiValue([S(o),S(a)])})),Gt=X("truncate-quotient",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{z.Number(e),z.Number(r);const t=v(e),n=v(r);return S((t-t%n)/n)})),Ht=X("truncate-remainder",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{z.Number(e),z.Number(r);const t=v(e),n=v(r);return S(t%n)})),Yt=Z("quotient",Gt),en=Z("remainder",Ht),rn=Z("modulo",Kt),tn=X("gcd",[{name:"ns",type:"variadic"}],(({ns:e})=>{if(z.Numbers(e),0===e.length)return S(0);const r=(e,t)=>0!==t?r(t,e%t):e;return S(Math.abs(e.map(v).reduce(r)))})),nn=X("lcm",[{name:"ns",type:"variadic"}],(({ns:e})=>{if(z.Numbers(e),0===e.length)return S(1);const r=(e,t)=>0!==t?r(t,e%t):e;return S(Math.abs(e.map(v).reduce(((e,t)=>e*t/r(e,t)))))})),an=X("floor",[{name:"x"}],(({x:e})=>{z.Number(e);const r=v(e);return S(Math.floor(r))})),on=X("ceiling",[{name:"x"}],(({x:e})=>{z.Number(e);const r=v(e);return S(Math.ceil(r))})),ln=X("truncate",[{name:"x"}],(({x:e})=>{z.Number(e);const r=v(e);return S(Math.trunc(r))})),sn=X("round",[{name:"x"}],(({x:e})=>{z.Number(e);const r=v(e);return S(Math.round(r))})),cn=X("rationalize",[{name:"x"},{name:"y"}],(()=>{throw C.Error("not-supported",'"Fraction numbers are not supported.')})),un=X("square",[{name:"x"}],(({x:e})=>{z.Number(e);const r=v(e);return S(r**2)})),mn=X("exact-integer-sqrt",[{name:"k"}],(({k:e})=>{z.IntegerNumber(e);const r=v(e);if(!Number.isSafeInteger(r)||r<0)throw C.Error("out-of-range","exact-integer-sqrt can calculate exact & non-negative value.");const t=Math.floor(Math.sqrt(r)),n=r-t**2;return C.MultiValue([S(t),S(n)])})),dn=X("expt",[{name:"z1"},{name:"z2"}],(({z1:e,z2:r})=>{z.Number(e),z.Number(r);const t=v(e),n=v(r);return S(t**n)})),pn=X("inexact",[{name:"z"}],(({z:e})=>(z.Number(e),e))),fn=X("exact",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e),t=Number(r.toFixed());if(!Number.isSafeInteger(t))throw C.Error("out-of-range",`"exact" can't calculate exact number for ${e[1]}.`);return e})),bn=X("number->string",[{name:"z"},{name:"radix",type:"optional"}],(({z:e,radix:r})=>{z.Number(e);const t=v(e);if(isNaN(t))return C.String("+nan.0",!1);if(isFinite(t)){r&&z.IntegerNumber(r);const e=r?v(r):10;if(![2,8,10,16].includes(e))throw C.Error("out-of-range","radix must be one of 2, 8, 10, 16.");return C.String(t.toString(e),!1)}return C.String((t>0?"+":"-")+"inf.0",!1)})),yn=X("string->number",[{name:"str"},{name:"radix",type:"optional"}],(({str:e,radix:r})=>{z.String(e);let t,n=e[1];if(r){if(z.IntegerNumber(r),![2,8,10,16].includes(v(r)))throw C.Error("out-of-range","radix must be one of 2, 8, 10, 16.");const e=`#${{2:"b",8:"o",10:"d",16:"x"}[v(r)]}`;n=n.replace(/^(#[dDbBoOxX])?/,e)}try{t=ie(n)}catch(a){return C.Boolean(!1)}return $.Number(t)?t:C.Boolean(!1)})),hn={numberQ:jt,realQ:Pt,integerQ:Et,exactQ:Nt,inexactQ:It,exactIntegerQ:Bt,eq:Ot,lt:Ct,gt:At,le:$t,ge:Lt,nanQ:kt,zeroQ:zt,positiveQ:Vt,negativeQ:Mt,oddQ:qt,evenQ:Tt,max:Dt,min:Rt,add:Qt,sub:Ut,mul:Ft,div:Jt,abs:_t,floorS:Xt,floorQuotient:Zt,floorRemainder:Kt,truncateS:Wt,truncateQuotient:Gt,truncateRemainder:Ht,quotient:Yt,remainder:en,modulo:rn,gcd:tn,lcm:nn,floor:an,ceiling:on,truncate:ln,rationalize:cn,round:sn,square:un,exactIntegerSqrt:mn,expt:dn,inexact:pn,exact:fn,numberToString:bn,stringToNumber:yn},gn='"fs" is not set. To use filesystems, import/require "fs" and set it on Interpreter\'s constructor parameter.',vn=X("call-with-port",[{name:"port"},{name:"proc"}],(({port:e,proc:r})=>(z.Port(e),z.Procedure(r),A.Begin(A.Call(r,e),A.CallBuiltIn("close-port",e))))),Sn=X("input-port?",[{name:"obj"}],(({obj:e})=>{var r;return z.Object(e),C.Boolean(!(!$.Port(e)||!(null==(r=e[3])?void 0:r.includes("r"))))})),wn=X("output-port?",[{name:"obj"}],(({obj:e})=>{var r;return z.Object(e),C.Boolean(!(!$.Port(e)||!(null==(r=e[3])?void 0:r.includes("w"))))})),xn=X("textual-port?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.Port(e)&&"string"==typeof e[5])))),jn=X("binary-port?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.Port(e)&&"string"!=typeof e[5])))),Pn=X("port?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.Port(e))))),En=X("input-port-open?",[{name:"port"}],(({port:e})=>{var r;return z.Port(e),C.Boolean(!!(null==(r=e[3])?void 0:r.includes("r")))})),Nn=X("output-port-open?",[{name:"port"}],(({port:e})=>{var r;return z.Port(e),C.Boolean(!!(null==(r=e[3])?void 0:r.includes("w")))})),In=X("close-port",[{name:"port"}],(({port:e},r)=>{var t;if(z.Port(e),!e[3])return["<undefined>"];if("built-in"===e[1]){if(!r)throw C.Error("program-error","No interpreter object.");const n=r.getBuiltInPort(e[2]);if(!n)throw C.Error("program-error","Illegal built-in file object.");null==(t=n.close)||t.call(n)}else if("string"!==e[1]){if("file"===e[1]){if(!(null==r?void 0:r.fs))throw C.Error("program-error",'No interpreter object or No Node.js "fs" object set on Interpreter.');return r.fs.closeSync(e[2]),C.Boolean(!0)}throw C.Error("program-error",`Unknown port type "${e[1]}"`)}return e[3]=null,["<undefined>"]})),Bn=X("close-input-port",[{name:"port"}],(({port:e})=>{var r;if(z.Port(e),!(null==(r=e[3])?void 0:r.includes("r")))return["<undefined>"];if("built-in"===e[1])throw C.Error("program-error","Can't close only output port for built-in port.");if("string"===e[1]);else if("bytevector"!==e[1])throw"file"===e[1]?C.Error("program-error","Can't close only input port for file port."):C.Error("program-error",`Unknown port type "${e[1]}"`);return e[3]=e[3].replace("r","")||null,["<undefined>"]})),On=X("close-output-port",[{name:"port"}],(({port:e})=>{var r;if(z.Port(e),!(null==(r=e[3])?void 0:r.includes("w")))return["<undefined>"];if("built-in"===e[1])throw C.Error("program-error","Can't close only output port for built-in port.");if("string"===e[1]);else if("bytevector"!==e[1])throw"file"===e[1]?C.Error("program-error","Can't close only output port for file port."):C.Error("program-error",`Unknown port type "${e[1]}"`);return e[3]=e[3].replace("w","")||null,["<undefined>"]})),Cn=X("open-input-string",[{name:"str"}],(({str:e})=>(z.String(e),C.Port("string",e[1],"r",null,"")))),An=X("open-output-string",[],(()=>C.Port("string","","w",null,""))),$n=X("get-output-string",[{name:"port"}],(({port:e})=>{var r;if(z.Port(e),"string"!==e[1]||!(null==(r=e[3])?void 0:r.includes("w")))throw C.Error("read-error","Not a port created by open-output-string.");return C.String(e[2],!1)})),Ln=X("open-input-bytevector",[{name:"bvec"}],(({bvec:e})=>(z.ByteVector(e),C.Port("bytevector",[...e[1]],"r",null,[])))),kn=X("open-output-bytevector",[],(()=>C.Port("bytevector",[],"w",null,[]))),zn=X("get-output-bytevector",[{name:"port"}],(({port:e})=>{var r;if(z.Port(e),"bytevector"!==e[1]||!(null==(r=e[3])?void 0:r.includes("w")))throw C.Error("read-error","Not a port created by open-output-string.");return C.ByteVector([...e[2]],!1)})),Vn=X("read-char",[{name:"port",type:"optional"}],(({port:e},r,t)=>{var n,a;if(V(r),V(t),e||(e=r.getDynamic(E(t).env.dynamic,"current-input-port")),z.Port(e),!(null==(n=e[3])?void 0:n.includes("r")))throw C.Error("read-error","Port is not open.");if("string"!=typeof e[5])throw C.Error("read-error","Not a text port.");let o;if(e[5].length>0)/^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e[5])?(o=e[5].slice(0,2),e[5]=e[5].slice(2)):(o=e[5].slice(0,1),e[5]=e[5].slice(1));else if("built-in"===e[1]){const t=null==r?void 0:r.getBuiltInPort(e[2]);o=null==(a=null==t?void 0:t.read)?void 0:a.call(t,"character",null)}else if("string"===e[1])0===e[2].length?o=null:/^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e[2])?(o=e[2].slice(0,2),e[2]=e[2].slice(2)):(o=e[2].slice(0,1),e[2]=e[2].slice(1));else{if("file"!==e[1])throw C.Error("program-error","Illegal type of port.");{if(!(null==r?void 0:r.fs))throw C.Error("read-error",gn);const t=Buffer.alloc(4);for(let n=0;;n++){if(!r.fs.readSync(e[2],t,{length:1,offset:n})){o=null;break}const a=t.toString("utf8",0,n+1);if(!a.includes("�")){o=a;break}if(n>=4)throw C.Error("read-error","Not a valid text(UTF-8) file.")}}}if(null===o)return C.EndOfFile();if(void 0===o)throw C.Error("read-error",null);if("string"!=typeof o)throw C.Error("read-error","Read-data is not a expected format (number).");return C.Character(o)})),Mn=X("peek-char",[{name:"port",type:"optional"}],(({port:e},r,t)=>{V(r),V(t),e||(e=r.getDynamic(E(t).env.dynamic,"current-input-port")),z.Port(e);const n=Vn.body({port:e},r,t);return $.EndOfFile(n)||(e[5]="string"==typeof e[5]?n[1]+e[5]:n[1]),n})),qn=X("read-line",[{name:"port",type:"optional"}],(({port:e},r,t)=>{V(r),V(t),e||(e=r.getDynamic(E(t).env.dynamic,"current-input-port")),z.Port(e);let n="";for(;;){const a=Vn.body({port:e},r,t);if($.EndOfFile(a))return""===n?a:C.String(n,!1);if("\r"===a[1]){const a=Vn.body({port:e},r,t);return $.EndOfFile(a)||"\n"===a[1]||(e[5]="string"==typeof e[5]?a[1]+e[5]:a[1]),C.String(n,!1)}if("\n"===a[1])return C.String(n,!1);n+=a[1]}})),Tn=X("eof-object?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.EndOfFile(e))))),Dn=X("eof-object",[],(()=>C.EndOfFile())),Rn=X("char-ready?",[{name:"port",type:"optional"}],(({port:e},r,t)=>{var n,a;if(V(r),V(t),e||(e=r.getDynamic(E(t).env.dynamic,"current-input-port")),z.Port(e),!(null==(n=e[3])?void 0:n.includes("r")))return C.Boolean(!1);if("built-in"===e[1]){if(!r)throw C.Error("program-error","No interpreter object.");const t=r.getBuiltInPort(e[2]);if(!t)throw C.Error("program-error","Illegal built-in file object.");return C.Boolean(!!(null==(a=t.ready)?void 0:a.call(t)))}if("string"===e[1])return C.Boolean(!0);if("bytevector"===e[1])return C.Boolean(!1);throw"file"===e[1]?C.Error("program-error",'"Node.js file "ready" method is not implemented."'):C.Error("program-error",`Unknown port type "${e[1]}"`)})),Qn=X("read-string",[{name:"k"},{name:"port",type:"optional"}],(({k:e,port:r},t,n)=>{z.IntegerNumber(e),V(t),V(n),r||(r=t.getDynamic(E(n).env.dynamic,"current-input-port")),z.Port(r);let a="";for(;;){const o=Vn.body({port:r},t,n);if($.EndOfFile(o))return 0===a.length?o:C.String(a,!1);if(a+=o[1],a.length>=e[1])return C.String(a,!1)}})),Un=X("read-u8",[{name:"port",type:"optional"}],(({port:e},r,t)=>{var n,a;if(V(r),V(t),e||(e=r.getDynamic(E(t).env.dynamic,"current-input-port")),z.Port(e),!(null==(n=e[3])?void 0:n.includes("r")))throw C.Error("read-error","Port is not open.");if("string"==typeof e[5])throw C.Error("read-error","Not a binary port.");let o;if(e[5].length>0)o=e[5][0],e[5]=e[5].slice(1);else if("built-in"===e[1]){const t=null==r?void 0:r.getBuiltInPort(e[2]);o=null==(a=null==t?void 0:t.read)?void 0:a.call(t,"byte",null)}else if("bytevector"===e[1])e[2].length>0?(o=e[2][0],e[2]=e[2].slice(1)):o=null;else{if("file"!==e[1])throw C.Error("program-error","Illegal type of port.");{if(!(null==r?void 0:r.fs))throw C.Error("read-error",gn);const t=Buffer.alloc(1);o=r.fs.readSync(e[2],t)?t[0]:null}}if(null===o)return C.EndOfFile();if(void 0===o)throw C.Error("read-error",null);if("number"!=typeof o)throw C.Error("read-error","Read-data is not a expected format (string).");return C.Number(o)})),Fn=X("peek-u8",[{name:"port",type:"optional"}],(({port:e},r,t)=>{V(r),V(t),e||(e=r.getDynamic(E(t).env.dynamic,"current-input-port")),z.Port(e);const n=Un.body({port:e},r,t);return $.EndOfFile(n)||(e[5]="string"!=typeof e[5]?[n[1],...e[5]]:[n[1]]),n})),Jn=X("u8-ready?",[{name:"port",type:"optional"}],(({port:e},r,t)=>{var n,a;if(V(r),V(t),e||(e=r.getDynamic(E(t).env.dynamic,"current-input-port")),z.Port(e),!(null==(n=e[3])?void 0:n.includes("r")))return C.Boolean(!1);if("built-in"===e[1]){if(!r)throw C.Error("program-error","No interpreter object.");const t=r.getBuiltInPort(e[2]);if(!t)throw C.Error("program-error","Illegal built-in file object.");return C.Boolean(!!(null==(a=t.ready)?void 0:a.call(t)))}if("string"===e[1])return C.Boolean(!1);if("bytevector"===e[1])return C.Boolean(!0);if("file"===e[1]){if(!(null==r?void 0:r.fs))throw C.Error("read-error",gn);throw C.Error("program-error",'"Node.js file "ready" method is not implemented."')}throw C.Error("program-error",`Unknown port type "${e[1]}"`)})),_n=X("read-bytevector",[{name:"k"},{name:"port",type:"optional"}],(({k:e,port:r},t,n)=>{z.IntegerNumber(e),V(t),V(n),r||(r=t.getDynamic(E(n).env.dynamic,"current-input-port")),z.Port(r);const a=[];for(;;){const o=Un.body({port:r},t,n);if($.EndOfFile(o))return 0===a.length?o:C.ByteVector(a,!1);if(a.push(o[1]),a.length>=e[1])return C.ByteVector(a,!1)}})),Xn=X("read-bytevector!",[{name:"bvec"},{name:"port",type:"optional"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({bvec:e,port:r,start:t,end:n},a,o)=>{z.ByteVector(e),V(a),V(o);const i=$.Number(t)?t[1]:0,l=$.Number(n)?n[1]:e[1].length;if("number"!=typeof i||!Number.isInteger(i)||"number"!=typeof l||!Number.isInteger(l))throw C.Error("domain-error","Index must be integer.");const s=l-i,c=_n.body({k:C.Number(s),port:r},a,o);if($.EndOfFile(c))return c;for(let u=0;u<c[1].length;u++)e[1][i+u]=c[1][u];return C.Number(c[1].length)})),Zn=X("newline",[{name:"port",type:"optional"}],(({port:e},r,t)=>Wn.body({str:C.String("\n",!1),port:e,start:null,end:null},r,t))),Kn=X("write-char",[{name:"char"},{name:"port",type:"optional"}],(({char:e,port:r},t,n)=>(z.Character(e),Wn.body({str:C.String(e[1],!1),port:r,start:null,end:null},t,n)))),Wn=X("write-string",[{name:"str"},{name:"port",type:"optional"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,port:r,start:t,end:n},a,o)=>{var i;z.String(e),V(a),V(o);const l=$.Number(t)?t[1]:0,s=$.Number(n)?n[1]:e[1].length;if("number"!=typeof l||!Number.isInteger(l)||"number"!=typeof s||!Number.isInteger(s))throw C.Error("domain-error","Index must be integer.");const c=Array.from(e[1]).slice(l,s).join("");if(r||(r=a.getDynamic(E(o).env.dynamic,"current-output-port")),z.Port(r),!(null==(i=r[3])?void 0:i.includes("w")))throw C.Error("write-error","Port is not open for writing.");if("string"!=typeof r[5])throw C.Error("write-error","Not a text port.");if("built-in"===r[1]){if(!a)throw C.Error("program-error","No interpreter object.");const e=a.getBuiltInPort(r[2]);if(!e||!e.write)throw C.Error("program-error","No built-in method defined to write.");e.write(c)}else if("string"===r[1])r[2]=r[2]+c;else{if("file"!==r[1])throw C.Error("program-error","Illegal type of port for writing.");if(!(null==a?void 0:a.fs))throw C.Error("write-error",gn);a.fs.writeSync(r[2],c)}return["<undefined>"]})),Gn=X("write-u8",[{name:"byte"},{name:"port",type:"optional"}],(({byte:e,port:r},t,n)=>(z.IntegerNumber(e),Hn.body({bvec:C.ByteVector([e[1]],!1),port:r},t,n)))),Hn=X("write-bytevector",[{name:"bvec"},{name:"port",type:"optional"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({bvec:e,port:r,start:t,end:n},a,o)=>{var i;z.ByteVector(e),V(a),V(o);const l=$.Number(t)?t[1]:0,s=$.Number(n)?n[1]:e[1].length;if("number"!=typeof l||!Number.isInteger(l)||"number"!=typeof s||!Number.isInteger(s))throw C.Error("domain-error","Index must be integer.");const c=e[1].slice(l,s);if(r||(r=a.getDynamic(E(o).env.dynamic,"current-output-port")),z.Port(r),!(null==(i=r[3])?void 0:i.includes("w")))throw C.Error("write-error","Port is not open for writing.");if("string"==typeof r[5])throw C.Error("write-error","Not a binary port.");if("built-in"===r[1]){if(!a)throw C.Error("program-error","No interpreter object.");const e=a.getBuiltInPort(r[2]);if(!e||!e.write)throw C.Error("program-error","No built-in method defined to write.");e.write(new Uint8Array(c))}else if("bytevector"===r[1])r[2].push(...c);else{if("file"!==r[1])throw C.Error("program-error","Illegal type of port for writing.");if(!(null==a?void 0:a.fs))throw C.Error("write-error",gn);a.fs.writeSync(r[2],new Uint8Array(c))}return["<undefined>"]})),Yn=X("flush-output-port",[{name:"port",type:"optional"}],(({port:e},r,t)=>{var n,a;if(V(r),V(t),e||(e=r.getDynamic(E(t).env.dynamic,"current-output-port")),z.Port(e),!(null==(n=e[3])?void 0:n.includes("w")))throw C.Error("write-error","Port is not open for writing.");if("built-in"===e[1]){if(!r)throw C.Error("program-error","No interpreter object.");const t=r.getBuiltInPort(e[2]);if(!t)throw C.Error("program-error","No built-in method defined to write.");null==(a=t.flush)||a.call(t)}else if("file"===e[1]){if(!(null==r?void 0:r.fs))throw C.Error("write-error",gn);r.fs.fsyncSync(e[2])}return["<undefined>"]})),ea={callWithPort:vn,inputPortQ:Sn,outputPortQ:wn,textualPortQ:xn,binaryPortQ:jn,portQ:Pn,inputPortOpenQ:En,outputPortOpenQ:Nn,closePort:In,closeInputPort:Bn,closeOutputPort:On,openInputString:Cn,openOutputString:An,getOutputString:$n,openInputBytevector:Ln,openOutputBytevector:kn,getOutputBytevector:zn,readChar:Vn,peekChar:Mn,readLine:qn,eofObjectQ:Tn,eofObject:Dn,charReadyQ:Rn,readString:Qn,readU8:Un,peekU8:Fn,u8ReadyQ:Jn,readBytevector:_n,readBytevectorD:Xn,newline:Zn,writeChar:Kn,writeString:Wn,writeU8:Gn,writeBytevector:Hn,flushOutputPort:Yn},ra={stringQ:X("string?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.String(e))))),makeString:X("make-string",[{name:"k"},{name:"char",type:"optional"}],(({k:e,char:r})=>(z.IntegerNumber(e),r&&z.Character(r),C.String((r?r[1]:" ").repeat(e[1]),!1)))),string:X("string",[{name:"chars",type:"variadic"}],(({chars:e})=>(z.Characters(e),C.String(e.map((e=>e[1])).join(""),!1)))),stringLength:X("string-length",[{name:"str"}],(({str:e})=>(z.String(e),C.Number(Array.from(e[1]).length)))),stringRef:X("string-ref",[{name:"str"},{name:"k"}],(({str:e,k:r})=>{z.String(e),z.IntegerNumber(r);const t=Array.from(e[1])[r[1]];if(!t)throw C.Error("out-of-range",`The specified string doesn't have character with index ${r[1]}.`);return C.Character(t)})),stringSetD:X("string-set!",[{name:"str"},{name:"k"},{name:"char"}],(({str:e,k:r,char:t})=>{z.String(e),z.IntegerNumber(r),z.Character(t);const n=Array.from(e[1]),a=n.slice(0,r[1]),o=n.slice(r[1]+1);return e[1]=[...a,t[1],...o].join(""),["<undefined>"]})),stringEQ:X("string=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>(z.String(e),z.String(r),z.Strings(t),C.Boolean([r,...t].every((r=>r[1]===e[1])))))),stringLtQ:X("string<?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{z.String(e),z.String(r),z.Strings(t);const n=[e,r,...t].map((e=>e[1]));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]<e)))})),stringGtQ:X("string>?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{z.String(e),z.String(r),z.Strings(t);const n=[e,r,...t].map((e=>e[1]));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]>e)))})),stringLeQ:X("string<=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{z.String(e),z.String(r),z.Strings(t);const n=[e,r,...t].map((e=>e[1]));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]<=e)))})),stringGeQ:X("string>=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{z.String(e),z.String(r),z.Strings(t);const n=[e,r,...t].map((e=>e[1]));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]>=e)))})),substring:X("substring",[{name:"str"},{name:"start"},{name:"end"}],(({str:e,start:r,end:t})=>(z.String(e),z.IntegerNumber(r),z.IntegerNumber(t),C.String(Array.from(e[1]).slice(r[1],t[1]).join(""),!1)))),stringAppend:X("string-append",[{name:"strs",type:"variadic"}],(({strs:e})=>(z.Strings(e),C.String(e.map((e=>e[1])).join(""),!1)))),stringToList:X("string->list",[{name:"str"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,start:r,end:t})=>{z.String(e);const n=Array.from(e[1]),a=$.Number(r)?r[1]:0,o=$.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw C.Error("domain-error","Index must be integer.");return C.List(...n.slice(a,o).map((e=>C.Character(e))))})),listToString:X("list->string",[{name:"list"}],(({list:e})=>{z.List(e);const r=U(e);return z.Characters(r),C.String(r.map((e=>e[1])).join(""),!1)})),stringCopy:X("string-copy",[{name:"str"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,start:r,end:t})=>{z.String(e);const n=Array.from(e[1]),a=$.Number(r)?r[1]:0,o=$.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw C.Error("domain-error","Index must be integer.");return C.String(n.slice(a,o).join(""),!1)})),stringCopyD:X("string-copy!",[{name:"to"},{name:"at"},{name:"from"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({to:e,at:r,from:t,start:n,end:a})=>{z.String(e),z.IntegerNumber(r),z.String(t);const o=Array.from(t[1]),i=Array.from(e[1]),l=$.Number(n)?n[1]:0,s=$.Number(a)?a[1]:o.length;if("number"!=typeof l||!Number.isInteger(l)||"number"!=typeof s||!Number.isInteger(s))throw C.Error("domain-error","Index must be integer.");if(r[1]<0||r[1]>=o.length)throw C.Error("out-of-range","Index is out of range.");if(o.length-r[1]<s-l)throw C.Error("out-of-range","Index is out of range.");const c=o.slice(l,s),u=i.slice(0,r[1]),m=i.slice(r[1]+c.length);return e[1]=[...u,...c,...m].join(""),["<undefined>"]})),stringFillD:X("string-fill!",[{name:"str"},{name:"fill"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,fill:r,start:t,end:n})=>{z.String(e),z.Character(r);const a=Array.from(e[1]),o=$.Number(t)?t[1]:0,i=$.Number(n)?n[1]:a.length;if("number"!=typeof o||!Number.isInteger(o)||"number"!=typeof i||!Number.isInteger(i))throw C.Error("domain-error","Index must be integer.");const l=a.slice(o,i),s=a.slice(0,o),c=a.slice(i);return e[1]=[...s,...r[1].repeat(l.length),...c].join(""),["<undefined>"]}))},ta=X("import",[{name:"sets",type:"variadic",evaluate:!1}],(({sets:e},r,t)=>{var n;z.Objects(e),V(r),V(t);const a=!w(E(t).env.static),o=e=>{if($.Pair(e)&&$.Symbol(e[1])&&(n=e[1][1],["only","except","prefix","rename"].includes(n))){const r=e[1][1],[,t,...n]=U(e);if(!t)throw C.Error("error","Illegal import syntax. No import set after only, except, prefix, or rename.");if("only"===r){z.Symbols(n,"Illegal import syntax (only).");const e={};for(const[r,a]of Object.entries(o(t)))n.some((e=>e[1]===r))&&(e[r]=a);return e}if("except"===r){z.Symbols(n,"Illegal import syntax (except).");const e={};for(const[r,a]of Object.entries(o(t)))n.some((e=>e[1]!==r))&&(e[r]=a);return e}if("prefix"===r){0===n.length&&$.Symbol(n[0])||z.Symbols(n,"Illegal import syntax (prefix).");const e=n[0][1],r={};for(const[n,a]of Object.entries(o(t)))r[e+n]=a;return r}if("rename"===r){const e=o(t);for(const r of n){z.Pair(r,"Illegal import syntax (rename)."),z.Symbol(r[1],"Illegal import syntax (rename)."),z.Pair(r[2],"Illegal import syntax (rename)."),z.Symbol(r[2][1],"Illegal import syntax (rename).");const[,t,[,n]]=r,a=e[t[1]];V(a,`Identifier ${t[1]} is not found in the original set.`),delete e[t[1]],e[n[1]]=a}return e}return{}}{const n=h(e);if("(scheme base)"===n)return{};const a=r.getBuiltInLibrary(n);if(a)return a(r);const o=r.getStatic(E(t).env.static,C.Symbol(n));if($.Library(o)){const e={},[,t,n]=o;for(const[a,o]of Object.entries(t)){const t=r.getStatic(n.static,C.Symbol(a));if(!t)throw C.Error("error",`Invalid library export "${a[1]}" (exported as "${o[1]}")`);e[o]=t}return e}throw C.Error("error",`Library "${n}" not found.`)}var n};for(const i of e){const e=o(i);for(const o of Object.keys(e)){if(!a&&!$.Undefined(null!=(n=x(E(t).env.static)[o])?n:["<undefined>"]))throw C.Error("redefine-variable",null);r.defineStatic(E(t).env.static,C.Symbol(o),e[o])}}return["<undefined>"]})),na=X("define",[{name:"arg1",evaluate:!1},{name:"arg2",type:"variadic",evaluate:!1}],(({arg1:e,arg2:r},t,n)=>{var a,o;z.Object(e),z.Objects(r),V(t),V(n);const i=!w(E(n).env.static);if($.Symbol(e)){const o=e,[l]=r;if(!i&&!$.Undefined(null!=(a=x(E(n).env.static)[o[1]])?a:["<undefined>"]))throw C.Error("redefine-variable",null);return t.defineStatic(E(n).env.static,o,["<undefined>"]),A.Set(o,l)}{z.Pair(e);const[[,a,l],s]=[e,r];if(z.Symbol(a),z.List(l),!i&&!$.Undefined(null!=(o=x(E(n).env.static)[a[1]])?o:["<undefined>"]))throw C.Error("redefine-variable",null);const[c,u]=W(l);return t.defineStatic(E(n).env.static,a,C.Procedure("lambda",u?[...c,u]:c,A.BeginIfMultiple(...s),!1,E(n).env)),["<undefined>"]}}),!0),aa=X("define-values",[{name:"formals",evaluate:!1},{name:"expr"}],(({formals:e,expr:r},t,n)=>{var a;z.Object(e),z.Object(r),V(t),V(n);const o=!w(E(n).env.static),[i,l]=W(e),s=$.MultiValue(r)?r[1]:[r];for(let c=0;c<i.length;c++){if(!s[c])throw C.Error("arity-error",null);if(!o&&!$.Undefined(null!=(a=x(E(n).env.static)[i[c].name])?a:["<undefined>"]))throw C.Error("redefine-variable",null);t.defineStatic(E(n).env.static,C.Symbol(i[c].name),s[c])}return l&&t.defineStatic(E(n).env.static,C.Symbol(l.name),C.List(...s.slice(i.length))),["<undefined>"]})),oa=X("define-syntax",[{name:"keyword",evaluate:!1},{name:"spec",evaluate:!1}],(({keyword:e,spec:r},t,n)=>{var a;z.Symbol(e),z.Object(r),V(t),V(n);if(!!w(E(n).env.static)&&!$.Undefined(null!=(a=x(E(n).env.static)[e[1]])?a:["<undefined>"]))throw C.Error("redefine-variable",null);return t.defineStatic(E(n).env.static,e,C.Undefined()),A.CallBuiltIn("define-syntax-1",e,r)}),!0),ia=X("define-syntax-1",[{name:"keyword",evaluate:!1},{name:"spec"}],(({keyword:e,spec:r},t,n)=>{z.Symbol(e),z.SyntaxRules(r),V(t),V(n);const a=C.Procedure("lambda",[{name:"exprs",type:"variadic",evaluate:!1}],A.CallBuiltIn("use-syntax-rules",r,C.Symbol("exprs")),!0,E(n).env);return t.defineStatic(E(n).env.static,e,a),["<undefined>"]}),!1,!0),la=X("define-record-type",[{name:"name",evaluate:!1},{name:"ctor",evaluate:!1},{name:"pred",evaluate:!1},{name:"fields",evaluate:!1,type:"variadic"}],(({name:e,ctor:r,pred:t,fields:n},a,o)=>{var i,l,s,c;z.Symbol(e),z.Pair(r),z.Symbol(t),z.Pairs(n),V(a),V(o);const u=!w(E(o).env.static);if(!(u||$.Undefined(null!=(i=x(E(o).env.static)[e[1]])?i:["<undefined>"])&&$.Undefined(null!=(l=x(E(o).env.static)[t[1]])?l:["<undefined>"])))throw C.Error("redefine-variable",null);const m=E(o).env,d=C.RecordType(e[1]),[p,...f]=U(r);z.Symbol(p),z.Symbols(f);{const e=C.Symbol("rec");a.defineStatic(E(o).env.static,p,C.Procedure("lambda",f.map((e=>({name:e[1]}))),A.BeginIfMultiple(A.Define(e,A.CallBuiltIn("make-record",d)),...f.map((r=>A.CallBuiltIn("record-set!",e,r,r))),e),!1,m))}{const e=C.Symbol("rec");a.defineStatic(E(o).env.static,t,C.Procedure("lambda",[{name:e[1]}],A.CallBuiltIn("record-type?",e,d),!1,m))}for(const b of n){const[e,r,t]=U(b);if(z.Symbol(e),z.Symbol(r),!f.some((r=>r[1]===e[1])))throw C.Error("domain-error","Unknown field name");{if(!u&&!$.Undefined(null!=(s=x(E(o).env.static)[r[1]])?s:["<undefined>"]))throw C.Error("redefine-variable",null);const t=C.Symbol("rec");a.defineStatic(E(o).env.static,r,C.Procedure("lambda",[{name:t[1]}],A.CallBuiltIn("record-get",t,e),!1,m))}if(t){if(z.Symbol(t),!u&&!$.Undefined(null!=(c=x(E(o).env.static)[t[1]])?c:["<undefined>"]))throw C.Error("redefine-variable",null);const r=C.Symbol("rec"),n=C.Symbol("value");a.defineStatic(E(o).env.static,t,C.Procedure("lambda",[{name:r[1]},{name:n[1]}],A.CallBuiltIn("record-set!",r,e,n),!1,m))}}return["<undefined>"]})),sa=X("make-record",[{name:"type"}],(({type:e})=>(z.RecordType(e),C.Record(e,{}))),!1,!0),ca=X("record-type?",[{name:"rec"},{name:"type"}],(({rec:e,type:r})=>(z.Object(e),z.RecordType(r),$.Record(e)?Xe.body({obj1:e[1],obj2:r}):C.Boolean(!1))),!1,!0),ua=X("record-get",[{name:"rec"},{name:"field",evaluate:!1}],(({rec:e,field:r})=>{var t;z.Record(e),z.Symbol(r);return null!=(t=e[2][r[1]])?t:["<undefined>"]}),!1,!0),ma=X("record-set!",[{name:"rec"},{name:"field",evaluate:!1},{name:"value"}],(({rec:e,field:r,value:t})=>{if(z.Record(e),z.Symbol(r),z.Object(t),$.Undefined(t))throw C.Error("undefined-value","Attempt to set an undefined value.");return e[2][r[1]]=t,["<undefined>"]}),!1,!0),da=X("define-library",[{name:"name",evaluate:!1},{name:"decls",type:"variadic",evaluate:!1}],(({name:e,decls:r},t,n)=>{var a;z.Object(e),z.Pairs(r),V(t),V(n);const o=h(e);if(!!w(E(n).env.static)&&!$.Undefined(null!=(a=x(E(n).env.static)[o])?a:["<undefined>"]))throw C.Error("redefine-variable",null);const i=E(N(C.Undefined())).env,l=C.Library({},i),s=[],c=[],u=e=>{for(const r of e){const[,e,a]=r;if(z.Symbol(e,"Illegal syntax of define-library-syntax"),"export"===e[1]){z.List(a,"Illegal syntax of export.");for(const e of U(a))if($.Symbol(e))t.defineStatic(i.static,e,C.Undefined()),l[1][e[1]]=e[1];else{if(!$.Pair(e))throw C.Error("error","Illegal syntax of export in define-library");if(!($.Symbol(e[1])&&"rename"===e[1][1]&&$.Pair(e[2])&&$.Pair(e[2][2])))throw C.Error("error","Illegal syntax of export in define-library");{const[,r,[,n]]=e[2];z.Symbol(r,"Illegal renaming symbol(from) of export in define-library"),z.Symbol(n,"Illegal renaming symbol(to) of export in define-library"),t.defineStatic(i.static,r,C.Undefined()),l[1][r[1]]=n[1]}}}else if("include-library-declarations"===e[1]){z.List(a,"Illegal syntax of include-library-declarations");const e=U(a);z.Strings(e,"Illegal filename of include-library-declarations");for(const r of e)if(!c.includes(r[1])){const e=sr.body({filename:r},t);z.Pair(e),z.List(e[2]);const n=U(e[2]);z.Pairs(n,`Illegal declarations in file ${r[1]}`),u(n)}}else if("cond-expand"===e[1]){z.List(a,"Illegal syntax of cond-expand in define-library");const[e,...r]=U(a),o=Pr.body({clause1:e,clauses:r},t,n);if(!$.Undefined(o)){const[,...e]=U(o);z.Pairs(e,"Illegal result of cond-expand in define-library"),u(e)}}else{if(!["import","begin","include","include-cli"].includes(e[1]))throw C.Error("error","Illegal declaration in define-library");s.push(r)}}};u(r);const m=B(n,A.Define(C.Symbol(o),l));return I(m,A.Begin(...s,C.MultiValue([])),{env:i})})),pa={Import:ta,define:na,defineValues:aa,defineSyntax:oa,defineSyntax1:ia,defineRecordType:la,makeRecord:sa,recordTypeQ:ca,recordGet:ua,recordSetD:ma,defineLibrary:da},fa={symbolQ:X("symbol?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.Symbol(e))))),symbolEQ:X("symbol=?",[{name:"symbol1"},{name:"symbol2"},{name:"symbols",type:"variadic"}],(({symbol1:e,symbol2:r,symbols:t})=>(z.Symbol(e),z.Symbol(r),z.Symbols(t),C.Boolean([r,...t].every((r=>r[1]===e[1])))))),symbolToString:X("symbol->string",[{name:"obj"}],(({obj:e})=>(z.Symbol(e),C.String(e[1],!0)))),stringToSymbol:X("string->symbol",[{name:"obj"}],(({obj:e})=>(z.String(e),C.Symbol(e[1]))))},ba={vectorQ:X("vector?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.Vector(e))))),makeVector:X("make-vector",[{name:"k"},{name:"fill",type:"optional"}],(({k:e,fill:r})=>(z.IntegerNumber(e),r&&z.Object(r),C.Vector(Array(e[1]).fill(r||["<undefined>"]),!1)))),vector:X("vector",[{name:"objs",type:"variadic"}],(({objs:e})=>(z.Objects(e),C.Vector(e,!1)))),vectorLength:X("vector-length",[{name:"vec"}],(({vec:e})=>(z.Vector(e),C.Number(e[1].length)))),vectorRef:X("vector-ref",[{name:"vec"},{name:"k"}],(({vec:e,k:r})=>{if(z.Vector(e),z.IntegerNumber(r),!(r[1]in e[1]))throw C.Error("out-of-range","Index is out of range.");return e[1][r[1]]})),vectorSetD:X("vector-set!",[{name:"vec"},{name:"k"},{name:"obj"}],(({vec:e,k:r,obj:t})=>{if(z.Vector(e),z.IntegerNumber(r),z.Object(t),!(r[1]in e[1]))throw C.Error("out-of-range","Index is out of range.");if($.Undefined(t))throw C.Error("undefined-value","Attempt to set a undefined value to vector.");return e[1][r[1]]=t,["<undefined>"]})),vector2list:X("vector->list",[{name:"vec"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({vec:e,start:r,end:t})=>{z.Vector(e);const n=e[1],a=$.Number(r)?r[1]:0,o=$.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw C.Error("domain-error","Index must be integer.");return C.List(...n.slice(a,o))})),list2vector:X("list->vector",[{name:"list"}],(({list:e})=>(z.List(e),C.Vector(U(e),!1)))),vector2string:X("vector->string",[{name:"vec"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({vec:e,start:r,end:t})=>{z.Vector(e);const n=e[1],a=$.Number(r)?r[1]:0,o=$.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw C.Error("domain-error","Index must be integer.");return C.String(n.slice(a,o).map((e=>(z.Character(e),e[1]))).join(""),!1)})),string2vector:X("string->vector",[{name:"str"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,start:r,end:t})=>{z.String(e);const n=Array.from(e[1]),a=$.Number(r)?r[1]:0,o=$.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw C.Error("domain-error","Index must be integer.");return C.Vector(n.slice(a,o).map((e=>C.Character(e))),!1)})),vectorCopy:X("vector-copy",[{name:"vec"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({vec:e,start:r,end:t})=>{z.Vector(e);const n=e[1];if(0===n.length)return C.Vector([],!1);const a=$.Number(r)?r[1]:0,o=$.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw C.Error("domain-error","Index must be integer.");return C.Vector(n.slice(a,o),!1)})),vectorCopyD:X("vector-copy!",[{name:"to"},{name:"at"},{name:"from"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({to:e,at:r,from:t,start:n,end:a})=>{z.Vector(e),z.IntegerNumber(r),z.Vector(t);const o=$.Number(n)?n[1]:0,i=$.Number(a)?a[1]:t[1].length;if("number"!=typeof o||!Number.isInteger(o)||"number"!=typeof i||!Number.isInteger(i))throw C.Error("domain-error","Index must be integer.");if(!(r[1]in e[1]))throw C.Error("out-of-range","Index is out of range.");if(e[1].length-r[1]<i-o)throw C.Error("out-of-range","Index is out of range.");const l=t[1].slice(o,i);return e[1].splice(r[1],l.length,...l),["<undefined>"]})),vectorAppend:X("vector-append",[{name:"vecs",type:"variadic"}],(({vecs:e})=>(z.Vectors(e),C.Vector(e.map((e=>e[1])).flat(),!1)))),vectorFillD:X("vector-fill!",[{name:"vec"},{name:"fill"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({vec:e,fill:r,start:t,end:n})=>{if(z.Vector(e),z.Object(r),$.Undefined(r))throw C.Error("undefined-value","Attempt to fill vector with an undefined value.");const a=e[1],o=$.Number(t)?t[1]:0,i=$.Number(n)?n[1]:a.length;if("number"!=typeof o||!Number.isInteger(o)||"number"!=typeof i||!Number.isInteger(i))throw C.Error("domain-error","Index must be integer.");for(let l=o;l<i;l++)l in a&&(a[l]=r);return e}))},ya=[X("write",[{name:"obj"},{name:"port",type:"optional"}],(({obj:e,port:r})=>{let t;z.Object(e),r&&z.Object(r);try{t=f(b([y(e)]))}catch(n){if(n instanceof Error)throw C.Error("write-error",n.message);throw n}return r?A.CallBuiltIn("write-string",C.String(t,!1),r):A.CallBuiltIn("write-string",C.String(t,!1))}),!0,!0),X("write-shared",[{name:"obj"},{name:"port",type:"optional"}],(({obj:e,port:r})=>{let t;z.Object(e),r&&z.Object(r);try{t=f(b([y(e,{labels:"shared"})]))}catch(n){if(n instanceof Error)throw C.Error("write-error",n.message);throw n}return r?A.CallBuiltIn("write-string",C.String(t,!1),r):A.CallBuiltIn("write-string",C.String(t,!1))}),!0,!0),X("write-simple",[{name:"obj"},{name:"port",type:"optional"}],(({obj:e,port:r})=>{let t;z.Object(e),r&&z.Object(r);try{t=f(b([y(e,{labels:"simple"})]))}catch(n){if(n instanceof Error)throw C.Error("write-error",n.message);throw n}return r?A.CallBuiltIn("write-string",C.String(t,!1),r):A.CallBuiltIn("write-string",C.String(t,!1))}),!0,!0),X("display",[{name:"obj"},{name:"port",type:"optional"}],(({obj:e,port:r})=>{let t;z.Object(e),r&&z.Object(r);try{t=f(b([y(e,{style:"display"})]))}catch(n){if(n instanceof Error)throw C.Error("write-error",n.message);throw n}return r?A.CallBuiltIn("write-string",C.String(t,!1),r):A.CallBuiltIn("write-string",C.String(t,!1))}),!0,!0)],ha=[X("read",[{name:"port",type:"optional"}],(({port:e},r,t)=>{if(V(r),V(t),e||(e=r.getDynamic(E(t).env.dynamic,"current-input-port")),z.Port(e),"string"!=typeof e[5])throw C.Error("read-error","Not a text port.");let n,a,o="";for(;;){const n=Vn.body({port:e},r,t);if($.EndOfFile(n))break;o+=n[1]}try{const e=ne(o);[n,a]=ae(e)}catch(m){throw m instanceof Error?C.Error("read-error",m.message):C.Error("read-error","Error occured while reading.")}if(0===n.length){if(a.length>0)throw C.Error("read-error","The external representation is incomplete and therefore not parsable,");return C.EndOfFile()}const[i,...l]=n,s=oe(i,null,{removeLineInfo:!0}),c=b(l),u=f(c);return e[5]=u+e[5],s}),!1,!0)],ga=X("delay",[{name:"expr",evaluate:!1}],(({expr:e},r,t)=>{z.Object(e),V(t);const n=C.Procedure("lambda",[],e,!1,E(t).env);return C.Promise(n,null)}),!1,!0),va=X("delay-force",[{name:"expr",evaluate:!1}],(({expr:e},r,t)=>{z.Object(e),V(t);const n=C.Procedure("lambda",[],e,!1,E(t).env),a=C.Promise(n,null);return A.CallBuiltIn("force",a)}),!0,!0),Sa=X("force",[{name:"promise"}],(({promise:e})=>{if(z.Object(e),$.Promise(e)){if(e[2])return A.Quote(e[2]);{const r=e[1];if(!r)throw C.Error("error","Illegal promise.");return A.CallBuiltIn("force-1",e,A.Call(r))}}return A.Quote(e)}),!0,!0),wa=X("force-1",[{name:"promise"},{name:"obj"}],(({promise:e,obj:r})=>(z.Promise(e),z.Object(r),e[2]=r,r)),!1,!0),xa=[ga,va,Sa,X("promise?",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Boolean($.Promise(e)))),!1,!0),X("make-promise",[{name:"obj"}],(({obj:e})=>(z.Object(e),C.Promise(null,e))),!1,!0)],ja=[wa],Pa=[X("current-second",[],(()=>C.Number(Date.now()/1e3)),!1,!0),X("current-jiffy",[],(()=>{const e=Function("return this")();return C.Number(Math.round(e.performance?performance.now():Date.now()))}),!1,!0),X("jiffies-per-second",[],(()=>C.Number(1e3)),!1,!0)],Ea=[X("finite?",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e);return C.Boolean(Number.isFinite(r))}),!1,!0),X("infinite?",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e);return C.Boolean(!Number.isNaN(r)&&!Number.isFinite(r))}),!1,!0),X("exp",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e);return S(Math.exp(r))}),!1,!0),X("log",[{name:"z1"},{name:"z2",type:"optional"}],(({z1:e,z2:r})=>{z.Number(e);const t=v(e);if(r){z.Number(r);const e=v(r);return S(Math.log(t)/Math.log(e))}return S(Math.log(t))}),!1,!0),X("sin",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e);return S(Math.sin(r))}),!1,!0),X("cos",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e);return S(Math.cos(r))}),!1,!0),X("tan",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e);return S(Math.tan(r))}),!1,!0),X("asin",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e);return S(Math.asin(r))}),!1,!0),X("acos",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e);return S(Math.acos(r))}),!1,!0),X("atan",[{name:"z1"},{name:"z2",type:"optional"}],(({z1:e,z2:r})=>{z.Number(e);const t=v(e);if(r){z.Number(r);const e=v(r);return S(Math.atan2(t,e))}return S(Math.atan(t))}),!1,!0),X("sqrt",[{name:"z"}],(({z:e})=>{z.Number(e);const r=v(e);return S(Math.sqrt(r))}),!1,!0)],Na=[X("case-lambda",[{name:"clauses",type:"variadic",evaluate:!1}],(({clauses:e})=>{z.Pairs(e);const r=_(),t=_(),n=C.Procedure("built-in","lambda"),a=C.Procedure("built-in","cond"),o=C.Procedure("built-in","define"),i=C.Procedure("built-in","apply"),l=C.Procedure("built-in","error");return ie([n,r,[o,t,["length",r]],[a,...e.map((([,e,n])=>{const[a,o]=W(e);return[[o?">=":"=",t,a.length],[i,["lambda",e,...n],r]]})),["else",[l,'"No matching clause for case-lambda"']]]])}),!0,!0)],Ia=[X("char-ci=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{z.Character(e),z.Character(r),z.Characters(t);const n=[e,r,...t].map((e=>Y(e[1])));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]===e)))}),!1,!0),X("char-ci<?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{z.Character(e),z.Character(r),z.Characters(t);const n=[e,r,...t].map((e=>Y(e[1])));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]<e)))}),!1,!0),X("char-ci>?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{z.Character(e),z.Character(r),z.Characters(t);const n=[e,r,...t].map((e=>Y(e[1])));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]>e)))}),!1,!0),X("char-ci<=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{z.Character(e),z.Character(r),z.Characters(t);const n=[e,r,...t].map((e=>Y(e[1])));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]<=e)))}),!1,!0),X("char-ci>=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{z.Character(e),z.Character(r),z.Characters(t);const n=[e,r,...t].map((e=>Y(e[1])));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]>=e)))}),!1,!0),X("char-alphabetic?",[{name:"char"}],(({char:e})=>(z.Character(e),C.Boolean(/\p{Alphabetic}/u.test(e[1])))),!1,!0),X("char-numeric?",[{name:"char"}],(({char:e})=>(z.Character(e),C.Boolean(/\p{Decimal_Number}/u.test(e[1])))),!1,!0),X("char-whitespace?",[{name:"char"}],(({char:e})=>(z.Character(e),C.Boolean(/\p{White_Space}/u.test(e[1])))),!1,!0),X("char-upper-case?",[{name:"char"}],(({char:e})=>(z.Character(e),C.Boolean(/\p{Uppercase}/u.test(e[1])))),!1,!0),X("char-lower-case?",[{name:"char"}],(({char:e})=>(z.Character(e),C.Boolean(/\p{Lowercase}/u.test(e[1])))),!1,!0),X("digit-value",[{name:"char"}],(({char:e})=>{var r;z.Character(e);const t=null!=(r=e[1].codePointAt(0))?r:0,n=[48,1632,1776,1984,2406,2534,2662,2790,2918,3046,3174,3302,3430,3558,3664,3792,3872,4160,4240,6112,6160,6470,6608,6784,6800,6992,7088,7232,7248,42528,43216,43264,43472,43504,43600,44016,65296,66720,69734,69872,69942,70096,70384,70864,71248,71360,71472,71904,92768,93008,120782,120792,120802,120812,120822].find((e=>t>=e&&t<=e+9));return n?C.Number(t-n):C.Boolean(!1)}),!1,!0),X("char-upcase",[{name:"char"}],(({char:e})=>(z.Character(e),C.Character(e[1].toUpperCase()))),!1,!0),X("char-downcase",[{name:"char"}],(({char:e})=>(z.Character(e),C.Character(e[1].toLowerCase()))),!1,!0),X("char-foldcase",[{name:"char"}],(({char:e})=>(z.Character(e),C.Character(Y(e[1])))),!1,!0),X("string-ci=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{z.String(e),z.String(r),z.Strings(t);const n=[e,r,...t].map((e=>Y(e[1])));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]===e)))}),!1,!0),X("string-ci<?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{z.String(e),z.String(r),z.Strings(t);const n=[e,r,...t].map((e=>Y(e[1])));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]<e)))}),!1,!0),X("string-ci>?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{z.String(e),z.String(r),z.Strings(t);const n=[e,r,...t].map((e=>Y(e[1])));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]>e)))}),!1,!0),X("string-ci<=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{z.String(e),z.String(r),z.Strings(t);const n=[e,r,...t].map((e=>Y(e[1])));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]<=e)))}),!1,!0),X("string-ci>=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{z.String(e),z.String(r),z.Strings(t);const n=[e,r,...t].map((e=>Y(e[1])));return C.Boolean(n.every(((e,r)=>0===r||n[r-1]>=e)))}),!1,!0),X("string-upcase",[{name:"str"}],(({str:e})=>(z.String(e),C.String(e[1].toUpperCase(),!1))),!1,!0),X("string-downcase",[{name:"str"}],(({str:e})=>(z.String(e),C.String(e[1].toLowerCase(),!1))),!1,!0),X("string-foldcase",[{name:"str"}],(({str:e})=>(z.String(e),C.String(Y(e[1]),!1))),!1,!0)],Ba=(e,r)=>{const t=(r=r.replace(/^c/,"").replace(/r$/,"")).slice(-1),[,n,a]=e;if("a"===t)return r.length<=1?n:(z.Pair(n),Ba(n,r.slice(0,r.length-1)));if("d"===t)return r.length<=1?a:(z.Pair(a),Ba(a,r.slice(0,r.length-1)));throw C.Error("error",`Illegal cxr parameter ${r}`)},Oa=[X("caaaar",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"caaaar"))),!1,!0),X("caaadr",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"caaadr"))),!1,!0),X("caaar",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"caaar"))),!1,!0),X("caadar",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"caadar"))),!1,!0),X("caaddr",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"caaddr"))),!1,!0),X("caadr",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"caadr"))),!1,!0),X("cadaar",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cadaar"))),!1,!0),X("cadadr",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cadadr"))),!1,!0),X("cadar",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cadar"))),!1,!0),X("caddar",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"caddar"))),!1,!0),X("cadddr",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cadddr"))),!1,!0),X("caddr",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"caddr"))),!1,!0),X("cdaaar",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cdaaar"))),!1,!0),X("cdaadr",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cdaadr"))),!1,!0),X("cdaar",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cdaar"))),!1,!0),X("cdadar",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cdadar"))),!1,!0),X("cdaddr",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cdaddr"))),!1,!0),X("cdadr",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cdadr"))),!1,!0),X("cddaar",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cddaar"))),!1,!0),X("cddadr",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cddadr"))),!1,!0),X("cddar",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cddar"))),!1,!0),X("cdddar",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cdddar"))),!1,!0),X("cddddr",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cddddr"))),!1,!0),X("cdddr",[{name:"pair"}],(({pair:e})=>(z.Pair(e),Ba(e,"cdddr"))),!1,!0)],Ca=[X("command-line",[],(()=>{if(!(null==process?void 0:process.argv))throw C.Error("error","No process.argv (Maybe not running on Node.js)");return C.List(...process.argv.map((e=>C.String(e,!0))))}),!1,!0),X("exit",[{name:"obj",type:"optional"}],(({obj:e},r,t)=>{V(t),e&&z.Object(e);const n=e?A.CallBuiltIn("emergency-exit",C.MultiValue([e])):A.CallBuiltIn("emergency-exit"),a=C.Continuation(N(n));return A.Call(a)}),!0,!0),X("emergency-exit",[{name:"obj",type:"optional"}],(({obj:e})=>{throw e&&z.Object(e),C.Exit(null!=e?e:null)}),!1,!0),X("get-environment-variable",[{name:"name"}],(({name:e})=>{if(z.String(e),!(null==process?void 0:process.env))throw C.Error("error","No process.env (Maybe not running on Node.js)");const r=process.env[e[1]];return r?C.String(r,!0):C.Boolean(!1)}),!1,!0),X("get-environment-variables",[],(()=>{if(!(null==process?void 0:process.env))throw C.Error("error","No process.env (Maybe not running on Node.js)");return C.List(...Object.keys(process.env).map((e=>{var r;return C.Pair(C.String(e,!0),C.String(null!=(r=process.env[e])?r:"",!0))})))}),!1,!0)],Aa='"fs" is not set. To use filesystems, import/require "fs" and set it on Interpreter\'s constructor parameter.',$a=X("eval-close",[{name:"obj"},{name:"port"}],(({obj:e,port:r},t)=>(z.Object(e),z.Port(r),V(t),In.body({port:r},t),e)),!1,!0),La=X("call-with-input-file",[{name:"str"},{name:"proc"}],(({str:e,proc:r},t,n)=>{V(t),V(n);const a=t.getOptions().fs;V(a,Aa),z.String(e),z.Procedure(r);const o=Ma.body({str:e},t);return A.CallBuiltIn("eval-close",A.Call(r,o),o)}),!0,!0),ka=X("call-with-output-file",[{name:"str"},{name:"proc"}],(({str:e,proc:r},t)=>{V(t);const n=t.getOptions().fs;V(n,Aa),z.String(e),z.Procedure(r);const a=Ta.body({str:e},t);return A.CallBuiltIn("eval-close",A.Call(r,a),a)}),!0,!0),za=X("with-input-from-file",[{name:"str"},{name:"thunk"}],(({str:e,thunk:r},t)=>{V(t);const n=t.getOptions().fs;V(n,Aa),z.String(e),z.Procedure(r);const a=Ma.body({str:e},t);return A.CallBuiltIn("parameterize",C.List(C.List(C.Symbol("current-input-port"),a)),A.CallBuiltIn("eval-close",A.Call(r),a))}),!0,!0),Va=X("with-output-to-file",[{name:"str"},{name:"thunk"}],(({str:e,thunk:r},t)=>{V(t);const n=t.getOptions().fs;V(n,Aa),z.String(e),z.Procedure(r);const a=Ta.body({str:e},t);return A.CallBuiltIn("parameterize",C.List(C.List(C.Symbol("current-output-port"),a)),A.CallBuiltIn("eval-close",A.Call(r),a))}),!0,!0),Ma=X("open-input-file",[{name:"str"}],(({str:e},r)=>{var t;V(r);const n=r.getOptions().fs;V(n,Aa),z.String(e);const a=r.getBuiltInPort(e[1]);if(a)try{return null==(t=a.open)||t.call(a,"r",null),C.Port("built-in",e[1],"r",null,"")}catch(o){throw o instanceof Error?C.Error("file-error",o.message):C.Error("file-error",`built-in port "${e[1]} open("r") failed.`)}else try{const r=n.openSync(e[1],"r");return C.Port("file",r,"r",null,"")}catch(o){throw o instanceof Error?C.Error("file-error",o.message):C.Error("file-error",`fs.openSync("${e[1]}", "r") failed.`)}}),!1,!0),qa=X("open-binary-input-file",[{name:"str"}],(({str:e},r)=>{var t;V(r);const n=r.getOptions().fs;V(n,Aa),z.String(e);const a=r.getBuiltInPort(e[1]);if(a)try{return null==(t=a.open)||t.call(a,"r",null),C.Port("built-in",e[1],"r",null,[])}catch(o){throw o instanceof Error?C.Error("file-error",o.message):C.Error("file-error",`built-in port "${e[1]} open("r") failed.`)}else try{const r=n.openSync(e[1],"r");return C.Port("file",r,"r",null,[])}catch(o){throw o instanceof Error?C.Error("file-error",o.message):C.Error("file-error",`fs.openSync("${e[1]}", "r") failed.`)}}),!1,!0),Ta=X("open-output-file",[{name:"str"}],(({str:e},r)=>{var t;V(r);const n=r.getOptions().fs;V(n,Aa),z.String(e);const a=r.getBuiltInPort(e[1]);if(a)try{return null==(t=a.open)||t.call(a,"w",null),C.Port("built-in",e[1],"w",null,"")}catch(o){throw o instanceof Error?C.Error("file-error",o.message):C.Error("file-error",`built-in port "${e[1]} open("w") failed.`)}else try{const r=n.openSync(e[1],"w");return C.Port("file",r,"w",null,"")}catch(o){throw o instanceof Error?C.Error("file-error",o.message):C.Error("file-error",`fs.openSync("${e[1]}", "w") failed.`)}}),!1,!0),Da=X("open-binary-output-file",[{name:"str"}],(({str:e},r)=>{var t;V(r);const n=r.getOptions().fs;V(n,Aa),z.String(e);const a=r.getBuiltInPort(e[1]);if(a)try{return null==(t=a.open)||t.call(a,"w",null),C.Port("built-in",e[1],"w",null,[])}catch(o){throw o instanceof Error?C.Error("file-error",o.message):C.Error("file-error",`built-in port "${e[1]} open("w") failed.`)}else try{const r=n.openSync(e[1],"w");return C.Port("file",r,"w",null,[])}catch(o){throw o instanceof Error?C.Error("file-error",o.message):C.Error("file-error",`fs.openSync("${e[1]}", "w") failed.`)}}),!1,!0),Ra=X("file-exists?",[{name:"filename"}],(({filename:e},r)=>{V(r);const t=r.getOptions().fs;V(t,Aa),z.String(e);try{return C.Boolean(t.existsSync(e[1]))}catch(n){throw n instanceof Error?C.Error("file-error",n.message):C.Error("file-error","fs.existsSync() failed.")}}),!1,!0),Qa=X("delete-file",[{name:"filename"}],(({filename:e},r)=>{V(r);const t=r.getOptions().fs;V(t,Aa),z.String(e);try{t.unlinkSync(e[1])}catch(n){throw n instanceof Error?C.Error("file-error",n.message):C.Error("file-error","fs.unlinkSync() failed.")}return C.Undefined()}),!1,!0),Ua=[La,ka,za,Va,Ma,qa,Ta,Da,Ra,Qa],Fa=[$a],Ja=[X("environment",[{name:"sets",type:"variadic"}],(({sets:e},r,t)=>{z.Objects(e),V(r),V(t);const n=N(C.Undefined());return ta.body({sets:e},r,n),C.EnvironmentSpec(E(n).env)}),!1,!0),X("eval",[{name:"expr"},{name:"spec"}],(({expr:e,spec:r},t,n)=>(z.Object(e),z.EnvironmentSpec(r),V(n),B(n,e,{env:r[1]}))),!1,!0)],_a=X("interaction-environment",[],(()=>{const e=N(C.Undefined());return C.EnvironmentSpec(E(e).env)}),!1,!0),Xa=[_a],Za=[X("load",[{name:"filename"},{name:"spec",type:"optional"}],(({filename:e,spec:r},t,n)=>{V(t),V(n),z.String(e),r?z.EnvironmentSpec(r):r=_a.body();const a=sr.body({filename:e},t);return A.CallBuiltIn("eval",a,r)}),!0,!0)],Ka="\n  * +  - /  < <=  = >  >= abs  acos and  angle append  apply asin  assoc assq  assv atan\n  begin boolean?  caaaar caaadr  caaar caadar  caaddr caadr  caar cadaar  cadadr cadar\n  caddar cadddr  caddr cadr  call-with-current-continuation  call-with-input-file call-with-output-file\n  call-with-values car  case cdaaar  cdaadr cdaar  cdadar cdaddr  cdadr cdar  cddaar cddadr\n  cddar cdddar  cddddr cdddr  cddr cdr  ceiling char->integer  char-alphabetic? char-ci<=?\n  char-ci<? char-ci=?  char-ci>=? char-ci>?  char-downcase char-lower-case?  char-numeric? char-ready?\n  char-upcase char-upper-case?  char-whitespace? char<=?  char<? char=?  char>=? char>?\n  char? close-input-port  close-output-port complex?  cond cons  cos current-input-port\n  current-output-port define  define-syntax delay  denominator display  do dynamic-wind\n  eof-object? eq?  equal? eqv?  eval even?  exact->inexact exact?  exp expt  floor for-each\n  force gcd  if imag-part  inexact->exact inexact?   input-port? integer->char\n  integer? interaction-environment  lambda lcm  length let\n  let* let-syntax  letrec letrec-syntax  list list->string  list->vector list-ref\n  list-tail list?  load log  magnitude make-polar  make-rectangular make-string\n  make-vector map  max member  memq memv  min modulo  negative? newline  not null-environment\n  null? number->string  number? numerator  odd? open-input-file  open-output-file or\n  output-port? pair?  peek-char positive?  procedure? quasiquote  quote quotient  rational? rationalize\n  read read-char  real-part real?  remainder reverse  round  scheme-report-environment\n  set! set-car!  set-cdr! sin  sqrt string  string->list string->number  string->symbol string-append\n  string-ci<=? string-ci<?  string-ci=? string-ci>=?  string-ci>? string-copy  string-fill! string-length\n  string-ref string-set!  string<=? string<?  string=? string>=?  string>? string?  substring symbol->string\n  symbol? tan  truncate values  vector vector->list  vector-fill! vector-length  vector-ref vector-set!\n  vector? with-input-from-file  with-output-to-file write  write-char zero?\n".split(/(\s|\n)+/).filter((e=>!/^\s*$/.test(e))),Wa="\n  and  begin  case  cond  do  if  lambda  let  let*  let-syntax  letrec  letrec-syntax  or  quasiquote  quote  set!\n".split(/(\s|\n)+/).filter((e=>!/^\s*$/.test(e))),Ga=X("scheme-report-environment",[{name:"version"}],(({version:e},r,t)=>{if(V(r),V(t),z.Number(e),5!==e[1])throw C.Error("error","scheme-report-environment only supports version 5.");const n=N(C.Undefined());for(const a of Ka)r.getProcedureContent(C.Procedure("built-in",a))&&r.defineStatic(E(n).env.static,C.Symbol(a),C.Procedure("built-in",a));return C.EnvironmentSpec(E(n).env)}),!1,!0),Ha=X("null-environment",[{name:"version"}],(({version:e},r,t)=>{if(V(r),V(t),z.Number(e),5!==e[1])throw C.Error("error","scheme-report-environment only supports version 5.");const n=N(C.Undefined());for(const a of Wa)r.getProcedureContent(C.Procedure("built-in",a))&&r.defineStatic(E(n).env.static,C.Symbol(a),C.Procedure("built-in",a));return C.EnvironmentSpec(E(n).env)}),!1,!0),Ya=Z("exact->inexact",pn);Ya.hidden=!0;const eo=Z("inexact->exact",fn);eo.hidden=!0;const ro=[Ga,Ha,Ya,eo],to=[...Object.values(me),...Object.values(je),...Object.values($e),...Object.values(_e),...Object.values(We),...Object.values(ir),...Object.values(Zr),...Object.values(xt),...Object.values(hn),...Object.values(ea),...Object.values(ra),...Object.values(pa),...Object.values(fa),...Object.values(ba),...Object.values(mr),...Object.values(cr)],no={"(scheme write)":e=>{ya.forEach((r=>e.setBuiltInProcedure(r)));const r={};return ya.forEach((({name:e})=>r[e]=C.Procedure("built-in",e))),r},"(scheme read)":e=>{ha.forEach((r=>e.setBuiltInProcedure(r)));const r={};return ha.forEach((({name:e})=>r[e]=C.Procedure("built-in",e))),r},"(scheme lazy)":e=>{[...xa,...ja].forEach((r=>e.setBuiltInProcedure(r)));const r={};return xa.forEach((({name:e})=>r[e]=C.Procedure("built-in",e))),r},"(scheme time)":e=>{[...Pa].forEach((r=>e.setBuiltInProcedure(r)));const r={};return Pa.forEach((({name:e})=>r[e]=C.Procedure("built-in",e))),r},"(scheme inexact)":e=>{[...Ea].forEach((r=>e.setBuiltInProcedure(r)));const r={};return Ea.forEach((({name:e})=>r[e]=C.Procedure("built-in",e))),r},"(scheme case-lambda)":e=>{Na.forEach((r=>e.setBuiltInProcedure(r)));const r={};return Na.forEach((({name:e})=>r[e]=C.Procedure("built-in",e))),r},"(scheme char)":e=>{Ia.forEach((r=>e.setBuiltInProcedure(r)));const r={};return Ia.forEach((({name:e})=>r[e]=C.Procedure("built-in",e))),r},"(scheme cxr)":e=>{Oa.forEach((r=>e.setBuiltInProcedure(r)));const r={};return Oa.forEach((({name:e})=>r[e]=C.Procedure("built-in",e))),r},"(scheme process-context)":e=>{Ca.forEach((r=>e.setBuiltInProcedure(r)));const r={};return Ca.forEach((({name:e})=>r[e]=C.Procedure("built-in",e))),r},"(scheme file)":e=>{[...Ua,...Fa].forEach((r=>e.setBuiltInProcedure(r)));const r={};return Ua.forEach((({name:e})=>r[e]=C.Procedure("built-in",e))),r},"(scheme eval)":e=>{Ja.forEach((r=>e.setBuiltInProcedure(r)));const r={};return Ja.forEach((({name:e})=>r[e]=C.Procedure("built-in",e))),r},"(scheme repl)":e=>{Xa.forEach((r=>e.setBuiltInProcedure(r)));const r={};return Xa.forEach((({name:e})=>r[e]=C.Procedure("built-in",e))),r},"(scheme load)":e=>{Za.forEach((r=>e.setBuiltInProcedure(r)));const r={};return Za.forEach((({name:e})=>r[e]=C.Procedure("built-in",e))),r},"(scheme r5rs)":e=>{ro.forEach((r=>e.setBuiltInProcedure(r)));const r={};for(const t of Ka)e.getProcedureContent(C.Procedure("built-in",t))&&(r[t]=C.Procedure("built-in",t));return r}},ao=[],oo=console;exports.Interpreter=class{constructor(e){var r,t;c(this,"options"),c(this,"builtins",{jsObject:{},procedure:{},port:{"//input":{},"//output":{write:e=>{var r;(null==(r=null==process?void 0:process.stdout)?void 0:r.write)?process.stdout.write(e):oo.log(e)}},"//error":{write:e=>{var r;(null==(r=null==process?void 0:process.stderr)?void 0:r.write)?process.stderr.write(e):oo.warn(e)}}},static:{"current-input-port":C.Parameter("current-input-port",null),"current-output-port":C.Parameter("current-output-port",null),"current-error-port":C.Parameter("current-error-port",null)},dynamic:{"current-input-port":C.Port("built-in","//input","r",null,""),"current-output-port":C.Port("built-in","//output","w",null,""),"current-error-port":C.Port("built-in","//error","w",null,"")},library:{}}),c(this,"fs",null),this.options=null!=e?e:{},this.fs=null!=(r=null==e?void 0:e.fs)?r:null,ao.forEach((([e,r])=>this.setBuiltInJSObject(e,r))),to.forEach((e=>this.setBuiltInProcedure(e))),Object.keys(no).forEach((e=>this.setBuiltInLibrary(e,no[e]))),null==(t=null==e?void 0:e.plugins)||t.forEach((e=>e(this)))}getOptions(){return this.options}setBuiltInProcedure(e,r=!1){const t=C.Procedure("built-in",e.name);return!r&&this.getProcedureContent(t)||(this.builtins.procedure[e.name]=e),t}setBuiltInJSObject(e,r,t=!1){const n=C.JS("built-in",e);return!t&&this.getJSObjectContent(n)||(this.builtins.jsObject[e]=r),n}setBuiltInPort(e,r,t=!1){var n;const a=C.Port("built-in",e,null,null,(null==(n=r.binary)?void 0:n.call(r))?[]:"");return!t&&this.getBuiltInPort(e)||(this.builtins.port[e]=r),a}setBuiltInLibrary(e,r,t=!1){return!t&&this.getBuiltInPort(e)||(this.builtins.library[e]=r,r(this)),C.Symbol(e)}getProcedureContent(e){if($.Continuation(e))return{parameters:[{name:"arg",evaluate:!0,type:"variadic"}],body:e,isMacro:!1,env:null};if($.Parameter(e))return{parameters:[],body:e,isMacro:!1,env:null};if("lambda"===e[1]){const[,,r,t,n,a]=e;return{parameters:r,body:t,isMacro:n,env:a}}{const[,,r]=e;if(Q.call(this.builtins.procedure,r)){const{parameters:e,body:t,isMacro:n=!1}=this.builtins.procedure[r];return{parameters:e,body:t,isMacro:n,env:null}}return null}}getJSObjectContent(e){if("inline"===e[1])return e[2];{const r=e[2];return Q.call(this.builtins.jsObject,r)?this.builtins.jsObject[r]:null}}getBuiltInPort(e){return Q.call(this.builtins.port,e)?this.builtins.port[e]:null}getBuiltInLibrary(e){return Q.call(this.builtins.library,e)?this.builtins.library[e]:null}defineStatic(e,r,t){const n=r[3]?r[3]:r[1];return e=r[2]?r[2]:e,x(e)[n]=t,n}defineDynamic(e,r,t){return x(e)[r]=t,r}setStatic(e,r,t){const n=r[3]?r[3]:r[1];for(let a=e=r[2]?r[2]:e;null!==a;a=w(a)){const e=x(a);if(Q.call(e,n))return e[n]=t}return null}setDynamic(e,r,t){for(let n=e;null!==n;n=w(n)){const e=x(n);if(Q.call(e,r))return e[r]=t}return null}getStatic(e,r){const t=r[3]?r[3]:r[1];for(let n=e=r[2]?r[2]:e;null!==n;n=w(n)){const e=x(n);if(Q.call(e,t))return e[t]}return Q.call(this.builtins.static,t)?this.builtins.static[t]:Q.call(this.builtins.procedure,t)&&!this.builtins.procedure[t].hidden?["<procedure>","built-in",t]:null}getDynamic(e,r){for(let t=e;null!==t;t=w(t)){const e=x(t);if(Q.call(e,r))return e[r]}return Q.call(this.builtins.dynamic,r)?this.builtins.dynamic[r]:null}eval(e){return this.evalAST(le(e))}evalJS(e){return this.evalAST(A.Begin(ie(e)))}resume(e,r=C.Undefined()){if(q(e)&&!T(e))throw new Error("The content of envelope is not #SUSPEND# object.");const t=T(e)?e.content[1]:e[1];return this.evalAST(A.Begin(A.Call(t,r)))}evalAST(e){var r,t,n,a;const o=N(e);let i=null;try{for(let e=o;e;){if(E(e).depth>(null!=(r=this.options.stack)?r:16384))throw new Error("Call-stack overflow.");this.options.beforeExecute&&([e,i]=null!=(t=this.options.beforeExecute(e,i))?t:[e,i]),this.options.debug&&oo.log(`Executing(${null!=(n=e[1].want)?n:"initial"}/depth:${e[1].depth}) ${h(e[1].expr)}`);const[o,l]=this.execute(e,i);if(this.options.debug){const r=o?j(o)===e?"wind":j(e)===o?"unwind":j(o)==j(o)?"transfer":"unknown":"finish";oo.log(`Result: ${l?h(l):l} (${r}).`),o&&this.options.verbose&&oo.log(`Next(${null!=(a=o[1].want)?a:"initial"}/depth:${o[1].depth}) ${h(o[1].expr)}`)}this.options.afterExecute&&this.options.afterExecute(o,l,e,i),[e,i]=[o,l]}}catch(l){if($.Exception(l)){const[,e,r]=l,[,t,n]=$.Error(r)?r:[null,"exception",h(r)],a="Exception: "+(null!=n?n:t)+"\n"+P(e).map((([,{depth:e,want:r,expr:t,info:n}])=>`${e}: ${null!=r?r:"initial"}: ${h(t,{maxdepth:20}).slice(0,100)}: ${JSON.stringify(n)}`)).join("\n")+"\n";throw this.options.debug&&oo.log(`UNHANDLED ERROR: ${t}, ${n}\n${a}`),Object.assign(new Error,{name:t,message:null!=n?n:t,stack:a})}if($.Object(l)||$.SpecialObject(l)){throw{language:u,version:"0.6.0",content:l}}throw l}if(!i)throw new Error("AST didn't return value");return i}execute(e,r){var t,n;const a=(e=>{const r=E(e),t=r.args;return["#CALL-STACK#",s(l({},r),{args:t?[...t]:null}),j(e)]})(e),o=E(a),{expr:i}=o;try{if(r){if("return"===o.want)return[j(a),r];if("macro"===o.want)return[B(a,r),null]}if(null===o.want){if(r){if(!$.MultiValue(r)||0!==r[1].length)throw C.Error("internal-error",`Call-frame was given a value without any want. "${o.want}"`);r=null}if($.Symbol(i)){const e=this.getStatic(null!=(t=i[2])?t:E(a).env.static,i);if(e)return[j(a),e];throw C.Error("unbound-variable",`${i[1]} is not defined.`)}if($.Null(i))throw C.Error("program-error","Evaluating an empty list is an error in Scheme.");if(!$.Pair(i))return[j(a),i];o.want="oper"}if(!$.Pair(i))throw C.Error("internal-error","Illegal status of call-frame. frane.want is not null, but expr is not a <pair>.");if("oper"===o.want)if(r){if(!$.Procedure(r))throw C.Error("not-a-procedure","Operator evaluation didn't return a valid procedure");o.oper=r,o.want="args",r=null}else{if(!$.Procedure(i[1])){if($.Symbol(i[1])||$.Pair(i[1]))return[I(a,i[1]),null];throw C.Error("invalid-procedure","Operator is not a valid procedure.")}o.oper=i[1],o.want="args"}if(!o.oper)throw C.Error("internal-error","Illegal status of call-frame. frame.want is not null or oper, but oper is still null.");const l=this.getProcedureContent(o.oper);if(!l)throw C.Error("program-error","Operator is not a valid procedure.");const s=l.parameters.filter((e=>!e.type||"head"===e.type)),c=l.parameters.filter((e=>"optional"===e.type)),[m]=l.parameters.filter((e=>"variadic"===e.type)),d=l.parameters.filter((e=>"tail"===e.type));if("args"===o.want){let e;if(r)e=[r],r=null;else{const[r]=F(i);e=r.slice(1)}if(1===e.length&&$.MultiValue(e[0])){const[[,r]]=e;if(r.length<s.length+d.length||!m&&r.length>s.length+d.length+c.length)throw C.Error("arity-error","Length of items in `multiple-value' object does not match the length of parameters.");o.args=r,o.want="return"}else{if(e.length<s.length+d.length||!m&&e.length>s.length+d.length+c.length)throw C.Error("arity-error","Length of arguments does not match the length of parameters.");const r=Math.max(0,e.length-s.length-d.length),t=Math.max(0,e.length-s.length-c.length-d.length),n=[...s,...c.slice(0,r),...Array.from({length:t},(()=>m)),...d];o.args=e.map(((e,r)=>{var t;return(null==(t=n[r].evaluate)||t)&&$.Evaluatable(e)?null:e})),o.want=-1}}if(!o.args)throw C.Error("internal-error","Invalid status of call-frame. frame.want is not null, oper or args, but frame.args is still null.");if("number"==typeof o.want){r&&(o.args[o.want]=r,r=null);for(let e=0,r=o.args[e];e<o.args.length;r=o.args[++e])if(null===r){const r=U(i).slice(1);return o.want=e,[I(a,r[e]),null]}o.want="return"}if(!$.Objects(o.args))throw C.Error("internal-error","Invalid status of call-frame. frame.args contains non-objects.");const p=o.args,f=Math.max(0,p.length-s.length-d.length),b=Math.max(0,p.length-s.length-c.length-d.length),y=[...s,...c.slice(0,f),...Array.from({length:b},(()=>m)),...d];if("return"===o.want){if("function"==typeof l.body){const e=m?{[m.name]:[]}:{};for(let n=0;n<y.length;n++)"variadic"===y[n].type?e[y[n].name].push(p[n]):e[y[n].name]=p[n];let r;const{acceptableJSValue:t=(()=>!0)}=this.options;try{if(r=l.body(e,this,a),!$.Object(r)&&!$.CallStack(r)){if(!t(r))throw C.Error("not-acceptable-js-value",null);r=C.JS("inline",r)}}catch(u){throw $.Object(u)||$.SpecialObject(u)?$.Exception(u)||$.SpecialObject(u)?u:C.Exception(a,u,!1):u instanceof Error?u:C.Exception(a,C.JS("inline",u),!1)}return $.CallStack(r)?[r,null]:l.isMacro&&$.Evaluatable(r)?[B(a,r),null]:[j(a),r]}if($.Continuation(l.body)){const e=l.body,r=P(a),t=P(e[1]).reverse(),o=new Set(t),i=null!=(n=r.find((e=>o.has(e))))?n:null,s=i?r.slice(0,r.indexOf(i)):r,c=i?t.slice(t.indexOf(i)+1):t,u=1===p.length?p[0]:C.MultiValue(p);for(const n of s){const r=E(n).after;if(r){const t=A.Begin(A.Call(r),A.Call(e,C.MultiValue([u])));return[B(n,t,{before:null,after:null}),null]}}for(const n of c){const r=E(n).before;if(r){const t=A.Begin(A.Call(r),A.Call(e,C.MultiValue([u])));return[I(n,t),null]}}return[e[1],u]}if($.Parameter(l.body)){const e=this.getDynamic(E(a).env.dynamic,l.body[1]);if(!e)throw C.Error("unbound-variable","Parameter is not defined.");return[j(a),e]}{const{dynamic:r}=E(e).env,t=O(l.env.static),n=[];for(let e=0;e<y.length;e++)"variadic"!==y[e].type?this.defineStatic(t,C.Symbol(y[e].name),p[e]):n.push(p[e]);return m&&this.defineStatic(t,C.Symbol(m.name),J(n)),l.isMacro?(E(a).want="macro",[I(a,l.body,{env:{static:t,dynamic:r}}),null]):[B(a,l.body,{env:{static:t,dynamic:r}}),null]}}throw C.Error("internal-error",`Illegal status (want) of call-frame: ${o.want}`)}catch(u){if(u=$.Error(u)?C.Exception(a,u,!1):u,$.Exception(u)){const[,e,r,t]=u;if(o.handler){const n=x(o.handler);if(t){const t=C.Continuation(j(e)),a=A.Call(t,A.Call(n,C.MultiValue([r])));return[B(e,a,{handler:w(o.handler)}),null]}{const t=A.Raise(A.Call(n,C.MultiValue([r])));return[B(e,t,{handler:w(o.handler)}),null]}}throw u}if($.JS(u)&&"built-in"===u[1]&&((c=u[2])&&("object"==typeof c||"function"==typeof c)&&"function"==typeof c.then)){const e=C.JSPromiseContinuation(C.Continuation(a),u[2],"pending");throw u[2].then((()=>e[3]="fulfilled"),(()=>e[3]="rejected")),e}throw u}var c}},exports.arrayToList=J,exports.assert=z,exports.create=C,exports.defineBuiltInProcedure=X,exports.defineBuiltInProcedureAlias=Z,exports.exitValueFromEnvelope=e=>e.content[1],exports.forkCS=I,exports.forms=A,exports.fromJS=ie,exports.fromReferentialJSON=(e,r)=>{const t=JSON.parse(e),n=new Map,a=e=>{e instanceof Array&&e[0]===r&&e.length>=3?(n.set(e[1],e[2]),Object.keys(e[2]).forEach((r=>a(e[2][r])))):"object"==typeof e&&null!==e&&Object.keys(e).forEach((r=>a(e[r])))};a(t);const o=e=>{if(e instanceof Array&&e[0]===r&&n.has(e[1])){if(e.length>=3){const r=e[2];if(r instanceof Array)return r.splice(0,r.length,...r.map((e=>o(e)))),r;{const e=Object.keys(r).reduce(((e,t)=>(e[t]=o(r[t]),e)),{});return Object.assign(r,e)}}return n.get(e[1])}return e instanceof Array?e.map((e=>o(e))):"object"==typeof e&&null!==e?Object.keys(e).reduce(((r,t)=>(r[t]=o(e[t]),r)),{}):e};return o(t)},exports.is=$,exports.isCurrentVersionEnvelope=e=>!!e&&"object"==typeof e&&e.language===u&&"0.6.0"===e.version&&($.Object(e.content)||$.SpecialObject(e.content)),exports.isEnvelope=q,exports.isExitEnvelope=e=>q(e)&&$.Exit(e.content),exports.isJSPromiseContinuationEnvelope=D,exports.isPromiseEnvelope=R,exports.isSuspendEnvelope=T,exports.listToArray=U,exports.pairToArrayWithEnd=F,exports.parser=le,exports.promiseFromEnvelope=e=>e.content[2],exports.promiseStatusFromEnvelope=e=>e.content[3],exports.suspendValueFromEnvelope=e=>e.content[2],exports.toJS=e=>y(e,{extended:!0}),exports.toReferentialJSON=(e,r)=>{const t=new Set,n=new Set,a=e=>{var o,i;if(e instanceof Array&&e[0]===r){const e=new Error(`ReferenceTag "${r}" is already contained in the value.`);throw e.name="reference-tag",e}if("object"!=typeof e||null===e){if("number"!=typeof e||!Number.isNaN(e)&&Number.isFinite(e)){if(null===e||"boolean"==typeof e||"string"==typeof e||"number"==typeof e)return;throw new Error(`Unserializable object: <${typeof e}>`)}throw new Error("JSON can't contain Infinite/-Infinite/NaN")}{const r=null==(o=e.constructor)?void 0:o.name;if("Object"!==r&&"Array"!==r)throw new Error(`Unserializable object: <${typeof e} ${null==(i=e.constructor)?void 0:i.name}>`);t.has(e)?n.has(e)||n.add(e):(t.add(e),Object.keys(e).forEach((r=>a(e[r]))))}};a(e),t.clear();const o=new Map,i=(e,t=!1)=>!t&&o.has(e)?[r,o.get(e)]:!t&&n.has(e)?(o.set(e,o.size+1),[r,o.get(e),i(e,!0)]):e instanceof Array?e.map((e=>i(e))):"object"==typeof e&&null!==e?Object.keys(e).reduce(((r,t)=>(r[t]=i(e[t]),r)),{}):e,l=i(e);return n.clear(),o.clear(),JSON.stringify(l)},exports.transferCS=B,exports.unparser=g,exports.wrapBuiltInProcedure=({name:e,parameters:r,body:t,isMacro:n,hidden:a})=>{const o=console;return{name:e,parameters:r,body:(a,i,l)=>{let s;o.log(`-----[Built-in Procedure Call "${e}"]-----\nIs${n?"":" NOT"} a macro procedure.\n-----[Parameters]-----\n`+r.map(((e,r)=>{const t=a[e.name];return $.Object(t)?`${r}:${e.name}: ${h(t,{maxdepth:20})}\n`:t instanceof Array?`${r}:${e.name}:length ${t.length}}\n`+t.map(((e,r)=>` [${r}]: ${h(e,{maxdepth:20})}\n`)).join(""):`${r}:${e.name}: ${t}\n`})).join("")+" --------------------------------------------\nCalling now...\n");try{s=t(a,i,l)}catch(c){throw o.log(`-----[Exception]-----\nException is${$.Object(c)?"":" NOT"} a LISP Object.\n`+($.Object(c)?h(c,{maxdepth:20}):`${c}`)+"\n-----------------------"),c}return o.log(`-----[Return]-----\nReturn value is ${$.Object(s)?"":"NOT"} a LISP Object.\n`+($.Object(s)?h(s,{maxdepth:20}):`${s}`)+"\n-----------------------"),s},isMacro:n,hidden:a}},exports.writeObject=h;
