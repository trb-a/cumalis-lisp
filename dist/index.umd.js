var __defProp=Object.defineProperty,__defProps=Object.defineProperties,__getOwnPropDescs=Object.getOwnPropertyDescriptors,__getOwnPropSymbols=Object.getOwnPropertySymbols,__hasOwnProp=Object.prototype.hasOwnProperty,__propIsEnum=Object.prototype.propertyIsEnumerable,__defNormalProp=(e,r,t)=>r in e?__defProp(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t,__spreadValues=(e,r)=>{for(var t in r||(r={}))__hasOwnProp.call(r,t)&&__defNormalProp(e,t,r[t]);if(__getOwnPropSymbols)for(var t of __getOwnPropSymbols(r))__propIsEnum.call(r,t)&&__defNormalProp(e,t,r[t]);return e},__spreadProps=(e,r)=>__defProps(e,__getOwnPropDescs(r)),__require="undefined"!=typeof require?require:e=>{throw new Error('Dynamic require of "'+e+'" is not supported')},__publicField=(e,r,t)=>(__defNormalProp(e,"symbol"!=typeof r?r+"":r,t),t);!function(e,r){"object"==typeof exports&&"undefined"!=typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):r((e="undefined"!=typeof globalThis?globalThis:e||self).Scheme={})}(this,(function(e){"use strict";const r="cumalis-lisp",t="0.6.0",n={quote:"'",quasiquote:"`",unquote:",","unquote-splicing":",@"},a=/^(?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+$/,o={"":"\\a","\b":"\\b","\t":"\\t","\n":"\\n","\r":"\\r",'"':'\\"',"\\":"\\\\","|":"\\|"},i=e=>{let r="",t="";for(const a of e){const e=a.length>2&&0===a.indexOf('""')?a.replace(/^""/,"").replace(/""$/,""):a;r=r+(""===r||"("===t.slice(-1)||")"===a||Object.values(n).indexOf(t)>=0||/^#\d+=$/.test(t)&&"("===a?"":" ")+e,t=a}return r},l=e=>{const r=e=>{const t=[];for(const a of e)if("string"==typeof a)t.push(a);else if(a instanceof Array)if("string"==typeof a[0]&&Object.values(n).includes(a[0]))t.push(...r(a));else if("#"===a[0]||"#u8"===a[0]){if(2!==a.length||!(a[1]instanceof Array))throw new Error("Illegal token tree: #/#u8 must have only one token array");t.push(`${a[0]}(`),t.push(...r(a[1])),t.push(")")}else if("string"==typeof a[0]&&/^#\d+=/.exec(a[0])){if(2!==a.length)throw new Error("Illegal token tree: datum label must have the content");t.push(a[0],...r(a.splice(1)))}else t.push("("),t.push(...r(a)),t.push(")");return t};return r(e)},s=(e,r)=>{const{extended:t=!1,style:i="write",labels:l="cyclic",maxdepth:s=1/0}=null!=r?r:{},c=new Set,u=new Set,d=(e,r,n)=>{if(I.Object(e),!t&&r>s)return;if(!t&&("cyclic"===l&&n.has(e)||"shared"===l&&c.has(e)))return void u.add(e);c.add(e);const a=new Set(n);a.add(e),P.Pair(e)?(d(e[1],r+1,a),d(e[2],r+1,a)):P.Vector(e)&&e[1].forEach((e=>d(e,r+1,a)))};d(e,0,new Set);const p=new Map,f=(e,r,l=!1)=>{var c;if(I.Object(e),!t&&r>s)return"...";if(!l&&!t&&u.has(e)){if(p.has(e))return`#${p.get(e)}#`;{const t=p.size+1;p.set(e,t);return[`#${t}=`,f(e,r,!0)]}}switch(e[0]){case"<symbol>":return t||a.test(e[1])?e[1]:"|"+e[1].replace(/[\x00-\x1f\x7f"|\\]/g,(e=>{var r,t;return null!=(t=o[e])?t:`\\x${null==(r=e.codePointAt(0))?void 0:r.toString(16)}`}))+"|";case"<null>":return t?null:[];case"<string>":return t?e[1]:"display"!==i?'"'+e[1].replace(/[\x00-\x1f\x7f]"|\\/g,(e=>{var r,t;return null!=(t=o[e])?t:`\\x${null==(r=e.codePointAt(0))?void 0:r.toString(16)}`}))+'"':'""'+e[1]+'""';case"<number>":return t?m(e):`${e[1]}`;case"<boolean>":return t?e[1]:e[1]?"#t":"#f";case"<character>":if(t)return e[1];if("display"!==i){const[r]=null!=(c=Object.entries(Z).find((([,r])=>r===e[1])))?c:[];return`#\\${null!=r?r:e[1]}`}return'""'+e[1]+'""';case"<vector>":return["#",[...e[1].map((e=>f(e,r+1)))]];case"<bytevector>":return["#u8",[...e[1].map((e=>`${e}`))]];case"<pair>":const[,l,s]=e;if("<null>"===s[0])return[f(l,r+1)];if("<pair>"!==s[0])return[f(l,r+1),".",f(s,r+1)];if("<symbol>"===l[0]&&n[l[1]]){const e=f(s,r+1);return e instanceof Array&&!P.Object(e)?[n[l[1]],...e]:[n[l[1]],e]}{const e=f(l,r+1),t=f(s,r+1);return t instanceof Array&&!P.Object(t)?[e,...t]:[e,".",t]}case"<js>":return t?["&",e[1]]:`#<$js[${null===e[1]?"null":typeof e[1]}]>`;case"<procedure>":return t?e:"built-in"===e[1]?`#<procedure[built-in/${e[2]}]>`:`#<procedure[${e[1]}]>`;default:return t?e:`#${e[0]}`}};return f(e,0)},c=(e,r={})=>{try{const t=s(e,__spreadProps(__spreadValues({maxdepth:8},r),{extended:!1})),n=l([t]);return i(n)}catch(t){return"<!!WRITE-ERROR!!>"}},u=(e,r={})=>{const t=s(e,__spreadProps(__spreadValues({},r),{extended:!1}));if(!(t instanceof Array&&"begin"===t[0]))throw new Error('fromASTToText error: The top of AST is must be a "begin" expression.');const n=l(t.slice(1));return i(n)},m=e=>"number"==typeof e[1]?e[1]:"+inf.0"===e[1]?1/0:"-inf.0"===e[1]?-1/0:NaN,d=e=>j.Number(Number.isFinite(e)?Number.isNaN(e)?"+nan.0":e:e<0?"-inf.0":"+inf.0"),p=e=>e[2],f=e=>e[1],b=e=>e[2],y=e=>{const r=[];for(let t=e;t;t=b(t))r.push(t);return r},h=e=>e[1],g=e=>["#CALL-STACK#",{depth:0,env:{static:j.StaticNS({},null),dynamic:j.DynamicNS({},null)},expr:e,want:null,oper:null,args:null,before:null,after:null,handler:null,info:P.Pair(e)&&e[4]||null},null],v=(e,r,t={})=>{var n,a,o;const{env:i,handler:l,depth:s,info:c}=h(e);return["#CALL-STACK#",{depth:s+1,env:null!=(n=t.env)?n:i,expr:r,want:null,oper:null,args:null,before:null!=(a=t.before)?a:null,after:null!=(o=t.after)?o:null,handler:l,info:P.Pair(r)&&r[4]||c},e]},S=(e,r,t={})=>{var n,a,o;const{env:i,handler:l,depth:s,info:c,before:u,after:m}=h(e);return["#CALL-STACK#",{depth:s,env:null!=(n=t.env)?n:i,expr:r,want:null!=(a=t.want)?a:null,oper:null!=(o=t.oper)?o:null,args:null,before:void 0===t.before?u:t.before,after:void 0===t.after?m:t.after,handler:void 0!==t.handler?t.handler:l,info:P.Pair(r)&&r[4]||c},b(e)]},w=e=>[e[0],{},e],j={Symbol:(...e)=>["<symbol>",...e],String:(...e)=>["<string>",...e],Number:(...e)=>["<number>",...e],Boolean:(...e)=>["<boolean>",...e],Character:(...e)=>["<character>",...e],Pair:(e,r,t=!1,n)=>n?["<pair>",e,r,t,n]:["<pair>",e,r,t],Null:()=>["<null>"],Vector:(...e)=>["<vector>",...e],ByteVector:(...e)=>["<bytevector>",...e],EndOfFile:(...e)=>["<end-of-file>",...e],Procedure:(...e)=>["<procedure>",...e],Port:(...e)=>["<port>",...e],RecordType:(...e)=>["<record-type>",...e],Record:(...e)=>["<record>",...e],SyntaxRules:(...e)=>["<syntax-rules>",...e],Parameter:(...e)=>["<parameter>",...e],MultiValue:(...e)=>["<multi-value>",...e],Exception:(...e)=>["<exception>",...e],Undefined:(...e)=>["<undefined>",...e],Promise:(...e)=>["<promise>",...e],Error:(e,r,t=[])=>["<error>",e,r,t],Continuation:(...e)=>["<continuation>",...e],EnvironmentSpec:(...e)=>["<environment-spec>",...e],Library:(...e)=>["<library>",...e],JS:(...e)=>["<js>",...e],List:(...e)=>e.reverse().reduce(((e,r)=>["<pair>",r,e,!1]),["<null>"]),Suspend:(...e)=>["#SUSPEND#",...e],JSPromiseContinuation:(...e)=>["#JS-PROMISE-CONTINUATION#",...e],Exit:(...e)=>["#EXIT#",...e],StaticNS:(...e)=>["#STATIC-NS-STACK#",...e],DynamicNS:(...e)=>["#DYNAMIC-NS-STACK#",...e],HandlerStack:(...e)=>["#HANDLER-STACK#",...e]},x={Call:(e,...r)=>j.List(e,...r),CallBuiltIn:(e,...r)=>j.List(j.Procedure("built-in",e),...r),Lambda:(...e)=>P.List(e[0])?x.CallBuiltIn("lambda",...e):x.CallBuiltIn("lambda",M(e[0],e[1]),...e.slice(2)),CallThunk:(...e)=>x.Call(x.CallBuiltIn("lambda",["<null>"],...e)),Begin:(...e)=>x.CallBuiltIn("begin",...e),Quote:e=>x.CallBuiltIn("quote",e),Set:(e,r)=>x.CallBuiltIn("set!",e,r),Raise:e=>x.CallBuiltIn("raise",e),RaiseContinuable:e=>x.CallBuiltIn("raise-continuable",e),Let:(e,...r)=>x.CallBuiltIn("let",j.List(...e.map((e=>j.List(...e)))),...r),If:(e,r,t)=>t?x.CallBuiltIn("if",e,r,t):x.CallBuiltIn("if",e,r),And:(...e)=>x.CallBuiltIn("and",...e),Or:(...e)=>x.CallBuiltIn("or",...e),Cond:(e,...r)=>x.CallBuiltIn("cond",e,...r),Case:(e,r)=>x.CallBuiltIn("case",e,j.List(...r.map((e=>j.List(...e))))),Define:(...e)=>x.CallBuiltIn("define",...e),DefineValues:(e,r)=>x.CallBuiltIn("define-values",P.List(e)?e:j.List(...e),r),Append:(...e)=>x.CallBuiltIn("append",...e),Cons:(...e)=>x.CallBuiltIn("cons",...e),Values:(...e)=>x.CallBuiltIn("values",...e),BeginIfMultiple:(...e)=>0===e.length?["<undefined>"]:1===e.length?e[0]:x.Begin(...e)},P={Symbol:e=>e instanceof Array&&"<symbol>"===e[0],String:e=>e instanceof Array&&"<string>"===e[0],Number:e=>e instanceof Array&&"<number>"===e[0],Boolean:e=>e instanceof Array&&"<boolean>"===e[0],Character:e=>e instanceof Array&&"<character>"===e[0],Pair:e=>e instanceof Array&&"<pair>"===e[0],Null:e=>e instanceof Array&&"<null>"===e[0],Vector:e=>e instanceof Array&&"<vector>"===e[0],ByteVector:e=>e instanceof Array&&"<bytevector>"===e[0],EndOfFile:e=>e instanceof Array&&"<end-of-file>"===e[0],Port:e=>e instanceof Array&&"<port>"===e[0],RecordType:e=>e instanceof Array&&"<record-type>"===e[0],Record:e=>e instanceof Array&&"<record>"===e[0],MultiValue:e=>e instanceof Array&&"<multi-value>"===e[0],SyntaxRules:e=>e instanceof Array&&"<syntax-rules>"===e[0],SyntaxRulePattern:e=>e instanceof Array&&"<syntax-rule-pattern>"===e[0],Parameter:e=>e instanceof Array&&"<parameter>"===e[0],EnvironmentSpec:e=>e instanceof Array&&"<environment-spec>"===e[0],Exception:e=>e instanceof Array&&"<exception>"===e[0],Undefined:e=>e instanceof Array&&"<undefined>"===e[0],Promise:e=>e instanceof Array&&"<promise>"===e[0],Error:e=>e instanceof Array&&"<error>"===e[0],Continuation:e=>e instanceof Array&&"<continuation>"===e[0],Library:e=>e instanceof Array&&"<library>"===e[0],JS:e=>e instanceof Array&&"<js>"===e[0],List:e=>P.Pair(e)||P.Null(e),Procedure:e=>e instanceof Array&&("<procedure>"===e[0]||"<continuation>"===e[0]||"<parameter>"===e[0]),Object:e=>e instanceof Array&&"string"==typeof e[0]&&/^<.*>/.test(e[0]),Evaluatable:e=>P.List(e)||P.Symbol(e),False:e=>P.Boolean(e)&&!1===e[1],RealNumber:e=>P.Number(e)&&"number"==typeof e[1],IntegerNumber:e=>P.Number(e)&&"number"==typeof e[1]&&Number.isInteger(e[1]),Objects:e=>e instanceof Array&&e.every((e=>P.Object(e))),Suspend:e=>e instanceof Array&&"#SUSPEND#"===e[0],JSPromiseContinuation:e=>e instanceof Array&&"#JS-PROMISE-CONTINUATION#"===e[0],Exit:e=>e instanceof Array&&"#EXIT#"===e[0],CallStack:e=>e instanceof Array&&"#CALL-STACK#"===e[0],SpecialObject:e=>e instanceof Array&&"string"==typeof e[0]&&/^#.+#$/.test(e[0]),Dictionary:e=>"object"==typeof e&&!!e&&e.constructor===Object,Stack:e=>e instanceof Array&&3===e.length&&"string"==typeof e[0]&&/^#.*-STACK#$/.test(e[0])},E=(e,r)=>(t,n)=>{if(!e(t))throw j.Error("domain-error",null!=n?n:r)},N=(e,r)=>(t,n)=>{if(!(t instanceof Array))throw j.Error("domain-error",null!=n?n:r);for(const a of t)if(!e(a))throw j.Error("domain-error",null!=n?n:r)},I={List:E(P.List,"A <pair> or <null> is expected."),Pair:E(P.Pair,"A <pair> is expected."),Symbol:E(P.Symbol,"A <symbol> is expected."),Number:E(P.Number,"A <number> is expected."),Boolean:E(P.Boolean,"A <boolean> is expected."),Object:E(P.Object,"A Scheme object is expected."),String:E(P.String,"A <string> is expected."),Vector:E(P.Vector,"A <vector> is expected."),ByteVector:E(P.ByteVector,"A <bytevector> is expected."),Character:E(P.Character,"A <character> is expected."),Promise:E(P.Promise,"A <promise> is expected."),Error:E(P.Error,"A <error> is expected."),Procedure:E(P.Procedure,"A <procedure> is expected."),SyntaxRules:E(P.SyntaxRules,"A <syntax-rules> is expected."),Parameter:E(P.Parameter,"A <parameter> is expected."),EnvironmentSpec:E(P.EnvironmentSpec,"A <environment-spec> is expected."),RecordType:E(P.RecordType,"A <record-type> is expected."),Record:E(P.Record,"A <record> is expected."),MultiValue:E(P.MultiValue,"A <multi-value> is expected."),Port:E(P.Port,"A <port> is expected."),Library:E(P.Library,"A <library> is expected."),Lists:N(P.List,"An array of <pair>/<null> is expected."),Pairs:N(P.Pair,"An array of <pair> is expected."),Symbols:N(P.Symbol,"An array of <symbol> is expected."),Numbers:N(P.Number,"An array of <number> is expected."),Booleans:N(P.Boolean,"An array of <boolean> is expected."),Objects:N(P.Object,"An array of Scheme object is expected."),Strings:N(P.String,"An array of <string> is expected."),Vectors:N(P.Vector,"An array of <vector> is expected."),ByteVectors:N(P.ByteVector,"An array of  <bytevector> is expected."),Characters:N(P.Character,"An array of <character> is expected."),RealNumber:E(P.RealNumber,"A real <number> (not infinite, not NaN) is expected."),IntegerNumber:E(P.IntegerNumber,"A integer <number> is expected."),RealNumbers:N(P.RealNumber,"An array of real <number> is expected."),IntegerNumbers:N(P.IntegerNumber,"An array of integer <number> is expected.")},B=(e,r)=>{if(null==e)throw j.Error("program-error",null!=r?r:"Required object.")},O=e=>"object"==typeof e&&null!==e&&"Object"===e.constructor.name,C=e=>!!e&&"object"==typeof e&&e.language===r&&!!e.version&&(P.Object(e.content)||P.SpecialObject(e.content)),A=e=>C(e)&&P.Suspend(e.content),$=e=>C(e)&&P.JSPromiseContinuation(e.content),L=$,k=Object.prototype.hasOwnProperty,V=e=>{const r=new Set,t=e=>{if(P.Pair(e)){const[,n,a]=e;if(r.has(a))throw new Error("Circular list detected.");return r.add(a),[n,...t(P.List(a)?a:["<null>"])]}return[]};return t(e)},z=e=>{const r=new Set;return(e=>{const[,t,n]=e;if(P.Pair(n)){if(r.has(n))throw new Error("Circular list detected.");r.add(n);const[e,a]=z(n);return[[t,...e],a]}return[[t],n]})(e)},M=(e,r,t=!1,n)=>e.reverse().reduce(((r,a,o)=>n&&o===e.length-1?j.Pair(a,r,t,n):j.Pair(a,r,t)),r||["<null>"]),_=(()=>{let e=0,r=0,t=0;return()=>"::"+"T-S-XXXXXXX".replace(/[TSX]/g,(n=>(r=Date.now(),"T"===n?`0000000000000${r.toString(16)}`.slice(-14):"S"===n?`000${(e===r?(e=r,t=0):t++).toString(16)}`.slice(-4):`000${(65536*Math.random()|0).toString(16)}`.slice(-4))))})(),q=(e,r,t,n=!1,a=!1)=>{if(r.filter((e=>"variadic"===e.type)).length>1)throw new Error("Only one variadic parameter is allowed.");return{name:e,parameters:r,body:t,isMacro:n,hidden:a}},T=(e,r)=>__spreadProps(__spreadValues({},r),{name:e}),D=(e,r)=>e.length===r.length&&e.every(((e,t)=>e===r[t])),R=e=>{var r,t;if(P.List(e)){if(P.Null(e))return[[],null];{const[t,n]=z(e);return I.Symbols(t),P.Null(n)||I.Symbol(n),[t.map((e=>{var r;return{name:null!=(r=e[3])?r:e[1]}})),P.Null(n)?null:{name:null!=(r=n[3])?r:n[1],type:"variadic"}]}}return I.Symbol(e),[[],{name:null!=(t=e[3])?t:e[1],type:"variadic"}]},Q={"Âµ":"Î¼","Í…":"Î¹","Ï‚":"Ïƒ","Ï":"Î²","Ï‘":"Î¸","Ï•":"Ï†","Ï–":"Ï€","Ï°":"Îº","Ï±":"Ï","Ïµ":"Îµ","á¸":"á°","á¹":"á±","áº":"á²","á»":"á³","á¼":"á´","á½":"áµ","á²€":"Ð²","á²":"Ð´","á²‚":"Ð¾","á²ƒ":"Ñ","á²„":"Ñ‚","á²…":"Ñ‚","á²†":"ÑŠ","á²‡":"Ñ£","á²ˆ":"ê™‹","áº›":"á¹¡","á¾¾":"Î¹","ê­°":"áŽ ","ê­±":"áŽ¡","ê­²":"áŽ¢","ê­³":"áŽ£","ê­´":"áŽ¤","ê­µ":"áŽ¥","ê­¶":"áŽ¦","ê­·":"áŽ§","ê­¸":"áŽ¨","ê­¹":"áŽ©","ê­º":"áŽª","ê­»":"áŽ«","ê­¼":"áŽ¬","ê­½":"áŽ­","ê­¾":"áŽ®","ê®€":"áŽ°","ê®":"áŽ±","ê®‚":"áŽ²","ê®ƒ":"áŽ³","ê®„":"áŽ´","ê®…":"áŽµ","ê®†":"áŽ¶","ê®‡":"áŽ·","ê®ˆ":"áŽ¸","ê®‰":"áŽ¹","ê®Š":"áŽº","ê®‹":"áŽ»","ê®Œ":"áŽ¼","ê®":"áŽ½","ê®Ž":"áŽ¾","ê®":"á€","ê®‘":"á","ê®’":"á‚","ê®“":"áƒ","ê®”":"á„","ê®•":"á…","ê®–":"á†","ê®—":"á‡","ê®˜":"áˆ","ê®™":"á‰","ê®š":"áŠ","ê®›":"á‹","ê®œ":"áŒ","ê®":"á","ê®ž":"áŽ","ê® ":"á","ê®¡":"á‘","ê®¢":"á’","ê®£":"á“","ê®¤":"á”","ê®¥":"á•","ê®¦":"á–","ê®§":"á—","ê®¨":"á˜","ê®©":"á™","ê®ª":"áš","ê®«":"á›","ê®¬":"áœ","ê®­":"á","ê®®":"áž","ê®°":"á ","ê®±":"á¡","ê®²":"á¢","ê®³":"á£","ê®´":"á¤","ê®µ":"á¥","ê®¶":"á¦","ê®·":"á§","ê®¸":"á¨","ê®¹":"á©","ê®º":"áª","ê®»":"á«","ê®¼":"á¬","ê®½":"á­","ê®¾":"á®"},U=new RegExp("["+Object.keys(Q).join("")+"]","gu"),F=e=>e.replace(U,(e=>Q[e])).toLowerCase(),J=new RegExp("(?:"+[/\s+/.source,/;[^\n]*(?:\n|$)/.source,/(?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+/.source,/\|(?:[^|\\]|\n|\\(?:.|\n))+\|/.source,/#!(?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+/.source,/"(?:[^"\\]|\n|\\(?:.|\n))*"/.source,/(?:[()[\]{}'`]|,(?!@)|,@)/.source,/#(?:t(?:rue)?|f(?:alse)?|\(|u8\(|\d+[#=]|;)/.source,/#[dDbBoOxXeEiI](?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+/.source,/#\\(?:(?:[^A-Za-z]|\n)|[A-Za-z](?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])*)/.source,Array(16).fill(/#\|(?:[^|#]|\|[^#]|#[^|]|\n|(?:NEST))*\|#/.source).reduce(((e,r)=>e.replace("NEST",r)))].join("|")+")","y"),X={a:"",b:"\b",t:"\t",n:"\n",r:"\r"},Z={alarm:"",backspace:"\b",delete:"",escape:"",newline:"\n",null:"\0",return:"\r",space:" ",tab:"\t"},K=(e,r)=>{var t;const n=(e=>{const r=[0],t=/\n/g;for(let n;n=t.exec(e);)r.push(n.index+1);return t=>{var n;const a=r.filter((e=>e<=t)).slice(-1)[0],o=e.slice(a,t);return[r.indexOf(a)+1,o.length+(null!=(n=o.match(/[^\x01-\x7E\xA1-\xDF]/g))?n:[]).length+1]}})(e),a=[];J.lastIndex=0;let o=!1;for(;J.lastIndex<e.length;){const i=J.lastIndex,[l,s]=n(i),c=r?{filename:r,line:l,column:s}:{line:l,column:s};let[u]=null!=(t=J.exec(e))?t:[];if(null==u){const r=e.slice(i).split(/(\s|\n)+/,2)[0]||e[i],t=r.length>10?r.slice(0,10)+"...":r;throw new Error(`Tokenize failed. Unexpected token is: "${t}": ${JSON.stringify(c)}`)}"#!fold-case"!==u&&"#!no-fold-case"!==u?(o&&(u.match(/^(?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+$/)||u.match(/#\\(?:(?:[^A-Za-z]|\n)|[A-Za-z](?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])*)/))&&(u=F(u)),a.push([u,c])):o=!u.includes("#!no-")}return a},W=e=>{const r=e.filter((e=>!e[0].match(/^(\s|;|#\||#!(no-)?fold-case)/))),t=()=>{const e=[];for(let n=r.shift();n;n=r.shift()){const[r,a]=n;if(!r.match(/^(\s|;|#\|)/))if("("===r)e.push(t().concat(a));else if(["#(","#u8("].includes(r))e.push([r.slice(0,-1),t(),a]);else{if(["'","`",",",",@","#;"].includes(r)||r.match(/^#\d+=$/)){const n=t(),o=n.shift();if(null==o)throw`Unexpected end of source after quoting/datum label "${r}": ${JSON.stringify(a)}`;return"#;"!==r&&e.push([r,o]),e.push(...n),e}if(")"===r)return e;e.push(r)}}return e};return[t(),r]},G=(e,r=null,t,n=new Map)=>{var a;if("string"==typeof e){let t;if(t=/^([+-])(nan|inf)\.0$/i.exec(e))return j.Number(t[0].toLowerCase());if(t=/^(?:#d)?[-+]?\d+(?:\.\d*)?(?:e[-+]?\d+)?$/i.exec(e))return d(Number(e.replace(/^(#d)?0*/i,"")));if(t=/^(?:#b[-+]?[01]+|#o[-+]?[0-7]+|#x[-+]?[0-9A-Fa-f]+)/i.exec(e))return d(Number(e.replace(/^#([xob])([+-]?)/i,"0$1"))*(e.includes("-")?-1:1));if(/^#[dboxei]/i.exec(e))throw new Error(`Unsupported type of number literal: ${e}: ${JSON.stringify(r)}`);if(t=/^"((?:.|\n)*)"$/.exec(e)){const e=t[1].replace(/\\(x[0-9a-fA-F]+;|[ \t]*\n[ \t]*|[^x \t\n])/g,(e=>{var r;return"x"===e[1]?String.fromCodePoint(Number(`0x${e.replace(/;$/,"").slice(2)}`)):/\s|\n/.test(e[1])?"":null!=(r=X[e[1]])?r:e[1]}));return j.String(e,!0)}if(t=/^#([tf])/.exec(e))return j.Boolean("t"===t[1]);if(t=/^#\\((.|\n)*)$/.exec(e)){const e=1===t[1].length?t[1]:t[1].match(/^x[0-9A-Fa-f]+$/)?String.fromCodePoint(Number(`0x${t[1].slice(1)}`)):Z[t[1]];if(!e)throw new Error(`Illegal character literal: ${e}: ${JSON.stringify(r)}`);return j.Character(e)}if("."!==e&&(t=/^(([A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+)$/.exec(e)))return j.Symbol(t[1]);if("."!==e&&(t=/^\|(([^\\]|\n|\\(.|\n))+)\|$/.exec(e))){const e=t[1].replace(/\\(x[0-9a-fA-F]+;|\s*\n\s*|[^x\s\n])/g,(e=>{var r;return"x"===e[1]?String.fromCodePoint(Number(`0x${e.replace(/;$/,"").slice(2)}`)):/\s|\n/.test(e[1])?"":null!=(r=X[e[1]])?r:e[1]}));return j.Symbol(e)}if(t=/^#(\d+)#$/.exec(e)){const a=t[1];if(!n.has(a))throw new Error(`Invalid datum reference (${e}): ${JSON.stringify(r)}`);return n.get(a)}throw new Error(`Parse error: unexpected token: "${e}": ${JSON.stringify(r)}`)}if(e instanceof Array&&"&"!==e[0]){r=null!=(a=e.find((e=>O(e))))?a:r;const o=e.filter((e=>!O(e)));if(0===o.length)return j.Null();if(2===o.length&&"."===o[0])return G(o[1],r,t,n);if("#"===o[0]){if(2!==o.length)throw new Error(`Illegal vector literal. No datum: ${JSON.stringify(r)}`);if(!(o[1]instanceof Array))throw new Error(`Illegal vector literal. Datum is not an array: ${JSON.stringify(r)}`);return j.Vector(o[1].map((e=>G(e,r,t,n))),!0)}if("#u8"===o[0]){if(2!==o.length)throw new Error(`Illegal byte vector literal. No datum: ${JSON.stringify(r)}`);if(!(o[1]instanceof Array))throw new Error(`Illegal byte vector literal. Byte vector must have an array: ${JSON.stringify(r)}`);const e=o[1].map((e=>G(e,r,t,n)));if(!e.every((e=>P.RealNumber(e)&&Number.isInteger(e[1])&&e[1]>=0&&e[1]<=255)))throw new Error(`Illegal byte vector literal. All the contents of a byte vector must be 0-255.: ${JSON.stringify(r)}`);return j.ByteVector(e.map(m),!0)}if("string"==typeof o[0]&&["'","`",",",",@"].includes(o[0])){if(2!==o.length)throw new Error(`Illegal quote "${o[0]}". Quoted item must be a datum: ${JSON.stringify(r)}`);const e={"'":"quote","`":"quasiquote",",":"unquote",",@":"unquote-splicing"}[o[0]];return j.Pair(j.Symbol(e),j.Pair(G(o[1],r,t,n),j.Null(),!0),!0,(null==t?void 0:t.removeLineInfo)?null:r)}if("string"==typeof o[0]&&/^#(\d+)=$/.exec(o[0])){const[,e]=/^#(\d+)=$/.exec(o[0]);if(2!==o.length)throw new Error(`Illegal datum label. No next datum: ${JSON.stringify(r)}`);const a=j.Symbol(o[0]);n.set(e,a);const i=G(o[1],r,t,n);return a.splice(0,a.length,...i),a}if((null==t?void 0:t.extended)&&P.Object(e))return e;if((null==t?void 0:t.extended)&&"&"===e[0]){if(2!=e.length)throw new Error(`Parse error: JS Node must be like ["&", <object>]: ${typeof e} value: ${e}`);return j.JS("inline",e[1])}return j.Pair(G(o[0],r,t,n),G(o.slice(1),r,t,n),!0,(null==t?void 0:t.removeLineInfo)?null:r)}if((null==t?void 0:t.extended)&&null===e)return j.Null();if((null==t?void 0:t.extended)&&"number"==typeof e)return d(e);if((null==t?void 0:t.extended)&&"boolean"==typeof e)return j.Boolean(e);throw new Error(`Parse error: unexpected node type: ${typeof e} value: ${e}`)},H=(e,r=null,t)=>G(e,r,__spreadProps(__spreadValues({},null!=t?t:{}),{extended:!0})),Y=(e,r)=>{const t=K(e,null==r?void 0:r.filename),[n,a]=W(t);if(a.length>0)throw new Error(`Parse error: extra tokens. (missing right curly?), ${JSON.stringify(a[0][1])}`);return G(["begin",...n],null,r)},ee=q("not",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.False(e))))),re=q("boolean?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.Boolean(e))))),te=q("boolean=?",[{name:"boolean1"},{name:"boolean2"},{name:"booleans",type:"variadic"}],(({boolean1:e,boolean2:r,booleans:t})=>(I.Boolean(e),I.Boolean(r),I.Booleans(t),j.Boolean([r,...t].every((r=>r[1]===e[1])))))),ne={not:ee,booleanQ:re,booleanEQ:te},ae=q("bytevector?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.ByteVector(e))))),oe=q("make-bytevector",[{name:"k"},{name:"byte",type:"optional"}],(({k:e,byte:r})=>(I.IntegerNumber(e),r&&I.IntegerNumber(r),j.ByteVector(Array(e[1]).fill(r?r[1]:0),!1)))),ie=q("bytevector",[{name:"bytes",type:"variadic"}],(({bytes:e})=>(I.IntegerNumbers(e),j.ByteVector(e.map((e=>e[1])),!1)))),le=q("bytevector-length",[{name:"bvec"}],(({bvec:e})=>(I.ByteVector(e),j.Number(e[1].length)))),se=q("bytevector-u8-ref",[{name:"bvec"},{name:"k"}],(({bvec:e,k:r})=>{if(I.ByteVector(e),I.IntegerNumber(r),!(r[1]in e[1]))throw j.Error("out-of-range","Index is out of range.");return j.Number(e[1][r[1]])})),ce=q("bytevector-u8-set!",[{name:"bvec"},{name:"k"},{name:"byte"}],(({bvec:e,k:r,byte:t})=>{if(I.ByteVector(e),I.IntegerNumber(r),I.IntegerNumber(t),!(r[1]in e[1]))throw j.Error("out-of-range","Index is out of range.");return e[1][r[1]]=t[1],["<undefined>"]})),ue=q("bytevector-copy",[{name:"bvec"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({bvec:e,start:r,end:t})=>{I.ByteVector(e);const n=e[1];if(0===n.length)return j.ByteVector([],!1);const a=P.Number(r)?r[1]:0,o=P.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw j.Error("domain-error","Index must be integer.");return j.ByteVector(n.slice(a,o),!1)})),me=q("bytevector-copy!",[{name:"to"},{name:"at"},{name:"from"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({to:e,at:r,from:t,start:n,end:a})=>{I.ByteVector(e),I.IntegerNumber(r),I.ByteVector(t);const o=P.Number(n)?n[1]:0,i=P.Number(a)?a[1]:t[1].length;if("number"!=typeof o||!Number.isInteger(o)||"number"!=typeof i||!Number.isInteger(i))throw j.Error("domain-error","Index must be integer.");if(!(r[1]in e[1]))throw j.Error("out-of-range","Index is out of range.");if(e[1].length-r[1]<i-o)throw j.Error("out-of-range","Index is out of range.");const l=t[1].slice(o,i);return e[1].splice(r[1],l.length,...l),["<undefined>"]})),de=q("bytevector-append",[{name:"vecs",type:"variadic"}],(({vecs:e})=>(I.ByteVectors(e),j.ByteVector(e.map((e=>e[1])).flat(),!1)))),pe=q("utf8->string",[{name:"bvec"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({bvec:e,start:r,end:t})=>{I.ByteVector(e);const n=e[1],a=P.Number(r)?r[1]:0,o=P.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw j.Error("domain-error","Index must be integer.");const i=new Uint8Array(n.slice(a,o));return j.String((new TextDecoder).decode(i),!1)})),fe=q("string->utf8",[{name:"str"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,start:r,end:t})=>{I.String(e);const n=Array.from(e[1]),a=P.Number(r)?r[1]:0,o=P.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw j.Error("domain-error","Index must be integer.");const i=(new TextEncoder).encode(n.slice(a,o).join(""));return j.ByteVector(Array.from(i),!1)})),be={bytevectorQ:ae,makeBytevector:oe,bytevector:ie,bytevectorLength:le,bytevectorU8Ref:se,bytevectorU8SetD:ce,bytevectorCopy:ue,bytevectorCopyD:me,bytevectorAppend:de,utf8ToString:pe,stringToUtf8:fe},ye=q("char?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.Character(e))))),he=q("char=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>(I.Character(e),I.Character(r),I.Characters(t),j.Boolean([r,...t].every((r=>r[1]===e[1])))))),ge=q("char<?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{I.Character(e),I.Character(r),I.Characters(t);const n=[e,r,...t].map((e=>e[1]));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]<e)))})),ve=q("char>?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{I.Character(e),I.Character(r),I.Characters(t);const n=[e,r,...t].map((e=>e[1]));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]>e)))})),Se=q("char<=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{I.Character(e),I.Character(r),I.Characters(t);const n=[e,r,...t].map((e=>e[1]));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]<=e)))})),we=q("char>=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{I.Character(e),I.Character(r),I.Characters(t);const n=[e,r,...t].map((e=>e[1]));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]>=e)))})),je=q("char->integer",[{name:"char"}],(({char:e})=>{I.Character(e);const r=e[1].codePointAt(0);if(void 0===r)throw j.Error("out-of-range","Can't convert character to codepoint.");return j.Number(r)})),xe=q("integer->char",[{name:"n"}],(({n:e})=>(I.IntegerNumber(e),j.Character(String.fromCodePoint(e[1]))))),Pe={charQ:ye,charEQ:he,charLtQ:ge,charGtQ:ve,charLeQ:Se,charGeQ:we,charToInteger:je,integerToChar:xe},Ee=q("procedure?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.Procedure(e)))),!0),Ne=q("apply",[{name:"proc"},{name:"args",type:"variadic"}],(({proc:e,args:r},t,n)=>{let a;if(I.Procedure(e),I.Objects(r),B(t),B(n),0===r.length)a=[];else{const[e,t]=[r.slice(0,r.length-1),r[r.length-1]];I.List(t),a=[...e,...V(t)]}return x.Call(e,j.MultiValue(a))}),!0),Ie=q("map",[{name:"proc"},{name:"list1"},{name:"lists",type:"variadic"}],(({proc:e,list1:r,lists:t})=>{I.Procedure(e),I.List(r),I.Lists(t);const n=[r,...t];return n.every((e=>P.Pair(e)))?x.Cons(x.Call(e,j.MultiValue(n.map((e=>e[1])))),x.CallBuiltIn("map",j.MultiValue([e,...n.map((e=>e[2]))]))):x.Quote(["<null>"])}),!0),Be=q("string-map",[{name:"proc"},{name:"str1"},{name:"strs",type:"variadic"}],(({proc:e,str1:r,strs:t})=>{I.Procedure(e),I.String(r),I.Strings(t);const n=[Array.from(r[1]),...t.map((e=>Array.from(e[1])))];return n.every((e=>e.length>1))?x.CallBuiltIn("string-append",x.CallBuiltIn("string",x.Call(e,...n.map((e=>j.Character(e[0]))))),x.CallBuiltIn("string-map",e,...n.map((e=>j.String(e.slice(1).join(""),!1))))):n.every((e=>e.length>=1))?x.CallBuiltIn("string",x.Call(e,...n.map((e=>j.Character(e[0]))))):j.String("",!1)}),!0),Oe=q("vector-map",[{name:"proc"},{name:"vector1"},{name:"vectors",type:"variadic"}],(({proc:e,vector1:r,vectors:t})=>{I.Procedure(e),I.Vector(r),I.Vectors(t);const n=[r,...t];return n.every((e=>e[1].length>1))?x.CallBuiltIn("vector-append",x.CallBuiltIn("vector",x.Call(e,j.MultiValue(n.map((e=>e[1][0]))))),x.CallBuiltIn("vector-map",e,...n.map((e=>j.Vector(e[1].slice(1),!1))))):n.every((e=>e[1].length>=1))?x.CallBuiltIn("vector",x.Call(e,j.MultiValue(n.map((e=>e[1][0]))))):j.Vector([],!1)}),!0),Ce=q("for-each",[{name:"proc"},{name:"list1"},{name:"lists",type:"variadic"}],(({proc:e,list1:r,lists:t})=>{I.Procedure(e),I.List(r),I.Lists(t);const n=[r,...t];return n.every((e=>P.Pair(e)))?x.Begin(x.Call(e,j.MultiValue(n.map((e=>e[1])))),x.CallBuiltIn("for-each",j.MultiValue([e,...n.map((e=>e[2]))]))):["<undefined>"]}),!0),Ae=q("string-for-each",[{name:"proc"},{name:"str1"},{name:"strs",type:"variadic"}],(({proc:e,str1:r,strs:t})=>{I.Procedure(e),I.String(r),I.Strings(t);const n=[Array.from(r[1]),...t.map((e=>Array.from(e[1])))];return n.every((e=>e.length>1))?x.Begin(x.Call(e,...n.map((e=>j.Character(e[0])))),x.CallBuiltIn("string-for-each",e,...n.map((e=>j.String(e.slice(1).join(""),!1))))):n.every((e=>e.length>=1))?x.Call(e,...n.map((e=>j.Character(e[0])))):["<undefined>"]}),!0),$e=q("vector-for-each",[{name:"proc"},{name:"vector1"},{name:"vectors",type:"variadic"}],(({proc:e,vector1:r,vectors:t})=>{I.Procedure(e),I.Vector(r),I.Vectors(t);const n=[r,...t];return n.every((e=>e[1].length>1))?x.Begin(x.Call(e,j.MultiValue(n.map((e=>e[1][0])))),x.CallBuiltIn("vector-for-each",e,...n.map((e=>j.Vector(e[1].slice(1),!1))))):n.every((e=>e[1].length>=1))?x.Call(e,j.MultiValue(n.map((e=>e[1][0])))):x.Quote(["<null>"])}),!0),Le=q("call-with-current-continuation",[{name:"proc"}],(({proc:e},r,t)=>(I.Procedure(e),B(t),x.Call(e,j.Continuation(b(t))))),!0),ke=T("call/cc",Le),Ve=q("values",[{name:"objs",type:"variadic"}],(({objs:e})=>(I.Objects(e),1===e.length?e[0]:j.MultiValue(e)))),ze=q("call-with-values",[{name:"producer"},{name:"consumer"}],(({producer:e,consumer:r},t,n)=>{I.Procedure(e),I.Procedure(r),B(n);const a=S(n,j.List(r),{want:"args",oper:r});return v(a,j.List(e))})),Me=q("dynamic-wind",[{name:"before"},{name:"thunk"},{name:"after"}],(({before:e,thunk:r,after:t},n,a)=>{I.Procedure(e),I.Procedure(r),I.Procedure(t),B(a);const o=j.Continuation(b(a));return v(a,x.Begin(x.Call(e),x.Call(o,x.Call(r))),{before:e,after:t})})),_e={procedureQ:Ee,apply:Ne,map:Ie,stringMap:Be,vectorMap:Oe,forEach:Ce,stringForEach:Ae,vectorForEach:$e,callWithCurrentContinuation:Le,callCC:ke,values:Ve,callWithValues:ze,dynamicWind:Me},qe=q("eqv?",[{name:"obj1"},{name:"obj2"}],(({obj1:e,obj2:r})=>{I.Object(e),I.Object(r);const t=e=>P.String(e)||P.ByteVector(e)||P.Vector(e)?e.slice(0,e.length-1):P.Pair(e)?e.slice(0,3):P.Symbol(e)?e.slice(0,2):e;return j.Boolean(e===r||D(t(e),t(r)))})),Te=T("eq?",qe),De=q("equal?",[{name:"obj1"},{name:"obj2"}],(({obj1:e,obj2:r})=>{I.Object(e),I.Object(r);const t=(e,r)=>e===r||(P.Pair(e)&&P.Pair(r)?t(e[1],r[1])&&t(e[2],r[2]):P.Vector(e)&&P.Vector(r)?e[1]===r[1]||e[1].length===r[1].length&&e[1].every(((e,n)=>t(e,r[1][n]))):P.ByteVector(e)&&P.ByteVector(r)?D(e[1],r[1]):qe.body({obj1:e,obj2:r})[1]);return j.Boolean(t(e,r))})),Re={eqvQ:qe,eqQ:Te,equalQ:De},Qe=q("with-exception-handler",[{name:"handler"},{name:"thunk"}],(({handler:e,thunk:r},t,n)=>(I.Procedure(e),I.Procedure(r),B(n),S(n,x.Call(r),{handler:j.HandlerStack(e,h(n).handler)})))),Ue=q("raise",[{name:"obj"}],(({obj:e},r,t)=>{throw I.Object(e),B(t),j.Exception(t,e,!1)})),Fe=q("raise-continuable",[{name:"obj"}],(({obj:e},r,t)=>{throw I.Object(e),B(t),j.Exception(t,e,!0)})),Je=q("error",[{name:"message"},{name:"objs",type:"variadic"}],(({message:e,objs:r},t,n)=>{throw I.String(e),I.Objects(r),B(n),j.Exception(n,j.Error("error",e[1],r),!0)})),Xe=q("error-object?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.Error(e))))),Ze=q("error-object-message",[{name:"err"}],(({err:e})=>{var r;return I.Error(e),j.String(null!=(r=e[2])?r:e[1],!1)})),Ke=q("error-object-irritants",[{name:"err"}],(({err:e})=>(I.Error(e),j.List(...e[3])))),We=q("read-error?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.Error(e)&&"read-error"===e[1])))),Ge=q("file-error?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.Error(e)&&"file-error"===e[1])))),He={withExceptionHandler:Qe,raise:Ue,raiseContinuable:Fe,error:Je,errorObjectQ:Xe,errorObjectMessage:Ze,errorObjectIrritants:Ke,readErrorQ:We,fileErrorQ:Ge},Ye=q("suspend",[{name:"obj",type:"optional"}],(({obj:e},r,t)=>{throw B(t),e&&I.Object(e),j.Suspend(j.Continuation(b(t)),null!=e?e:j.Undefined())})),er=q("read-file",[{name:"filename"},{name:"cli",type:"optional"}],(({filename:e,cli:r},t)=>{if(B(t),I.String(e),r&&I.Boolean(r),!(null==t?void 0:t.fs))throw j.Error("program-error",'No interpreter object or No Node.js "fs" object set on Interpreter.');let n,a;try{n=t.fs.readFileSync(e[1]).toString()}catch{throw j.Error("read-error",`Can't read file from ${e[1]}.`)}try{a=Y(r&&r[1]?"#!fold-case "+n:n,{filename:e[1]})}catch(o){throw o instanceof Error?j.Error("read-error",o.message):j.Error("read-error","Error occured while reading.")}return a}),!1,!0),rr={suspend:Ye,readFile:er},tr=q("features",[],(()=>j.List(j.Symbol("r7rs"),j.Symbol(r),j.Symbol(r+"-"+t)))),nr={features:tr},ar=q("quote",[{name:"value",evaluate:!1}],(({value:e})=>(I.Object(e),e))),or=q("lambda",[{name:"formals",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({formals:e,body:r},t,n)=>{I.Object(e),I.Objects(r),B(n);const[a,o]=R(e);return j.Procedure("lambda",o?[...a,o]:a,x.BeginIfMultiple(...r),!1,h(n).env)})),ir=q("if",[{name:"test"},{name:"consequent",evaluate:!1},{name:"alternate",type:"optional",evaluate:!1}],(({test:e,consequent:r,alternate:t})=>(I.Object(e),I.Object(r),P.False(e)?t?(I.Object(t),t):["<undefined>"]:r)),!0),lr=q("set!",[{name:"variable",evaluate:!1},{name:"expr"}],(({variable:e,expr:r},t,n)=>{if(B(t),B(n),I.Symbol(e),I.Object(r),P.Undefined(r))throw j.Error("undefined-variable",`Attempt to set undefined value to a variable "${e[1]}"`);if(!t.setStatic(h(n).env.static,e,r))throw j.Error("unbound-variable",`Attempt to set value to an unbound variable "${e[1]}"`);return["<undefined>"]})),sr=q("include",[{name:"str1"},{name:"strs",type:"variadic"}],(({str1:e,strs:r},t,n)=>{B(t),B(n),I.String(e),I.Strings(r);const a=[e,...r].map((e=>er.body({filename:e},t)));return 1===a.length?a[0]:x.Begin(...a)}),!0),cr=q("include-cli",[{name:"str1"},{name:"strs",type:"variadic"}],(({str1:e,strs:r},t,n)=>{B(t),B(n),I.String(e),I.Strings(r);const a=[e,...r].map((e=>er.body({filename:e,cli:j.Boolean(!0)},t)));return 1===a.length?a[0]:x.Begin(...a)}),!0),ur=q("cond",[{name:"clause",evaluate:!1},{name:"clauses",type:"variadic",evaluate:!1}],(({clause:e,clauses:r})=>{I.Pair(e),I.Pairs(r);const t=0===r.length?["<undefined>"]:x.Cond(r[0],...r.splice(1)),[n,a,...o]=V(e);if(P.Symbol(n)&&"else"===n[1])return x.BeginIfMultiple(a,...o);if(a){if(P.Symbol(a)&&"=>"===a[1]){if(1!==o.length)throw j.Error("syntax-error","Illegal cond syntax (test => expression).");const e=j.Symbol(_());return x.Let([[e,n]],x.If(e,x.Call(o[0],e),t))}return x.If(n,x.BeginIfMultiple(a,...o),t)}return x.Or(n,t)}),!0),mr=q("case",[{name:"key"},{name:"clauses",type:"variadic",evaluate:!1}],(({key:e,clauses:r})=>{I.Object(e),I.Pairs(r);const t=r.find(((t,n)=>{if(P.Symbol(t[1])&&"else"===t[1][1]){if(n!==r.length-1)throw j.Error("syntax-error","Illegal case syntax (else placement).");return!0}return I.Pair(t[1]),V(t[1]).some((r=>qe.body({obj1:r,obj2:e})[1]))}));if(t){const[,r,...n]=V(t);if(r){if(P.Symbol(r)&&"=>"===r[1]){if(1!==n.length)throw j.Error("syntax-error","Illegal cond syntax (test => expression).");return x.Call(n[0],j.MultiValue([e]))}return x.BeginIfMultiple(r,...n)}throw j.Error("syntax-error","Illegal cond syntax (short clause).")}return["<undefined>"]}),!0),dr=q("and",[{name:"first",type:"optional"},{name:"rest",type:"variadic",evaluate:!1}],(({first:e,rest:r})=>e?(I.Object(e),I.Objects(r),0===r.length||P.False(e)?x.Quote(e):x.And(...r)):j.Boolean(!0)),!0),pr=q("or",[{name:"first",type:"optional"},{name:"rest",type:"variadic",evaluate:!1}],(({first:e,rest:r})=>e?(I.Object(e),I.Objects(r),0!==r.length&&P.False(e)?x.Or(...r):x.Quote(e)):j.Boolean(!1)),!0),fr=q("when",[{name:"test"},{name:"expr",evaluate:!1},{name:"exprs",type:"variadic",evaluate:!1}],(({test:e,expr:r,exprs:t})=>(I.Object(e),I.Object(r),I.Objects(t),P.False(e)?["<undefined>"]:x.BeginIfMultiple(r,...t))),!0),br=q("unless",[{name:"test"},{name:"expr",evaluate:!1},{name:"exprs",type:"variadic",evaluate:!1}],(({test:e,expr:r,exprs:t})=>(I.Object(e),I.Object(r),I.Objects(t),P.False(e)?x.BeginIfMultiple(r,...t):["<undefined>"])),!0),yr=q("cond-expand",[{name:"clause1",evaluate:!1},{name:"clauses",type:"variadic",evaluate:!1}],(({clause1:e,clauses:r},t,n)=>{I.Pair(e),I.Pairs(r),B(t),B(n);const a=[e,...r],o=V(tr.body()),i=e=>{if(P.Symbol(e))return o.some((r=>P.Symbol(r)&&r[1]===e[1]));if(P.Pair(e)){const[,r,a]=e;if(P.Symbol(r)&&P.List(a)){if("and"===r[1])return V(a).every((e=>i(e)));if("or"===r[1])return V(a).some((e=>i(e)));if("not"===r[1]){if(P.Pair(a))return!i(a[1])}else if("library"===r[1]&&P.Pair(a)){const e=c(a[1]);if(t.getBuiltInLibrary(e))return!0;{const r=t.getStatic(h(n).env.static,j.Symbol(e));return P.Library(r)}}}}return!1},l=a.find((e=>i(e[1])));return l?j.Pair(j.Procedure("built-in","begin"),l[2]):j.Undefined()}),!0),hr=q("let",[{name:"args",type:"variadic",evaluate:!1}],(({args:e},r,t)=>{I.Objects(e);const[n,a,...o]=P.Symbol(e[0])?e:[null,...e];I.List(a),I.Objects(o),B(t);const i=V(a).map((e=>{I.Pair(e),I.Symbol(e[1]),I.Pair(e[2]);const[,r,[,t]]=e;return[r,t]})),l=i.map((([e])=>e)),s=i.map((([,e])=>e)),c=x.Lambda(l,null,...o);return n?(I.Symbol(n),x.CallThunk(x.Define(n,c),x.Call(n,...s))):x.Call(c,...s)}),!0),gr=q("let*",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{if(I.List(e),I.Objects(r),B(n),P.Pair(e)){I.Pair(e[1]),I.Pair(e[1][2]);const[,[,t,[,n]],a]=e;return I.Symbol(t),x.Call(x.Lambda([t],null,x.CallBuiltIn("let*",a,...r)),n)}return x.BeginIfMultiple(...r)}),!0),vr=q("letrec",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{I.List(e),I.Objects(r),B(t),B(n);const a=V(e).map((e=>{I.Pair(e),I.Symbol(e[1]),I.Pair(e[2]);const[,r,[,t]]=e;return[r,t]})),{static:o,dynamic:i}=h(n).env,l=w(o);return a.forEach((([e])=>t.defineStatic(l,e,["<undefined>"]))),x.Call(j.Procedure("lambda",[],x.Begin(x.DefineValues(a.map((([e])=>e)),x.Values(...a.map((([,e])=>e)))),...r),!1,{static:l,dynamic:i}))}),!0),Sr=q("letrec*",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{I.List(e),I.Objects(r),B(t),B(n);const a=V(e).map((e=>{I.Pair(e),I.Symbol(e[1]),I.Pair(e[2]);const[,r,[,t]]=e;return[r,t]})),{static:o,dynamic:i}=h(n).env,l=w(o);return a.forEach((([e])=>t.defineStatic(l,e,["<undefined>"]))),x.Call(j.Procedure("lambda",[],x.Begin(...a.map((([e,r])=>x.Set(e,r))),...r),!1,{static:l,dynamic:i}))}),!0),wr=q("let-values",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>(I.List(e),I.Objects(r),B(n),x.CallThunk(...V(e).map((e=>{I.Pair(e),I.Pair(e[2]);const[,r,[,t]]=e,a=j.Procedure("lambda",[],t,!1,h(n).env);return x.CallBuiltIn("define-values",r,x.Call(a))})),...r))),!0),jr=q("let*-values",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{if(I.List(e),I.Objects(r),B(n),P.Pair(e)){I.Pair(e[1]),I.Pair(e[1][2]);const[,[,t,[,n]],a]=e;return x.CallThunk(x.CallBuiltIn("define-values",t,n),x.CallBuiltIn("let*-values",a,...r))}return x.BeginIfMultiple(...r)}),!0),xr=q("begin",[{name:"exprs",type:"variadic",evaluate:!0},{name:"last",type:"tail",evaluate:!1}],(({exprs:e,last:r},t,n)=>(((e,r)=>{if(!(e instanceof Array))throw j.Error("program-error",null!=r?r:"An array is expected.")})(e),I.Object(r),B(n),0===h(n).depth?v(n,r):r)),!0),Pr=q("do",[{name:"specs",evaluate:!1},{name:"clause",evaluate:!1},{name:"commands",type:"variadic",evaluate:!1}],(({specs:e,clause:r,commands:t})=>{I.List(e),I.List(r),I.Objects(t);const n=V(e).map((e=>{I.Pair(e),I.Pair(e[2]),I.Symbol(e[1]);const[,r,[,t,n]]=e;return[r,t,P.Pair(n)?n[1]:null]})),[,a,o]=r;return I.Object(a),I.List(o),x.Let(n.map((([e,r])=>[e,r])),x.If(a,P.Null(o)?j.Undefined():x.Begin(...V(o)),x.Begin(...t,x.CallBuiltIn("do",j.List(...n.map((([e,,r])=>j.List(e,null!=r?r:e,null!=r?r:e)))),r,...t))))}),!0),Er=q("make-parameter",[{name:"init"},{name:"converter",type:"optional"}],(({init:e,converter:r},t,n)=>{I.Object(e),B(t),B(n);let a=_();for(;a in h(n).env.dynamic[1];)a=_();return r&&I.Procedure(r),t.defineDynamic(h(n).env.dynamic,a,e),j.Parameter(a,null!=r?r:null)})),Nr=q("parameterize",[{name:"assocs",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({assocs:e,body:r},t,n)=>{I.Pair(e),I.Pairs(r),B(t),B(n);const{env:a}=h(n),o=V(e).map((e=>{I.Pair(e),I.Pair(e[2]);const[,r,[,t]]=e;return[r,t]})),i={static:a.static,dynamic:j.DynamicNS({},a.dynamic)},l=x.BeginIfMultiple(...o.map((([e,r])=>x.CallBuiltIn("define-parameter",e,r))),...r);return S(n,l,{env:i})})),Ir=q("define-parameter",[{name:"param"},{name:"value",evaluate:!1}],(({param:e,value:r},t,n)=>{I.Parameter(e),I.Object(r),B(t),B(n);const[,,a]=e;return x.CallBuiltIn("define-parameter-1",e,a?x.Call(a,r):r)}),!0,!0),Br=q("define-parameter-1",[{name:"param"},{name:"value"}],(({param:e,value:r},t,n)=>{var a;if(I.Parameter(e),I.Object(r),B(t),B(n),!P.Undefined(null!=(a=f(h(n).env.dynamic)[e[1]])?a:["<undefined>"]))throw j.Error("redefine-variable",null);return t.defineDynamic(h(n).env.dynamic,e[1],r),["<undefined>"]}),!1,!0),Or=q("guard",[{name:"arg1",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({arg1:e,body:r},t,n)=>{I.Pair(e),I.Objects(r),I.Symbol(e[1]),I.Pair(e[2]),B(n);const[,a,o]=e,i=j.Continuation(b(n)),l=j.Procedure("lambda",[{name:a[1]}],x.Call(i,x.CallBuiltIn("cond",...V(o),j.List(j.Symbol("else"),x.RaiseContinuable(a)))),!1,h(n).env);return x.CallBuiltIn("with-exception-handler",l,x.Lambda([],null,...r))}),!0),Cr=q("quasiquote",[{name:"template",evaluate:!1}],(({template:e})=>{I.Object(e);const r=[],t=[],n=(e,a)=>{if(P.Pair(e)){const[,o,i]=e;if(P.Symbol(o)&&"quasiquote"===o[1])return j.Pair(o,n(i,a+1));if(P.Symbol(o)&&"unquote"===o[1]||"unquote-splicing"===o[1]){if(0!==a)return j.Pair(o,n(i,a-1));{const e=j.Symbol("unquote-splicing"===o[1]?"@"+_():_());return I.Pair(i),r.push(e),t.push(i[1]),e}}return j.Pair(n(o,a),n(i,a))}return P.Vector(e)?j.Vector(e[1].map((e=>n(e,a))),!1):e},a=n(e,0);return x.CallBuiltIn("quasiquote-1",a,j.List(...r),...t)}),!0),Ar=q("quasiquote-1",[{name:"template",evaluate:!1},{name:"marks",evaluate:!1},{name:"exprs",type:"variadic"}],(({template:e,marks:r,exprs:t})=>{I.Object(e),I.List(r),I.Objects(t);const n=V(r);I.Symbols(n);const a=new Map;if(n.length!==t.length)throw j.Error("arity-error","quasiquote-1: marks and exprs unmatch.");n.forEach(((e,r)=>a.set(e[1],t[r])));const o=e=>{if(P.Pair(e)){const[,r,t]=e;if(P.Symbol(r)&&"@"===r[1][0]&&a.has(r[1])){const e=a.get(r[1]);if(P.List(e))return P.Null(e)?o(t):M(V(e),o(t));throw j.Error("error","unquote-splicing evaluated as non-list object.")}return j.Pair(o(r),o(t))}return P.Vector(e)?j.Vector(e[1].map((e=>{if(P.Symbol(e)&&"@"===e[1][0]&&a.has(e[1])){const r=a.get(e[1]);if(P.List(r))return P.Null(r)?[]:V(r);throw j.Error("error","unquote-splicing evaluated as non-list object.")}return[o(e)]})).flat(),!1):P.Symbol(e)&&a.has(e[1])&&"@"!==e[1][0]?a.get(e[1]):e};return o(e)}),!1,!0),$r=q("let-syntax",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{I.List(e,"aa"),I.Objects(r),B(n);const a=V(e).map((e=>{I.Pair(e),I.Pair(e[2]),I.Symbol(e[1]);const[,r,[,t]]=e;return[r,j.Procedure("lambda",[],t,!1,h(n).env)]}));return x.CallThunk(...a.map((([e,r])=>x.CallBuiltIn("define-syntax",e,x.Call(r)))),...r)}),!0),Lr=q("letrec-syntax",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{I.List(e),I.Objects(r),B(t),B(n);const a=V(e).map((e=>{I.Pair(e),I.Pair(e[2]),I.Symbol(e[1]);const[,r,[,t]]=e;return[r,t]})),{static:o,dynamic:i}=h(n).env,l=w(o);return a.forEach((([e])=>t.defineStatic(l,e,["<undefined>"]))),x.Call(j.Procedure("lambda",[],x.Begin(...a.map((([e,r])=>x.CallBuiltIn("define-syntax",e,r))),...r),!1,{static:l,dynamic:i}))}),!0),kr=(e,r,t=!0)=>{var n;const[a,o]=z(e),i=a.findIndex((e=>P.Symbol(e)&&e[1]===r)),l=t?i<0?a.slice(1):a.slice(1,i-1):i<0?a:a.slice(0,i-1),s=i<0?[]:a.slice(i+1),c=i<0?null:null!=(n=a[i-1])?n:null;return["<syntax-rule-pattern>",l.map((e=>P.Pair(e)?kr(e,r,!1):e)),c?P.Pair(c)?kr(c,r,!1):c:null,s.map((e=>P.Pair(e)?kr(e,r,!1):e)),P.Null(o)?null:o]},Vr=q("syntax-rules",[{name:"arg1",evaluate:!1},{name:"arg2",evaluate:!1},{name:"args",type:"variadic",evaluate:!1}],(({arg1:e,arg2:r,args:t},n,a)=>{I.Object(e),I.Object(r),I.Objects(t),B(n),B(a);const[o,i,l]=P.Symbol(e)?[e[1],r,t]:["...",e,[r,...t]];I.List(i);const s=V(i).map((e=>(I.Symbol(e),e[1]))),c=(e,r=new Map)=>{var t;if(P.Pair(e))return j.Pair(c(e[1],r),c(e[2],r));if(P.Symbol(e)){if(n.getStatic(h(a).env.static,e))return j.Symbol(e[1],h(a).env.static,null!=(t=e[3])?t:null);if(s.includes(e[1])||o===e[1]||"_"===e[1])return e;if(r.has(e[1]))return r.get(e[1]);{const t=j.Symbol(e[1],null,_());return r.set(e[1],t),t}}return e};I.Pairs(l);const u=[];for(const m of l){const e=c(m);I.Pair(e),I.Pair(e[2]);const[,r,[,t]]=e;I.Pair(r);const[n,a]=z(r);if(!P.Null(a)&&n.some((e=>P.Symbol(e)&&e[1]===o)))throw j.Error("syntax-error","The root of a syntax-rules pattern with ellipsis must be a proper list.");u.push([kr(r,o),t])}return j.SyntaxRules(o,s,u)})),zr=(e,r)=>{if(P.SyntaxRulePattern(e)){const[,t,n,a,o]=e;return[...t,...n?[n]:[],...a,...o?[o]:[]].map((e=>zr(e,r))).flat()}return P.Symbol(e)&&!r.includes(e[1])?"_"===e[1]?[]:[e[1]]:[]},Mr=(e,r,t,n,a,o)=>{if(P.SyntaxRulePattern(e)){if(!P.List(r))return null;const[,i,l,s,c]=e;if(P.Null(r))return 0!==i.length||l||0!==s.length||c?null:new Map;const[u,m]=z(r);if(l||c){if(u.length<i.length+s.length)return null}else if(u.length!==i.length+s.length)return null;let d;if(l){const e=u.length-i.length-s.length;d=[...i,...Array(e).fill(l),...s],c&&(d.push(c),u.push(m))}else d=[...i],c&&(d.push(c),u.push(M(u.slice(i.length),m)));const p=new Map;l&&zr(l,o).forEach((e=>p.set(e,[])));for(let e=0;e<d.length;e++){const[r,i]=[d[e],u[e]],s=Mr(r,i,t,n,a,o);if(!s)return null;if(r===l)for(const[e,t]of s.entries()){const r=p.get(e);if(!r||P.Object(r))throw j.Error("syntax-error",`Internal error: illegal behavior of syntax-rules. No array prepared for variadic variable "${e}".`);P.Object(t)?p.set(e,[...r,t]):p.set(e,[...r,...t])}else for(const[e,t]of s.entries()){if(p.has(e))throw j.Error("syntax-error","The same pattern variable appeared more than once in a pattern.");p.set(e,t)}}return p}if(P.Symbol(e)&&o.includes(e[1])){if(!P.Symbol(r))return null;const o=t.getStatic(a,e),i=t.getStatic(n,e);return e[1]===r[1]&&o===i?new Map:null}return P.Symbol(e)?"_"===e[1]?new Map:new Map([[e[1],r]]):De.body({obj1:e,obj2:r})[1]?new Map:null},_r=q("use-syntax-rules",[{name:"spec"},{name:"args"}],(({spec:e,args:r},t,n)=>{I.SyntaxRules(e),I.List(r),B(t),B(n);const[,a,o,i]=e,l=h(b(n)).env.static,s=h(n).env.static;let c,u;{let e,n;for(const a of i)if(e=Mr(a[0],r,t,l,s,o)){n=a[1];break}if(!e||!n)throw j.Error("syntax-error","No rules match arguments.");[c,u]=[e,n]}const m=e=>{if(P.Pair(e)){const[,r,t]=e;if(P.Symbol(r)&&c.has(r[1])&&P.Symbol(t[1])&&t[1][1]===a){const e=c.get(r[1]);if(!e||P.Object(e))throw j.Error("syntax-error",`Pattern variable "${r[1]} is not variadic." `);return M(e,m(t[2]))}return P.Pair(r)&&P.Symbol(r[1])&&r[1][1]===a&&P.Pair(r[2])?j.Pair(m(r[2][1]),m(t)):j.Pair(m(r),m(t))}if(P.Symbol(e)&&c.has(e[1])){const r=c.get(e[1]);if(!P.Object(r))throw j.Error("syntax-error",`Pattern variable "${e[1]}" must be variadic. (add "${a}" after the symbol)" `);return r}return e};return m(u)}),!1,!0),qr=q("syntax-error",[{name:"message"},{name:"args",type:"variadic"}],(({message:e,args:r})=>{throw I.String(e),I.Objects(r),j.Error("syntax-error",e[1],r)})),Tr={quote:ar,lambda:or,If:ir,setD:lr,include:sr,includeCli:cr,cond:ur,Case:mr,and:dr,or:pr,when:fr,unless:br,condExpand:yr,Let:hr,LetStar:gr,letrecStar:Sr,letrec:vr,letValues:wr,letStarValues:jr,begin:xr,Do:Pr,makeParameter:Er,parameterize:Nr,defineParameter:Ir,defineParameter1:Br,guard:Or,quasiquote:Cr,quasiquote1:Ar,letSyntax:$r,letrecSyntax:Lr,syntaxRules:Vr,applySyntaxRules:_r,syntaxError:qr},Dr=q("pair?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.Pair(e))))),Rr=q("cons",[{name:"obj1"},{name:"obj2"}],(({obj1:e,obj2:r})=>(I.Object(e),I.Object(r),j.Pair(e,r)))),Qr=q("car",[{name:"pair"}],(({pair:e})=>(I.Pair(e),e[1]))),Ur=q("cdr",[{name:"pair"}],(({pair:e})=>(I.Pair(e),e[2]))),Fr=q("set-car!",[{name:"pair"},{name:"obj"}],(({pair:e,obj:r})=>{if(I.Pair(e),I.Object(r),e[3])throw j.Error("immutable-object","Specified list is immutable");return e[1]=r,e})),Jr=q("set-cdr!",[{name:"pair"},{name:"obj"}],(({pair:e,obj:r})=>{if(I.Pair(e),I.Object(r),e[3])throw j.Error("immutable-object","Specified list is immutable");return e[2]=r,e})),Xr=q("caar",[{name:"pair"}],(({pair:e})=>(I.Pair(e),I.Pair(e[1]),e[1][1]))),Zr=q("cadr",[{name:"pair"}],(({pair:e})=>(I.Pair(e),I.Pair(e[2]),e[2][1]))),Kr=q("cdar",[{name:"pair"}],(({pair:e})=>(I.Pair(e),I.Pair(e[1]),e[1][2]))),Wr=q("cddr",[{name:"pair"}],(({pair:e})=>(I.Pair(e),I.Pair(e[2]),e[2][2]))),Gr=q("null?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.Null(e))))),Hr=q("list?",[{name:"obj"}],(({obj:e})=>{if(I.Object(e),!P.List(e))return j.Boolean(!1);if(P.Null(e))return j.Boolean(!0);try{const[,r]=z(e);return j.Boolean(P.Null(r))}catch(r){return j.Boolean(!1)}})),Yr=q("make-list",[{name:"k"},{name:"fill",type:"optional"}],(({k:e,fill:r})=>(I.IntegerNumber(e),r?(I.Object(r),j.List(...Array.from({length:e[1]},(()=>r)))):j.List(...Array.from({length:e[1]},(()=>["<undefined>"])))))),et=q("list",[{name:"objs",type:"variadic"}],(({objs:e})=>(I.Objects(e),j.List(...e)))),rt=q("length",[{name:"list"}],(({list:e})=>(I.List(e),j.Number(V(e).length)))),tt=q("append",[{name:"args",type:"variadic"}],(({args:e})=>{if(I.Objects(e),0===e.length)return["<null>"];if(1===e.length)return e[0];{const[r,t]=[e.slice(0,e.length-1),e[e.length-1]];return I.Lists(r),M(r.map((e=>V(e))).flat(),t)}})),nt=q("reverse",[{name:"list"}],(({list:e})=>(I.List(e),j.List(...V(e).reverse())))),at=q("list-tail",[{name:"list"},{name:"k"}],(({list:e,k:r})=>{if(I.Object(e),I.IntegerNumber(r),0===r[1])return e;I.List(e);for(let t=e,n=0;P.Pair(t);t=t[2],n++)if(n===r[1])return t;throw j.Error("out-of-range",`Specified list is shorter than specified number ${r[1]}`)})),ot=q("list-ref",[{name:"list"},{name:"k"}],(({list:e,k:r})=>{I.Pair(e),I.IntegerNumber(r);for(let t=e,n=0;P.Pair(t);t=t[2],n++)if(n===r[1])return t[1];throw j.Error("out-of-range",`Specified list is shorter than specified number ${r[1]}`)})),it=q("list-set!",[{name:"list"},{name:"k"},{name:"obj"}],(({list:e,k:r,obj:t})=>{I.Pair(e),I.IntegerNumber(r),I.Object(t);for(let n=e,a=0;P.Pair(n);n=n[2],a++)if(a===r[1]){if(n[3])throw j.Error("immutable-object","Specified list is immutable");return n[1]=t,["<undefined>"]}throw j.Error("out-of-range",`Specified list is shorter than specified number ${r[1]}`)})),lt=q("memq",[{name:"obj"},{name:"list"}],(({obj:e,list:r})=>{I.Object(e),I.List(r);const t=V(r).findIndex((r=>Te.body({obj1:e,obj2:r})[1]));return t<0?j.Boolean(!1):at.body({list:r,k:j.Number(t)})})),st=q("memv",[{name:"obj"},{name:"list"}],(({obj:e,list:r})=>{I.Object(e),I.List(r);const t=V(r).findIndex((r=>qe.body({obj1:e,obj2:r})[1]));return t<0?j.Boolean(!1):at.body({list:r,k:j.Number(t)})})),ct=q("member",[{name:"obj"},{name:"list"},{name:"compare",type:"optional"}],(({obj:e,list:r,compare:t})=>{if(I.Object(e),I.List(r),P.Null(r))return j.Boolean(!1);if(t){I.Procedure(t);const[,n,a]=r;return x.If(x.Call(t,j.MultiValue([n,e])),x.Quote(r),x.CallBuiltIn("member",j.MultiValue([e,a,t])))}{const t=V(r).findIndex((r=>De.body({obj1:e,obj2:r})[1]));return t<0?j.Boolean(!1):x.Quote(at.body({list:r,k:j.Number(t)}))}}),!0),ut=q("assq",[{name:"obj"},{name:"alist"}],(({obj:e,alist:r})=>{I.Object(e),I.List(r);const t=V(r).find((r=>(I.Pair(r),Te.body({obj1:e,obj2:r[1]})[1])));return null!=t?t:j.Boolean(!1)})),mt=q("assv",[{name:"obj"},{name:"alist"}],(({obj:e,alist:r})=>{I.Object(e),I.List(r);const t=V(r).find((r=>(I.Pair(r),qe.body({obj1:e,obj2:r[1]})[1])));return null!=t?t:j.Boolean(!1)})),dt=q("assoc",[{name:"obj"},{name:"alist"},{name:"compare",type:"optional"}],(({obj:e,alist:r,compare:t})=>{if(I.Object(e),I.List(r),P.Null(r))return j.Boolean(!1);if(t){I.Procedure(t);const[,n,a]=r;return I.Pair(n),x.If(x.Call(t,j.MultiValue([n[1],e])),x.Quote(n),x.CallBuiltIn("assoc",j.MultiValue([e,a,t])))}{const t=V(r).find((r=>(I.Pair(r),De.body({obj1:e,obj2:r[1]})[1])));return t?x.Quote(t):j.Boolean(!1)}}),!0),pt=q("list-copy",[{name:"obj"}],(({obj:e})=>{if(I.Object(e),P.List(e)){if(P.Null(e))return["<null>"];{const[r,t]=z(e);return M(r,t)}}return e})),ft={pairQ:Dr,cons:Rr,car:Qr,cdr:Ur,setCarD:Fr,setCdrD:Jr,caar:Xr,cadr:Zr,cdar:Kr,cddr:Wr,nullQ:Gr,listQ:Hr,makeList:Yr,list:et,length:rt,append:tt,reverse:nt,listTail:at,listRef:ot,listSetD:it,memq:lt,memv:st,member:ct,assq:ut,assv:mt,assoc:dt,listCopy:pt},bt=q("number?",[{name:"obj"}],(({obj:e})=>j.Boolean(P.Number(e)))),yt=q("real?",[{name:"obj"}],(({obj:e})=>j.Boolean(P.Number(e)))),ht=q("integer?",[{name:"obj"}],(({obj:e})=>j.Boolean(P.Number(e)&&Number.isInteger(m(e))))),gt=q("exact?",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e);return j.Boolean(Number.isSafeInteger(r))})),vt=q("inexact?",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e);return j.Boolean(!Number.isSafeInteger(r))})),St=T("exact-integer?",gt),wt=q("=",[{name:"z1"},{name:"z2"},{name:"zs",type:"variadic"}],(({z1:e,z2:r,zs:t})=>{I.Number(e),I.Number(r),I.Numbers(t);const n=[e,r,...t].map(m);return j.Boolean(n.slice(1).every((e=>n[0]===e)))})),jt=q("<",[{name:"z1"},{name:"z2"},{name:"zs",type:"variadic"}],(({z1:e,z2:r,zs:t})=>{I.Number(e),I.Number(r),I.Numbers(t);const n=[e,r,...t].map(m);return j.Boolean(n.every(((e,r)=>0===r||n[r-1]<e)))})),xt=q(">",[{name:"z1"},{name:"z2"},{name:"zs",type:"variadic"}],(({z1:e,z2:r,zs:t})=>{I.Number(e),I.Number(r),I.Numbers(t);const n=[e,r,...t].map(m);return j.Boolean(n.every(((e,r)=>0===r||n[r-1]>e)))})),Pt=q("<=",[{name:"z1"},{name:"z2"},{name:"zs",type:"variadic"}],(({z1:e,z2:r,zs:t})=>{I.Number(e),I.Number(r),I.Numbers(t);const n=[e,r,...t].map(m);return j.Boolean(n.every(((e,r)=>0===r||n[r-1]<=e)))})),Et=q(">=",[{name:"z1"},{name:"z2"},{name:"zs",type:"variadic"}],(({z1:e,z2:r,zs:t})=>{I.Number(e),I.Number(r),I.Numbers(t);const n=[e,r,...t].map(m);return j.Boolean(n.every(((e,r)=>0===r||n[r-1]>=e)))})),Nt=q("nan?",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e);return j.Boolean(Number.isNaN(r))})),It=q("zero?",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e);return j.Boolean(0===r)})),Bt=q("positive?",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e);return j.Boolean(r>0)})),Ot=q("negative?",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e);return j.Boolean(r<0)})),Ct=q("odd?",[{name:"n"}],(({n:e})=>{I.Number(e);const r=m(e);return j.Boolean(Number.isInteger(r)&&1===Math.abs(r%2))})),At=q("even?",[{name:"n"}],(({n:e})=>{I.Number(e);const r=m(e);return j.Boolean(Number.isInteger(r)&&0===Math.abs(r%2))})),$t=q("max",[{name:"xs",type:"variadic"}],(({xs:e})=>(I.Numbers(e),d(Math.max(...e.map(m)))))),Lt=q("min",[{name:"xs",type:"variadic"}],(({xs:e})=>(I.Numbers(e),d(Math.min(...e.map(m)))))),kt=q("+",[{name:"zs",type:"variadic"}],(({zs:e})=>(I.Numbers(e),d(e.map(m).reduce(((e,r)=>e+r),0))))),Vt=q("-",[{name:"z1"},{name:"zs",type:"variadic"}],(({z1:e,zs:r})=>{I.Number(e),I.Numbers(r);const t=m(e),n=r.map(m);return d(0===n.length?-t:n.reduce(((e,r)=>e-r),t))})),zt=q("*",[{name:"zs",type:"variadic"}],(({zs:e})=>(I.Numbers(e),d(e.map(m).reduce(((e,r)=>e*r),1))))),Mt=q("/",[{name:"z1"},{name:"zs",type:"variadic"}],(({z1:e,zs:r})=>{I.Number(e),I.Numbers(r);const t=m(e),n=r.map(m);return n.includes(0)?j.Error("division-by-zero",null):d(0===n.length?1/t:n.reduce(((e,r)=>e/r),t))})),_t=q("abs",[{name:"x"}],(({x:e})=>{I.Number(e);const r=m(e);return d(Math.abs(r))})),qt=q("floor/",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{I.Number(e),I.Number(r);const t=m(e),n=m(r),a=(t%n+n)%n,o=(t-a)/n;return j.MultiValue([d(o),d(a)])})),Tt=q("floor-quotient",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{I.Number(e),I.Number(r);const t=m(e),n=m(r);return d((t-(t%n+n)%n)/n)})),Dt=q("floor-remainder",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{I.Number(e),I.Number(r);const t=m(e),n=m(r);return d((t%n+n)%n)})),Rt=q("truncate/",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{I.Number(e),I.Number(r);const t=m(e),n=m(r),a=t%n,o=(t-a)/n;return j.MultiValue([d(o),d(a)])})),Qt=q("truncate-quotient",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{I.Number(e),I.Number(r);const t=m(e),n=m(r);return d((t-t%n)/n)})),Ut=q("truncate-remainder",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{I.Number(e),I.Number(r);const t=m(e),n=m(r);return d(t%n)})),Ft=T("quotient",Qt),Jt=T("remainder",Ut),Xt=T("modulo",Dt),Zt=q("gcd",[{name:"ns",type:"variadic"}],(({ns:e})=>{if(I.Numbers(e),0===e.length)return d(0);const r=(e,t)=>0!==t?r(t,e%t):e;return d(Math.abs(e.map(m).reduce(r)))})),Kt=q("lcm",[{name:"ns",type:"variadic"}],(({ns:e})=>{if(I.Numbers(e),0===e.length)return d(1);const r=(e,t)=>0!==t?r(t,e%t):e;return d(Math.abs(e.map(m).reduce(((e,t)=>e*t/r(e,t)))))})),Wt=q("floor",[{name:"x"}],(({x:e})=>{I.Number(e);const r=m(e);return d(Math.floor(r))})),Gt=q("ceiling",[{name:"x"}],(({x:e})=>{I.Number(e);const r=m(e);return d(Math.ceil(r))})),Ht=q("truncate",[{name:"x"}],(({x:e})=>{I.Number(e);const r=m(e);return d(Math.trunc(r))})),Yt=q("round",[{name:"x"}],(({x:e})=>{I.Number(e);const r=m(e);return d(Math.round(r))})),en=q("rationalize",[{name:"x"},{name:"y"}],(()=>{throw j.Error("not-supported",'"Fraction numbers are not supported.')})),rn=q("square",[{name:"x"}],(({x:e})=>{I.Number(e);const r=m(e);return d(r**2)})),tn=q("exact-integer-sqrt",[{name:"k"}],(({k:e})=>{I.IntegerNumber(e);const r=m(e);if(!Number.isSafeInteger(r)||r<0)throw j.Error("out-of-range","exact-integer-sqrt can calculate exact & non-negative value.");const t=Math.floor(Math.sqrt(r)),n=r-t**2;return j.MultiValue([d(t),d(n)])})),nn=q("expt",[{name:"z1"},{name:"z2"}],(({z1:e,z2:r})=>{I.Number(e),I.Number(r);const t=m(e),n=m(r);return d(t**n)})),an=q("inexact",[{name:"z"}],(({z:e})=>(I.Number(e),e))),on=q("exact",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e),t=Number(r.toFixed());if(!Number.isSafeInteger(t))throw j.Error("out-of-range",`"exact" can't calculate exact number for ${e[1]}.`);return e})),ln=q("number->string",[{name:"z"},{name:"radix",type:"optional"}],(({z:e,radix:r})=>{I.Number(e);const t=m(e);if(isNaN(t))return j.String("+nan.0",!1);if(isFinite(t)){r&&I.IntegerNumber(r);const e=r?m(r):10;if(![2,8,10,16].includes(e))throw j.Error("out-of-range","radix must be one of 2, 8, 10, 16.");return j.String(t.toString(e),!1)}return j.String((t>0?"+":"-")+"inf.0",!1)})),sn=q("string->number",[{name:"str"},{name:"radix",type:"optional"}],(({str:e,radix:r})=>{I.String(e);let t,n=e[1];if(r){if(I.IntegerNumber(r),![2,8,10,16].includes(m(r)))throw j.Error("out-of-range","radix must be one of 2, 8, 10, 16.");const e=`#${{2:"b",8:"o",10:"d",16:"x"}[m(r)]}`;n=n.replace(/^(#[dDbBoOxX])?/,e)}try{t=H(n)}catch(a){return j.Boolean(!1)}return P.Number(t)?t:j.Boolean(!1)})),cn={numberQ:bt,realQ:yt,integerQ:ht,exactQ:gt,inexactQ:vt,exactIntegerQ:St,eq:wt,lt:jt,gt:xt,le:Pt,ge:Et,nanQ:Nt,zeroQ:It,positiveQ:Bt,negativeQ:Ot,oddQ:Ct,evenQ:At,max:$t,min:Lt,add:kt,sub:Vt,mul:zt,div:Mt,abs:_t,floorS:qt,floorQuotient:Tt,floorRemainder:Dt,truncateS:Rt,truncateQuotient:Qt,truncateRemainder:Ut,quotient:Ft,remainder:Jt,modulo:Xt,gcd:Zt,lcm:Kt,floor:Wt,ceiling:Gt,truncate:Ht,rationalize:en,round:Yt,square:rn,exactIntegerSqrt:tn,expt:nn,inexact:an,exact:on,numberToString:ln,stringToNumber:sn},un='"fs" is not set. To use filesystems, import/require "fs" and set it on Interpreter\'s constructor parameter.',mn=q("call-with-port",[{name:"port"},{name:"proc"}],(({port:e,proc:r})=>(I.Port(e),I.Procedure(r),x.Begin(x.Call(r,e),x.CallBuiltIn("close-port",e))))),dn=q("input-port?",[{name:"obj"}],(({obj:e})=>{var r;return I.Object(e),j.Boolean(!(!P.Port(e)||!(null==(r=e[3])?void 0:r.includes("r"))))})),pn=q("output-port?",[{name:"obj"}],(({obj:e})=>{var r;return I.Object(e),j.Boolean(!(!P.Port(e)||!(null==(r=e[3])?void 0:r.includes("w"))))})),fn=q("textual-port?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.Port(e)&&"string"==typeof e[5])))),bn=q("binary-port?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.Port(e)&&"string"!=typeof e[5])))),yn=q("port?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.Port(e))))),hn=q("input-port-open?",[{name:"port"}],(({port:e})=>{var r;return I.Port(e),j.Boolean(!!(null==(r=e[3])?void 0:r.includes("r")))})),gn=q("output-port-open?",[{name:"port"}],(({port:e})=>{var r;return I.Port(e),j.Boolean(!!(null==(r=e[3])?void 0:r.includes("w")))})),vn=q("close-port",[{name:"port"}],(({port:e},r)=>{var t;if(I.Port(e),!e[3])return["<undefined>"];if("built-in"===e[1]){if(!r)throw j.Error("program-error","No interpreter object.");const n=r.getBuiltInPort(e[2]);if(!n)throw j.Error("program-error","Illegal built-in file object.");null==(t=n.close)||t.call(n)}else if("string"!==e[1]){if("file"===e[1]){if(!(null==r?void 0:r.fs))throw j.Error("program-error",'No interpreter object or No Node.js "fs" object set on Interpreter.');return r.fs.closeSync(e[2]),j.Boolean(!0)}throw j.Error("program-error",`Unknown port type "${e[1]}"`)}return e[3]=null,["<undefined>"]})),Sn=q("close-input-port",[{name:"port"}],(({port:e})=>{var r;if(I.Port(e),!(null==(r=e[3])?void 0:r.includes("r")))return["<undefined>"];if("built-in"===e[1])throw j.Error("program-error","Can't close only output port for built-in port.");if("string"===e[1]);else if("bytevector"!==e[1])throw"file"===e[1]?j.Error("program-error","Can't close only input port for file port."):j.Error("program-error",`Unknown port type "${e[1]}"`);return e[3]=e[3].replace("r","")||null,["<undefined>"]})),wn=q("close-output-port",[{name:"port"}],(({port:e})=>{var r;if(I.Port(e),!(null==(r=e[3])?void 0:r.includes("w")))return["<undefined>"];if("built-in"===e[1])throw j.Error("program-error","Can't close only output port for built-in port.");if("string"===e[1]);else if("bytevector"!==e[1])throw"file"===e[1]?j.Error("program-error","Can't close only output port for file port."):j.Error("program-error",`Unknown port type "${e[1]}"`);return e[3]=e[3].replace("w","")||null,["<undefined>"]})),jn=q("open-input-string",[{name:"str"}],(({str:e})=>(I.String(e),j.Port("string",e[1],"r",null,"")))),xn=q("open-output-string",[],(()=>j.Port("string","","w",null,""))),Pn=q("get-output-string",[{name:"port"}],(({port:e})=>{var r;if(I.Port(e),"string"!==e[1]||!(null==(r=e[3])?void 0:r.includes("w")))throw j.Error("read-error","Not a port created by open-output-string.");return j.String(e[2],!1)})),En=q("open-input-bytevector",[{name:"bvec"}],(({bvec:e})=>(I.ByteVector(e),j.Port("bytevector",[...e[1]],"r",null,[])))),Nn=q("open-output-bytevector",[],(()=>j.Port("bytevector",[],"w",null,[]))),In=q("get-output-bytevector",[{name:"port"}],(({port:e})=>{var r;if(I.Port(e),"bytevector"!==e[1]||!(null==(r=e[3])?void 0:r.includes("w")))throw j.Error("read-error","Not a port created by open-output-string.");return j.ByteVector([...e[2]],!1)})),Bn=q("read-char",[{name:"port",type:"optional"}],(({port:e},r,t)=>{var n,a;if(B(r),B(t),e||(e=r.getDynamic(h(t).env.dynamic,"current-input-port")),I.Port(e),!(null==(n=e[3])?void 0:n.includes("r")))throw j.Error("read-error","Port is not open.");if("string"!=typeof e[5])throw j.Error("read-error","Not a text port.");let o;if(e[5].length>0)/^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e[5])?(o=e[5].slice(0,2),e[5]=e[5].slice(2)):(o=e[5].slice(0,1),e[5]=e[5].slice(1));else if("built-in"===e[1]){const t=null==r?void 0:r.getBuiltInPort(e[2]);o=null==(a=null==t?void 0:t.read)?void 0:a.call(t,"character",null)}else if("string"===e[1])0===e[2].length?o=null:/^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e[2])?(o=e[2].slice(0,2),e[2]=e[2].slice(2)):(o=e[2].slice(0,1),e[2]=e[2].slice(1));else{if("file"!==e[1])throw j.Error("program-error","Illegal type of port.");{if(!(null==r?void 0:r.fs))throw j.Error("read-error",un);const t=Buffer.alloc(4);for(let n=0;;n++){if(!r.fs.readSync(e[2],t,{length:1,offset:n})){o=null;break}const a=t.toString("utf8",0,n+1);if(!a.includes("ï¿½")){o=a;break}if(n>=4)throw j.Error("read-error","Not a valid text(UTF-8) file.")}}}if(null===o)return j.EndOfFile();if(void 0===o)throw j.Error("read-error",null);if("string"!=typeof o)throw j.Error("read-error","Read-data is not a expected format (number).");return j.Character(o)})),On=q("peek-char",[{name:"port",type:"optional"}],(({port:e},r,t)=>{B(r),B(t),e||(e=r.getDynamic(h(t).env.dynamic,"current-input-port")),I.Port(e);const n=Bn.body({port:e},r,t);return P.EndOfFile(n)||(e[5]="string"==typeof e[5]?n[1]+e[5]:n[1]),n})),Cn=q("read-line",[{name:"port",type:"optional"}],(({port:e},r,t)=>{B(r),B(t),e||(e=r.getDynamic(h(t).env.dynamic,"current-input-port")),I.Port(e);let n="";for(;;){const a=Bn.body({port:e},r,t);if(P.EndOfFile(a))return""===n?a:j.String(n,!1);if("\r"===a[1]){const a=Bn.body({port:e},r,t);return P.EndOfFile(a)||"\n"===a[1]||(e[5]="string"==typeof e[5]?a[1]+e[5]:a[1]),j.String(n,!1)}if("\n"===a[1])return j.String(n,!1);n+=a[1]}})),An=q("eof-object?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.EndOfFile(e))))),$n=q("eof-object",[],(()=>j.EndOfFile())),Ln=q("char-ready?",[{name:"port",type:"optional"}],(({port:e},r,t)=>{var n,a;if(B(r),B(t),e||(e=r.getDynamic(h(t).env.dynamic,"current-input-port")),I.Port(e),!(null==(n=e[3])?void 0:n.includes("r")))return j.Boolean(!1);if("built-in"===e[1]){if(!r)throw j.Error("program-error","No interpreter object.");const t=r.getBuiltInPort(e[2]);if(!t)throw j.Error("program-error","Illegal built-in file object.");return j.Boolean(!!(null==(a=t.ready)?void 0:a.call(t)))}if("string"===e[1])return j.Boolean(!0);if("bytevector"===e[1])return j.Boolean(!1);throw"file"===e[1]?j.Error("program-error",'"Node.js file "ready" method is not implemented."'):j.Error("program-error",`Unknown port type "${e[1]}"`)})),kn=q("read-string",[{name:"k"},{name:"port",type:"optional"}],(({k:e,port:r},t,n)=>{I.IntegerNumber(e),B(t),B(n),r||(r=t.getDynamic(h(n).env.dynamic,"current-input-port")),I.Port(r);let a="";for(;;){const o=Bn.body({port:r},t,n);if(P.EndOfFile(o))return 0===a.length?o:j.String(a,!1);if(a+=o[1],a.length>=e[1])return j.String(a,!1)}})),Vn=q("read-u8",[{name:"port",type:"optional"}],(({port:e},r,t)=>{var n,a;if(B(r),B(t),e||(e=r.getDynamic(h(t).env.dynamic,"current-input-port")),I.Port(e),!(null==(n=e[3])?void 0:n.includes("r")))throw j.Error("read-error","Port is not open.");if("string"==typeof e[5])throw j.Error("read-error","Not a binary port.");let o;if(e[5].length>0)o=e[5][0],e[5]=e[5].slice(1);else if("built-in"===e[1]){const t=null==r?void 0:r.getBuiltInPort(e[2]);o=null==(a=null==t?void 0:t.read)?void 0:a.call(t,"byte",null)}else if("bytevector"===e[1])e[2].length>0?(o=e[2][0],e[2]=e[2].slice(1)):o=null;else{if("file"!==e[1])throw j.Error("program-error","Illegal type of port.");{if(!(null==r?void 0:r.fs))throw j.Error("read-error",un);const t=Buffer.alloc(1);o=r.fs.readSync(e[2],t)?t[0]:null}}if(null===o)return j.EndOfFile();if(void 0===o)throw j.Error("read-error",null);if("number"!=typeof o)throw j.Error("read-error","Read-data is not a expected format (string).");return j.Number(o)})),zn=q("peek-u8",[{name:"port",type:"optional"}],(({port:e},r,t)=>{B(r),B(t),e||(e=r.getDynamic(h(t).env.dynamic,"current-input-port")),I.Port(e);const n=Vn.body({port:e},r,t);return P.EndOfFile(n)||(e[5]="string"!=typeof e[5]?[n[1],...e[5]]:[n[1]]),n})),Mn=q("u8-ready?",[{name:"port",type:"optional"}],(({port:e},r,t)=>{var n,a;if(B(r),B(t),e||(e=r.getDynamic(h(t).env.dynamic,"current-input-port")),I.Port(e),!(null==(n=e[3])?void 0:n.includes("r")))return j.Boolean(!1);if("built-in"===e[1]){if(!r)throw j.Error("program-error","No interpreter object.");const t=r.getBuiltInPort(e[2]);if(!t)throw j.Error("program-error","Illegal built-in file object.");return j.Boolean(!!(null==(a=t.ready)?void 0:a.call(t)))}if("string"===e[1])return j.Boolean(!1);if("bytevector"===e[1])return j.Boolean(!0);if("file"===e[1]){if(!(null==r?void 0:r.fs))throw j.Error("read-error",un);throw j.Error("program-error",'"Node.js file "ready" method is not implemented."')}throw j.Error("program-error",`Unknown port type "${e[1]}"`)})),_n=q("read-bytevector",[{name:"k"},{name:"port",type:"optional"}],(({k:e,port:r},t,n)=>{I.IntegerNumber(e),B(t),B(n),r||(r=t.getDynamic(h(n).env.dynamic,"current-input-port")),I.Port(r);const a=[];for(;;){const o=Vn.body({port:r},t,n);if(P.EndOfFile(o))return 0===a.length?o:j.ByteVector(a,!1);if(a.push(o[1]),a.length>=e[1])return j.ByteVector(a,!1)}})),qn=q("read-bytevector!",[{name:"bvec"},{name:"port",type:"optional"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({bvec:e,port:r,start:t,end:n},a,o)=>{I.ByteVector(e),B(a),B(o);const i=P.Number(t)?t[1]:0,l=P.Number(n)?n[1]:e[1].length;if("number"!=typeof i||!Number.isInteger(i)||"number"!=typeof l||!Number.isInteger(l))throw j.Error("domain-error","Index must be integer.");const s=l-i,c=_n.body({k:j.Number(s),port:r},a,o);if(P.EndOfFile(c))return c;for(let u=0;u<c[1].length;u++)e[1][i+u]=c[1][u];return j.Number(c[1].length)})),Tn=q("newline",[{name:"port",type:"optional"}],(({port:e},r,t)=>Rn.body({str:j.String("\n",!1),port:e,start:null,end:null},r,t))),Dn=q("write-char",[{name:"char"},{name:"port",type:"optional"}],(({char:e,port:r},t,n)=>(I.Character(e),Rn.body({str:j.String(e[1],!1),port:r,start:null,end:null},t,n)))),Rn=q("write-string",[{name:"str"},{name:"port",type:"optional"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,port:r,start:t,end:n},a,o)=>{var i;I.String(e),B(a),B(o);const l=P.Number(t)?t[1]:0,s=P.Number(n)?n[1]:e[1].length;if("number"!=typeof l||!Number.isInteger(l)||"number"!=typeof s||!Number.isInteger(s))throw j.Error("domain-error","Index must be integer.");const c=Array.from(e[1]).slice(l,s).join("");if(r||(r=a.getDynamic(h(o).env.dynamic,"current-output-port")),I.Port(r),!(null==(i=r[3])?void 0:i.includes("w")))throw j.Error("write-error","Port is not open for writing.");if("string"!=typeof r[5])throw j.Error("write-error","Not a text port.");if("built-in"===r[1]){if(!a)throw j.Error("program-error","No interpreter object.");const e=a.getBuiltInPort(r[2]);if(!e||!e.write)throw j.Error("program-error","No built-in method defined to write.");e.write(c)}else if("string"===r[1])r[2]=r[2]+c;else{if("file"!==r[1])throw j.Error("program-error","Illegal type of port for writing.");if(!(null==a?void 0:a.fs))throw j.Error("write-error",un);a.fs.writeSync(r[2],c)}return["<undefined>"]})),Qn=q("write-u8",[{name:"byte"},{name:"port",type:"optional"}],(({byte:e,port:r},t,n)=>(I.IntegerNumber(e),Un.body({bvec:j.ByteVector([e[1]],!1),port:r},t,n)))),Un=q("write-bytevector",[{name:"bvec"},{name:"port",type:"optional"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({bvec:e,port:r,start:t,end:n},a,o)=>{var i;I.ByteVector(e),B(a),B(o);const l=P.Number(t)?t[1]:0,s=P.Number(n)?n[1]:e[1].length;if("number"!=typeof l||!Number.isInteger(l)||"number"!=typeof s||!Number.isInteger(s))throw j.Error("domain-error","Index must be integer.");const c=e[1].slice(l,s);if(r||(r=a.getDynamic(h(o).env.dynamic,"current-output-port")),I.Port(r),!(null==(i=r[3])?void 0:i.includes("w")))throw j.Error("write-error","Port is not open for writing.");if("string"==typeof r[5])throw j.Error("write-error","Not a binary port.");if("built-in"===r[1]){if(!a)throw j.Error("program-error","No interpreter object.");const e=a.getBuiltInPort(r[2]);if(!e||!e.write)throw j.Error("program-error","No built-in method defined to write.");e.write(new Uint8Array(c))}else if("bytevector"===r[1])r[2].push(...c);else{if("file"!==r[1])throw j.Error("program-error","Illegal type of port for writing.");if(!(null==a?void 0:a.fs))throw j.Error("write-error",un);a.fs.writeSync(r[2],new Uint8Array(c))}return["<undefined>"]})),Fn=q("flush-output-port",[{name:"port",type:"optional"}],(({port:e},r,t)=>{var n,a;if(B(r),B(t),e||(e=r.getDynamic(h(t).env.dynamic,"current-output-port")),I.Port(e),!(null==(n=e[3])?void 0:n.includes("w")))throw j.Error("write-error","Port is not open for writing.");if("built-in"===e[1]){if(!r)throw j.Error("program-error","No interpreter object.");const t=r.getBuiltInPort(e[2]);if(!t)throw j.Error("program-error","No built-in method defined to write.");null==(a=t.flush)||a.call(t)}else if("file"===e[1]){if(!(null==r?void 0:r.fs))throw j.Error("write-error",un);r.fs.fsyncSync(e[2])}return["<undefined>"]})),Jn={callWithPort:mn,inputPortQ:dn,outputPortQ:pn,textualPortQ:fn,binaryPortQ:bn,portQ:yn,inputPortOpenQ:hn,outputPortOpenQ:gn,closePort:vn,closeInputPort:Sn,closeOutputPort:wn,openInputString:jn,openOutputString:xn,getOutputString:Pn,openInputBytevector:En,openOutputBytevector:Nn,getOutputBytevector:In,readChar:Bn,peekChar:On,readLine:Cn,eofObjectQ:An,eofObject:$n,charReadyQ:Ln,readString:kn,readU8:Vn,peekU8:zn,u8ReadyQ:Mn,readBytevector:_n,readBytevectorD:qn,newline:Tn,writeChar:Dn,writeString:Rn,writeU8:Qn,writeBytevector:Un,flushOutputPort:Fn},Xn={stringQ:q("string?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.String(e))))),makeString:q("make-string",[{name:"k"},{name:"char",type:"optional"}],(({k:e,char:r})=>(I.IntegerNumber(e),r&&I.Character(r),j.String((r?r[1]:" ").repeat(e[1]),!1)))),string:q("string",[{name:"chars",type:"variadic"}],(({chars:e})=>(I.Characters(e),j.String(e.map((e=>e[1])).join(""),!1)))),stringLength:q("string-length",[{name:"str"}],(({str:e})=>(I.String(e),j.Number(Array.from(e[1]).length)))),stringRef:q("string-ref",[{name:"str"},{name:"k"}],(({str:e,k:r})=>{I.String(e),I.IntegerNumber(r);const t=Array.from(e[1])[r[1]];if(!t)throw j.Error("out-of-range",`The specified string doesn't have character with index ${r[1]}.`);return j.Character(t)})),stringSetD:q("string-set!",[{name:"str"},{name:"k"},{name:"char"}],(({str:e,k:r,char:t})=>{I.String(e),I.IntegerNumber(r),I.Character(t);const n=Array.from(e[1]),a=n.slice(0,r[1]),o=n.slice(r[1]+1);return e[1]=[...a,t[1],...o].join(""),["<undefined>"]})),stringEQ:q("string=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>(I.String(e),I.String(r),I.Strings(t),j.Boolean([r,...t].every((r=>r[1]===e[1])))))),stringLtQ:q("string<?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{I.String(e),I.String(r),I.Strings(t);const n=[e,r,...t].map((e=>e[1]));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]<e)))})),stringGtQ:q("string>?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{I.String(e),I.String(r),I.Strings(t);const n=[e,r,...t].map((e=>e[1]));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]>e)))})),stringLeQ:q("string<=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{I.String(e),I.String(r),I.Strings(t);const n=[e,r,...t].map((e=>e[1]));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]<=e)))})),stringGeQ:q("string>=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{I.String(e),I.String(r),I.Strings(t);const n=[e,r,...t].map((e=>e[1]));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]>=e)))})),substring:q("substring",[{name:"str"},{name:"start"},{name:"end"}],(({str:e,start:r,end:t})=>(I.String(e),I.IntegerNumber(r),I.IntegerNumber(t),j.String(Array.from(e[1]).slice(r[1],t[1]).join(""),!1)))),stringAppend:q("string-append",[{name:"strs",type:"variadic"}],(({strs:e})=>(I.Strings(e),j.String(e.map((e=>e[1])).join(""),!1)))),stringToList:q("string->list",[{name:"str"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,start:r,end:t})=>{I.String(e);const n=Array.from(e[1]),a=P.Number(r)?r[1]:0,o=P.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw j.Error("domain-error","Index must be integer.");return j.List(...n.slice(a,o).map((e=>j.Character(e))))})),listToString:q("list->string",[{name:"list"}],(({list:e})=>{I.List(e);const r=V(e);return I.Characters(r),j.String(r.map((e=>e[1])).join(""),!1)})),stringCopy:q("string-copy",[{name:"str"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,start:r,end:t})=>{I.String(e);const n=Array.from(e[1]),a=P.Number(r)?r[1]:0,o=P.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw j.Error("domain-error","Index must be integer.");return j.String(n.slice(a,o).join(""),!1)})),stringCopyD:q("string-copy!",[{name:"to"},{name:"at"},{name:"from"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({to:e,at:r,from:t,start:n,end:a})=>{I.String(e),I.IntegerNumber(r),I.String(t);const o=Array.from(t[1]),i=Array.from(e[1]),l=P.Number(n)?n[1]:0,s=P.Number(a)?a[1]:o.length;if("number"!=typeof l||!Number.isInteger(l)||"number"!=typeof s||!Number.isInteger(s))throw j.Error("domain-error","Index must be integer.");if(r[1]<0||r[1]>=o.length)throw j.Error("out-of-range","Index is out of range.");if(o.length-r[1]<s-l)throw j.Error("out-of-range","Index is out of range.");const c=o.slice(l,s),u=i.slice(0,r[1]),m=i.slice(r[1]+c.length);return e[1]=[...u,...c,...m].join(""),["<undefined>"]})),stringFillD:q("string-fill!",[{name:"str"},{name:"fill"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,fill:r,start:t,end:n})=>{I.String(e),I.Character(r);const a=Array.from(e[1]),o=P.Number(t)?t[1]:0,i=P.Number(n)?n[1]:a.length;if("number"!=typeof o||!Number.isInteger(o)||"number"!=typeof i||!Number.isInteger(i))throw j.Error("domain-error","Index must be integer.");const l=a.slice(o,i),s=a.slice(0,o),c=a.slice(i);return e[1]=[...s,...r[1].repeat(l.length),...c].join(""),["<undefined>"]}))},Zn=q("import",[{name:"sets",type:"variadic",evaluate:!1}],(({sets:e},r,t)=>{var n;I.Objects(e),B(r),B(t);const a=!p(h(t).env.static),o=e=>{if(P.Pair(e)&&P.Symbol(e[1])&&(n=e[1][1],["only","except","prefix","rename"].includes(n))){const r=e[1][1],[,t,...n]=V(e);if(!t)throw j.Error("error","Illegal import syntax. No import set after only, except, prefix, or rename.");if("only"===r){I.Symbols(n,"Illegal import syntax (only).");const e={};for(const[r,a]of Object.entries(o(t)))n.some((e=>e[1]===r))&&(e[r]=a);return e}if("except"===r){I.Symbols(n,"Illegal import syntax (except).");const e={};for(const[r,a]of Object.entries(o(t)))n.some((e=>e[1]!==r))&&(e[r]=a);return e}if("prefix"===r){0===n.length&&P.Symbol(n[0])||I.Symbols(n,"Illegal import syntax (prefix).");const e=n[0][1],r={};for(const[n,a]of Object.entries(o(t)))r[e+n]=a;return r}if("rename"===r){const e=o(t);for(const r of n){I.Pair(r,"Illegal import syntax (rename)."),I.Symbol(r[1],"Illegal import syntax (rename)."),I.Pair(r[2],"Illegal import syntax (rename)."),I.Symbol(r[2][1],"Illegal import syntax (rename).");const[,t,[,n]]=r,a=e[t[1]];B(a,`Identifier ${t[1]} is not found in the original set.`),delete e[t[1]],e[n[1]]=a}return e}return{}}{const n=c(e);if("(scheme base)"===n)return{};const a=r.getBuiltInLibrary(n);if(a)return a(r);const o=r.getStatic(h(t).env.static,j.Symbol(n));if(P.Library(o)){const e={},[,t,n]=o;for(const[a,o]of Object.entries(t)){const t=r.getStatic(n.static,j.Symbol(a));if(!t)throw j.Error("error",`Invalid library export "${a[1]}" (exported as "${o[1]}")`);e[o]=t}return e}throw j.Error("error",`Library "${n}" not found.`)}var n};for(const i of e){const e=o(i);for(const o of Object.keys(e)){if(!a&&!P.Undefined(null!=(n=f(h(t).env.static)[o])?n:["<undefined>"]))throw j.Error("redefine-variable",null);r.defineStatic(h(t).env.static,j.Symbol(o),e[o])}}return["<undefined>"]})),Kn=q("define",[{name:"arg1",evaluate:!1},{name:"arg2",type:"variadic",evaluate:!1}],(({arg1:e,arg2:r},t,n)=>{var a,o;I.Object(e),I.Objects(r),B(t),B(n);const i=!p(h(n).env.static);if(P.Symbol(e)){const o=e,[l]=r;if(!i&&!P.Undefined(null!=(a=f(h(n).env.static)[o[1]])?a:["<undefined>"]))throw j.Error("redefine-variable",null);return t.defineStatic(h(n).env.static,o,["<undefined>"]),x.Set(o,l)}{I.Pair(e);const[[,a,l],s]=[e,r];if(I.Symbol(a),I.List(l),!i&&!P.Undefined(null!=(o=f(h(n).env.static)[a[1]])?o:["<undefined>"]))throw j.Error("redefine-variable",null);const[c,u]=R(l);return t.defineStatic(h(n).env.static,a,j.Procedure("lambda",u?[...c,u]:c,x.BeginIfMultiple(...s),!1,h(n).env)),["<undefined>"]}}),!0),Wn=q("define-values",[{name:"formals",evaluate:!1},{name:"expr"}],(({formals:e,expr:r},t,n)=>{var a;I.Object(e),I.Object(r),B(t),B(n);const o=!p(h(n).env.static),[i,l]=R(e),s=P.MultiValue(r)?r[1]:[r];for(let c=0;c<i.length;c++){if(!s[c])throw j.Error("arity-error",null);if(!o&&!P.Undefined(null!=(a=f(h(n).env.static)[i[c].name])?a:["<undefined>"]))throw j.Error("redefine-variable",null);t.defineStatic(h(n).env.static,j.Symbol(i[c].name),s[c])}return l&&t.defineStatic(h(n).env.static,j.Symbol(l.name),j.List(...s.slice(i.length))),["<undefined>"]})),Gn=q("define-syntax",[{name:"keyword",evaluate:!1},{name:"spec",evaluate:!1}],(({keyword:e,spec:r},t,n)=>{var a;I.Symbol(e),I.Object(r),B(t),B(n);if(!!p(h(n).env.static)&&!P.Undefined(null!=(a=f(h(n).env.static)[e[1]])?a:["<undefined>"]))throw j.Error("redefine-variable",null);return t.defineStatic(h(n).env.static,e,j.Undefined()),x.CallBuiltIn("define-syntax-1",e,r)}),!0),Hn=q("define-syntax-1",[{name:"keyword",evaluate:!1},{name:"spec"}],(({keyword:e,spec:r},t,n)=>{I.Symbol(e),I.SyntaxRules(r),B(t),B(n);const a=j.Procedure("lambda",[{name:"exprs",type:"variadic",evaluate:!1}],x.CallBuiltIn("use-syntax-rules",r,j.Symbol("exprs")),!0,h(n).env);return t.defineStatic(h(n).env.static,e,a),["<undefined>"]}),!1,!0),Yn=q("define-record-type",[{name:"name",evaluate:!1},{name:"ctor",evaluate:!1},{name:"pred",evaluate:!1},{name:"fields",evaluate:!1,type:"variadic"}],(({name:e,ctor:r,pred:t,fields:n},a,o)=>{var i,l,s,c;I.Symbol(e),I.Pair(r),I.Symbol(t),I.Pairs(n),B(a),B(o);const u=!p(h(o).env.static);if(!(u||P.Undefined(null!=(i=f(h(o).env.static)[e[1]])?i:["<undefined>"])&&P.Undefined(null!=(l=f(h(o).env.static)[t[1]])?l:["<undefined>"])))throw j.Error("redefine-variable",null);const m=h(o).env,d=j.RecordType(e[1]),[b,...y]=V(r);I.Symbol(b),I.Symbols(y);{const e=j.Symbol("rec");a.defineStatic(h(o).env.static,b,j.Procedure("lambda",y.map((e=>({name:e[1]}))),x.BeginIfMultiple(x.Define(e,x.CallBuiltIn("make-record",d)),...y.map((r=>x.CallBuiltIn("record-set!",e,r,r))),e),!1,m))}{const e=j.Symbol("rec");a.defineStatic(h(o).env.static,t,j.Procedure("lambda",[{name:e[1]}],x.CallBuiltIn("record-type?",e,d),!1,m))}for(const p of n){const[e,r,t]=V(p);if(I.Symbol(e),I.Symbol(r),!y.some((r=>r[1]===e[1])))throw j.Error("domain-error","Unknown field name");{if(!u&&!P.Undefined(null!=(s=f(h(o).env.static)[r[1]])?s:["<undefined>"]))throw j.Error("redefine-variable",null);const t=j.Symbol("rec");a.defineStatic(h(o).env.static,r,j.Procedure("lambda",[{name:t[1]}],x.CallBuiltIn("record-get",t,e),!1,m))}if(t){if(I.Symbol(t),!u&&!P.Undefined(null!=(c=f(h(o).env.static)[t[1]])?c:["<undefined>"]))throw j.Error("redefine-variable",null);const r=j.Symbol("rec"),n=j.Symbol("value");a.defineStatic(h(o).env.static,t,j.Procedure("lambda",[{name:r[1]},{name:n[1]}],x.CallBuiltIn("record-set!",r,e,n),!1,m))}}return["<undefined>"]})),ea=q("make-record",[{name:"type"}],(({type:e})=>(I.RecordType(e),j.Record(e,{}))),!1,!0),ra=q("record-type?",[{name:"rec"},{name:"type"}],(({rec:e,type:r})=>(I.Object(e),I.RecordType(r),P.Record(e)?qe.body({obj1:e[1],obj2:r}):j.Boolean(!1))),!1,!0),ta=q("record-get",[{name:"rec"},{name:"field",evaluate:!1}],(({rec:e,field:r})=>{var t;I.Record(e),I.Symbol(r);return null!=(t=e[2][r[1]])?t:["<undefined>"]}),!1,!0),na=q("record-set!",[{name:"rec"},{name:"field",evaluate:!1},{name:"value"}],(({rec:e,field:r,value:t})=>{if(I.Record(e),I.Symbol(r),I.Object(t),P.Undefined(t))throw j.Error("undefined-value","Attempt to set an undefined value.");return e[2][r[1]]=t,["<undefined>"]}),!1,!0),aa=q("define-library",[{name:"name",evaluate:!1},{name:"decls",type:"variadic",evaluate:!1}],(({name:e,decls:r},t,n)=>{var a;I.Object(e),I.Pairs(r),B(t),B(n);const o=c(e);if(!!p(h(n).env.static)&&!P.Undefined(null!=(a=f(h(n).env.static)[o])?a:["<undefined>"]))throw j.Error("redefine-variable",null);const i=h(g(j.Undefined())).env,l=j.Library({},i),s=[],u=[],m=e=>{for(const r of e){const[,e,a]=r;if(I.Symbol(e,"Illegal syntax of define-library-syntax"),"export"===e[1]){I.List(a,"Illegal syntax of export.");for(const e of V(a))if(P.Symbol(e))t.defineStatic(i.static,e,j.Undefined()),l[1][e[1]]=e[1];else{if(!P.Pair(e))throw j.Error("error","Illegal syntax of export in define-library");if(!(P.Symbol(e[1])&&"rename"===e[1][1]&&P.Pair(e[2])&&P.Pair(e[2][2])))throw j.Error("error","Illegal syntax of export in define-library");{const[,r,[,n]]=e[2];I.Symbol(r,"Illegal renaming symbol(from) of export in define-library"),I.Symbol(n,"Illegal renaming symbol(to) of export in define-library"),t.defineStatic(i.static,r,j.Undefined()),l[1][r[1]]=n[1]}}}else if("include-library-declarations"===e[1]){I.List(a,"Illegal syntax of include-library-declarations");const e=V(a);I.Strings(e,"Illegal filename of include-library-declarations");for(const r of e)if(!u.includes(r[1])){const e=er.body({filename:r},t);I.Pair(e),I.List(e[2]);const n=V(e[2]);I.Pairs(n,`Illegal declarations in file ${r[1]}`),m(n)}}else if("cond-expand"===e[1]){I.List(a,"Illegal syntax of cond-expand in define-library");const[e,...r]=V(a),o=yr.body({clause1:e,clauses:r},t,n);if(!P.Undefined(o)){const[,...e]=V(o);I.Pairs(e,"Illegal result of cond-expand in define-library"),m(e)}}else{if(!["import","begin","include","include-cli"].includes(e[1]))throw j.Error("error","Illegal declaration in define-library");s.push(r)}}};m(r);const d=S(n,x.Define(j.Symbol(o),l));return v(d,x.Begin(...s,j.MultiValue([])),{env:i})})),oa={Import:Zn,define:Kn,defineValues:Wn,defineSyntax:Gn,defineSyntax1:Hn,defineRecordType:Yn,makeRecord:ea,recordTypeQ:ra,recordGet:ta,recordSetD:na,defineLibrary:aa},ia={symbolQ:q("symbol?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.Symbol(e))))),symbolEQ:q("symbol=?",[{name:"symbol1"},{name:"symbol2"},{name:"symbols",type:"variadic"}],(({symbol1:e,symbol2:r,symbols:t})=>(I.Symbol(e),I.Symbol(r),I.Symbols(t),j.Boolean([r,...t].every((r=>r[1]===e[1])))))),symbolToString:q("symbol->string",[{name:"obj"}],(({obj:e})=>(I.Symbol(e),j.String(e[1],!0)))),stringToSymbol:q("string->symbol",[{name:"obj"}],(({obj:e})=>(I.String(e),j.Symbol(e[1]))))},la={vectorQ:q("vector?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.Vector(e))))),makeVector:q("make-vector",[{name:"k"},{name:"fill",type:"optional"}],(({k:e,fill:r})=>(I.IntegerNumber(e),r&&I.Object(r),j.Vector(Array(e[1]).fill(r||["<undefined>"]),!1)))),vector:q("vector",[{name:"objs",type:"variadic"}],(({objs:e})=>(I.Objects(e),j.Vector(e,!1)))),vectorLength:q("vector-length",[{name:"vec"}],(({vec:e})=>(I.Vector(e),j.Number(e[1].length)))),vectorRef:q("vector-ref",[{name:"vec"},{name:"k"}],(({vec:e,k:r})=>{if(I.Vector(e),I.IntegerNumber(r),!(r[1]in e[1]))throw j.Error("out-of-range","Index is out of range.");return e[1][r[1]]})),vectorSetD:q("vector-set!",[{name:"vec"},{name:"k"},{name:"obj"}],(({vec:e,k:r,obj:t})=>{if(I.Vector(e),I.IntegerNumber(r),I.Object(t),!(r[1]in e[1]))throw j.Error("out-of-range","Index is out of range.");if(P.Undefined(t))throw j.Error("undefined-value","Attempt to set a undefined value to vector.");return e[1][r[1]]=t,["<undefined>"]})),vector2list:q("vector->list",[{name:"vec"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({vec:e,start:r,end:t})=>{I.Vector(e);const n=e[1],a=P.Number(r)?r[1]:0,o=P.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw j.Error("domain-error","Index must be integer.");return j.List(...n.slice(a,o))})),list2vector:q("list->vector",[{name:"list"}],(({list:e})=>(I.List(e),j.Vector(V(e),!1)))),vector2string:q("vector->string",[{name:"vec"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({vec:e,start:r,end:t})=>{I.Vector(e);const n=e[1],a=P.Number(r)?r[1]:0,o=P.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw j.Error("domain-error","Index must be integer.");return j.String(n.slice(a,o).map((e=>(I.Character(e),e[1]))).join(""),!1)})),string2vector:q("string->vector",[{name:"str"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,start:r,end:t})=>{I.String(e);const n=Array.from(e[1]),a=P.Number(r)?r[1]:0,o=P.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw j.Error("domain-error","Index must be integer.");return j.Vector(n.slice(a,o).map((e=>j.Character(e))),!1)})),vectorCopy:q("vector-copy",[{name:"vec"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({vec:e,start:r,end:t})=>{I.Vector(e);const n=e[1];if(0===n.length)return j.Vector([],!1);const a=P.Number(r)?r[1]:0,o=P.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw j.Error("domain-error","Index must be integer.");return j.Vector(n.slice(a,o),!1)})),vectorCopyD:q("vector-copy!",[{name:"to"},{name:"at"},{name:"from"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({to:e,at:r,from:t,start:n,end:a})=>{I.Vector(e),I.IntegerNumber(r),I.Vector(t);const o=P.Number(n)?n[1]:0,i=P.Number(a)?a[1]:t[1].length;if("number"!=typeof o||!Number.isInteger(o)||"number"!=typeof i||!Number.isInteger(i))throw j.Error("domain-error","Index must be integer.");if(!(r[1]in e[1]))throw j.Error("out-of-range","Index is out of range.");if(e[1].length-r[1]<i-o)throw j.Error("out-of-range","Index is out of range.");const l=t[1].slice(o,i);return e[1].splice(r[1],l.length,...l),["<undefined>"]})),vectorAppend:q("vector-append",[{name:"vecs",type:"variadic"}],(({vecs:e})=>(I.Vectors(e),j.Vector(e.map((e=>e[1])).flat(),!1)))),vectorFillD:q("vector-fill!",[{name:"vec"},{name:"fill"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({vec:e,fill:r,start:t,end:n})=>{if(I.Vector(e),I.Object(r),P.Undefined(r))throw j.Error("undefined-value","Attempt to fill vector with an undefined value.");const a=e[1],o=P.Number(t)?t[1]:0,i=P.Number(n)?n[1]:a.length;if("number"!=typeof o||!Number.isInteger(o)||"number"!=typeof i||!Number.isInteger(i))throw j.Error("domain-error","Index must be integer.");for(let l=o;l<i;l++)l in a&&(a[l]=r);return e}))},sa=[q("write",[{name:"obj"},{name:"port",type:"optional"}],(({obj:e,port:r})=>{let t;I.Object(e),r&&I.Object(r);try{t=i(l([s(e)]))}catch(n){if(n instanceof Error)throw j.Error("write-error",n.message);throw n}return r?x.CallBuiltIn("write-string",j.String(t,!1),r):x.CallBuiltIn("write-string",j.String(t,!1))}),!0,!0),q("write-shared",[{name:"obj"},{name:"port",type:"optional"}],(({obj:e,port:r})=>{let t;I.Object(e),r&&I.Object(r);try{t=i(l([s(e,{labels:"shared"})]))}catch(n){if(n instanceof Error)throw j.Error("write-error",n.message);throw n}return r?x.CallBuiltIn("write-string",j.String(t,!1),r):x.CallBuiltIn("write-string",j.String(t,!1))}),!0,!0),q("write-simple",[{name:"obj"},{name:"port",type:"optional"}],(({obj:e,port:r})=>{let t;I.Object(e),r&&I.Object(r);try{t=i(l([s(e,{labels:"simple"})]))}catch(n){if(n instanceof Error)throw j.Error("write-error",n.message);throw n}return r?x.CallBuiltIn("write-string",j.String(t,!1),r):x.CallBuiltIn("write-string",j.String(t,!1))}),!0,!0),q("display",[{name:"obj"},{name:"port",type:"optional"}],(({obj:e,port:r})=>{let t;I.Object(e),r&&I.Object(r);try{t=i(l([s(e,{style:"display"})]))}catch(n){if(n instanceof Error)throw j.Error("write-error",n.message);throw n}return r?x.CallBuiltIn("write-string",j.String(t,!1),r):x.CallBuiltIn("write-string",j.String(t,!1))}),!0,!0)],ca=[q("read",[{name:"port",type:"optional"}],(({port:e},r,t)=>{if(B(r),B(t),e||(e=r.getDynamic(h(t).env.dynamic,"current-input-port")),I.Port(e),"string"!=typeof e[5])throw j.Error("read-error","Not a text port.");let n,a,o="";for(;;){const n=Bn.body({port:e},r,t);if(P.EndOfFile(n))break;o+=n[1]}try{const e=K(o);[n,a]=W(e)}catch(p){throw p instanceof Error?j.Error("read-error",p.message):j.Error("read-error","Error occured while reading.")}if(0===n.length){if(a.length>0)throw j.Error("read-error","The external representation is incomplete and therefore not parsable,");return j.EndOfFile()}const[s,...c]=n,u=G(s,null,{removeLineInfo:!0}),m=l(c),d=i(m);return e[5]=d+e[5],u}),!1,!0)],ua=q("delay",[{name:"expr",evaluate:!1}],(({expr:e},r,t)=>{I.Object(e),B(t);const n=j.Procedure("lambda",[],e,!1,h(t).env);return j.Promise(n,null)}),!1,!0),ma=q("delay-force",[{name:"expr",evaluate:!1}],(({expr:e},r,t)=>{I.Object(e),B(t);const n=j.Procedure("lambda",[],e,!1,h(t).env),a=j.Promise(n,null);return x.CallBuiltIn("force",a)}),!0,!0),da=q("force",[{name:"promise"}],(({promise:e})=>{if(I.Object(e),P.Promise(e)){if(e[2])return x.Quote(e[2]);{const r=e[1];if(!r)throw j.Error("error","Illegal promise.");return x.CallBuiltIn("force-1",e,x.Call(r))}}return x.Quote(e)}),!0,!0),pa=q("force-1",[{name:"promise"},{name:"obj"}],(({promise:e,obj:r})=>(I.Promise(e),I.Object(r),e[2]=r,r)),!1,!0),fa=[ua,ma,da,q("promise?",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Boolean(P.Promise(e)))),!1,!0),q("make-promise",[{name:"obj"}],(({obj:e})=>(I.Object(e),j.Promise(null,e))),!1,!0)],ba=[pa],ya=[q("current-second",[],(()=>j.Number(Date.now()/1e3)),!1,!0),q("current-jiffy",[],(()=>{const e=Function("return this")();return j.Number(Math.round(e.performance?performance.now():Date.now()))}),!1,!0),q("jiffies-per-second",[],(()=>j.Number(1e3)),!1,!0)],ha=[q("finite?",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e);return j.Boolean(Number.isFinite(r))}),!1,!0),q("infinite?",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e);return j.Boolean(!Number.isNaN(r)&&!Number.isFinite(r))}),!1,!0),q("exp",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e);return d(Math.exp(r))}),!1,!0),q("log",[{name:"z1"},{name:"z2",type:"optional"}],(({z1:e,z2:r})=>{I.Number(e);const t=m(e);if(r){I.Number(r);const e=m(r);return d(Math.log(t)/Math.log(e))}return d(Math.log(t))}),!1,!0),q("sin",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e);return d(Math.sin(r))}),!1,!0),q("cos",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e);return d(Math.cos(r))}),!1,!0),q("tan",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e);return d(Math.tan(r))}),!1,!0),q("asin",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e);return d(Math.asin(r))}),!1,!0),q("acos",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e);return d(Math.acos(r))}),!1,!0),q("atan",[{name:"z1"},{name:"z2",type:"optional"}],(({z1:e,z2:r})=>{I.Number(e);const t=m(e);if(r){I.Number(r);const e=m(r);return d(Math.atan2(t,e))}return d(Math.atan(t))}),!1,!0),q("sqrt",[{name:"z"}],(({z:e})=>{I.Number(e);const r=m(e);return d(Math.sqrt(r))}),!1,!0)],ga=[q("case-lambda",[{name:"clauses",type:"variadic",evaluate:!1}],(({clauses:e})=>{I.Pairs(e);const r=_(),t=_(),n=j.Procedure("built-in","lambda"),a=j.Procedure("built-in","cond"),o=j.Procedure("built-in","define"),i=j.Procedure("built-in","apply"),l=j.Procedure("built-in","error");return H([n,r,[o,t,["length",r]],[a,...e.map((([,e,n])=>{const[a,o]=R(e);return[[o?">=":"=",t,a.length],[i,["lambda",e,...n],r]]})),["else",[l,'"No matching clause for case-lambda"']]]])}),!0,!0)],va=[q("char-ci=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{I.Character(e),I.Character(r),I.Characters(t);const n=[e,r,...t].map((e=>F(e[1])));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]===e)))}),!1,!0),q("char-ci<?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{I.Character(e),I.Character(r),I.Characters(t);const n=[e,r,...t].map((e=>F(e[1])));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]<e)))}),!1,!0),q("char-ci>?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{I.Character(e),I.Character(r),I.Characters(t);const n=[e,r,...t].map((e=>F(e[1])));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]>e)))}),!1,!0),q("char-ci<=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{I.Character(e),I.Character(r),I.Characters(t);const n=[e,r,...t].map((e=>F(e[1])));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]<=e)))}),!1,!0),q("char-ci>=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{I.Character(e),I.Character(r),I.Characters(t);const n=[e,r,...t].map((e=>F(e[1])));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]>=e)))}),!1,!0),q("char-alphabetic?",[{name:"char"}],(({char:e})=>(I.Character(e),j.Boolean(/\p{Alphabetic}/u.test(e[1])))),!1,!0),q("char-numeric?",[{name:"char"}],(({char:e})=>(I.Character(e),j.Boolean(/\p{Decimal_Number}/u.test(e[1])))),!1,!0),q("char-whitespace?",[{name:"char"}],(({char:e})=>(I.Character(e),j.Boolean(/\p{White_Space}/u.test(e[1])))),!1,!0),q("char-upper-case?",[{name:"char"}],(({char:e})=>(I.Character(e),j.Boolean(/\p{Uppercase}/u.test(e[1])))),!1,!0),q("char-lower-case?",[{name:"char"}],(({char:e})=>(I.Character(e),j.Boolean(/\p{Lowercase}/u.test(e[1])))),!1,!0),q("digit-value",[{name:"char"}],(({char:e})=>{var r;I.Character(e);const t=null!=(r=e[1].codePointAt(0))?r:0,n=[48,1632,1776,1984,2406,2534,2662,2790,2918,3046,3174,3302,3430,3558,3664,3792,3872,4160,4240,6112,6160,6470,6608,6784,6800,6992,7088,7232,7248,42528,43216,43264,43472,43504,43600,44016,65296,66720,69734,69872,69942,70096,70384,70864,71248,71360,71472,71904,92768,93008,120782,120792,120802,120812,120822].find((e=>t>=e&&t<=e+9));return n?j.Number(t-n):j.Boolean(!1)}),!1,!0),q("char-upcase",[{name:"char"}],(({char:e})=>(I.Character(e),j.Character(e[1].toUpperCase()))),!1,!0),q("char-downcase",[{name:"char"}],(({char:e})=>(I.Character(e),j.Character(e[1].toLowerCase()))),!1,!0),q("char-foldcase",[{name:"char"}],(({char:e})=>(I.Character(e),j.Character(F(e[1])))),!1,!0),q("string-ci=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{I.String(e),I.String(r),I.Strings(t);const n=[e,r,...t].map((e=>F(e[1])));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]===e)))}),!1,!0),q("string-ci<?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{I.String(e),I.String(r),I.Strings(t);const n=[e,r,...t].map((e=>F(e[1])));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]<e)))}),!1,!0),q("string-ci>?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{I.String(e),I.String(r),I.Strings(t);const n=[e,r,...t].map((e=>F(e[1])));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]>e)))}),!1,!0),q("string-ci<=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{I.String(e),I.String(r),I.Strings(t);const n=[e,r,...t].map((e=>F(e[1])));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]<=e)))}),!1,!0),q("string-ci>=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{I.String(e),I.String(r),I.Strings(t);const n=[e,r,...t].map((e=>F(e[1])));return j.Boolean(n.every(((e,r)=>0===r||n[r-1]>=e)))}),!1,!0),q("string-upcase",[{name:"str"}],(({str:e})=>(I.String(e),j.String(e[1].toUpperCase(),!1))),!1,!0),q("string-downcase",[{name:"str"}],(({str:e})=>(I.String(e),j.String(e[1].toLowerCase(),!1))),!1,!0),q("string-foldcase",[{name:"str"}],(({str:e})=>(I.String(e),j.String(F(e[1]),!1))),!1,!0)],Sa=(e,r)=>{const t=(r=r.replace(/^c/,"").replace(/r$/,"")).slice(-1),[,n,a]=e;if("a"===t)return r.length<=1?n:(I.Pair(n),Sa(n,r.slice(0,r.length-1)));if("d"===t)return r.length<=1?a:(I.Pair(a),Sa(a,r.slice(0,r.length-1)));throw j.Error("error",`Illegal cxr parameter ${r}`)},wa=[q("caaaar",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"caaaar"))),!1,!0),q("caaadr",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"caaadr"))),!1,!0),q("caaar",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"caaar"))),!1,!0),q("caadar",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"caadar"))),!1,!0),q("caaddr",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"caaddr"))),!1,!0),q("caadr",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"caadr"))),!1,!0),q("cadaar",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cadaar"))),!1,!0),q("cadadr",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cadadr"))),!1,!0),q("cadar",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cadar"))),!1,!0),q("caddar",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"caddar"))),!1,!0),q("cadddr",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cadddr"))),!1,!0),q("caddr",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"caddr"))),!1,!0),q("cdaaar",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cdaaar"))),!1,!0),q("cdaadr",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cdaadr"))),!1,!0),q("cdaar",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cdaar"))),!1,!0),q("cdadar",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cdadar"))),!1,!0),q("cdaddr",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cdaddr"))),!1,!0),q("cdadr",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cdadr"))),!1,!0),q("cddaar",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cddaar"))),!1,!0),q("cddadr",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cddadr"))),!1,!0),q("cddar",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cddar"))),!1,!0),q("cdddar",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cdddar"))),!1,!0),q("cddddr",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cddddr"))),!1,!0),q("cdddr",[{name:"pair"}],(({pair:e})=>(I.Pair(e),Sa(e,"cdddr"))),!1,!0)],ja=[q("command-line",[],(()=>{if(!(null==process?void 0:process.argv))throw j.Error("error","No process.argv (Maybe not running on Node.js)");return j.List(...process.argv.map((e=>j.String(e,!0))))}),!1,!0),q("exit",[{name:"obj",type:"optional"}],(({obj:e},r,t)=>{B(t),e&&I.Object(e);const n=e?x.CallBuiltIn("emergency-exit",j.MultiValue([e])):x.CallBuiltIn("emergency-exit"),a=j.Continuation(g(n));return x.Call(a)}),!0,!0),q("emergency-exit",[{name:"obj",type:"optional"}],(({obj:e})=>{throw e&&I.Object(e),j.Exit(null!=e?e:null)}),!1,!0),q("get-environment-variable",[{name:"name"}],(({name:e})=>{if(I.String(e),!(null==process?void 0:process.env))throw j.Error("error","No process.env (Maybe not running on Node.js)");const r=process.env[e[1]];return r?j.String(r,!0):j.Boolean(!1)}),!1,!0),q("get-environment-variables",[],(()=>{if(!(null==process?void 0:process.env))throw j.Error("error","No process.env (Maybe not running on Node.js)");return j.List(...Object.keys(process.env).map((e=>{var r;return j.Pair(j.String(e,!0),j.String(null!=(r=process.env[e])?r:"",!0))})))}),!1,!0)],xa='"fs" is not set. To use filesystems, import/require "fs" and set it on Interpreter\'s constructor parameter.',Pa=q("eval-close",[{name:"obj"},{name:"port"}],(({obj:e,port:r},t)=>(I.Object(e),I.Port(r),B(t),vn.body({port:r},t),e)),!1,!0),Ea=q("call-with-input-file",[{name:"str"},{name:"proc"}],(({str:e,proc:r},t,n)=>{B(t),B(n);const a=t.getOptions().fs;B(a,xa),I.String(e),I.Procedure(r);const o=Oa.body({str:e},t);return x.CallBuiltIn("eval-close",x.Call(r,o),o)}),!0,!0),Na=q("call-with-output-file",[{name:"str"},{name:"proc"}],(({str:e,proc:r},t)=>{B(t);const n=t.getOptions().fs;B(n,xa),I.String(e),I.Procedure(r);const a=Aa.body({str:e},t);return x.CallBuiltIn("eval-close",x.Call(r,a),a)}),!0,!0),Ia=q("with-input-from-file",[{name:"str"},{name:"thunk"}],(({str:e,thunk:r},t)=>{B(t);const n=t.getOptions().fs;B(n,xa),I.String(e),I.Procedure(r);const a=Oa.body({str:e},t);return x.CallBuiltIn("parameterize",j.List(j.List(j.Symbol("current-input-port"),a)),x.CallBuiltIn("eval-close",x.Call(r),a))}),!0,!0),Ba=q("with-output-to-file",[{name:"str"},{name:"thunk"}],(({str:e,thunk:r},t)=>{B(t);const n=t.getOptions().fs;B(n,xa),I.String(e),I.Procedure(r);const a=Aa.body({str:e},t);return x.CallBuiltIn("parameterize",j.List(j.List(j.Symbol("current-output-port"),a)),x.CallBuiltIn("eval-close",x.Call(r),a))}),!0,!0),Oa=q("open-input-file",[{name:"str"}],(({str:e},r)=>{var t;B(r);const n=r.getOptions().fs;B(n,xa),I.String(e);const a=r.getBuiltInPort(e[1]);if(a)try{return null==(t=a.open)||t.call(a,"r",null),j.Port("built-in",e[1],"r",null,"")}catch(o){throw o instanceof Error?j.Error("file-error",o.message):j.Error("file-error",`built-in port "${e[1]} open("r") failed.`)}else try{const r=n.openSync(e[1],"r");return j.Port("file",r,"r",null,"")}catch(o){throw o instanceof Error?j.Error("file-error",o.message):j.Error("file-error",`fs.openSync("${e[1]}", "r") failed.`)}}),!1,!0),Ca=q("open-binary-input-file",[{name:"str"}],(({str:e},r)=>{var t;B(r);const n=r.getOptions().fs;B(n,xa),I.String(e);const a=r.getBuiltInPort(e[1]);if(a)try{return null==(t=a.open)||t.call(a,"r",null),j.Port("built-in",e[1],"r",null,[])}catch(o){throw o instanceof Error?j.Error("file-error",o.message):j.Error("file-error",`built-in port "${e[1]} open("r") failed.`)}else try{const r=n.openSync(e[1],"r");return j.Port("file",r,"r",null,[])}catch(o){throw o instanceof Error?j.Error("file-error",o.message):j.Error("file-error",`fs.openSync("${e[1]}", "r") failed.`)}}),!1,!0),Aa=q("open-output-file",[{name:"str"}],(({str:e},r)=>{var t;B(r);const n=r.getOptions().fs;B(n,xa),I.String(e);const a=r.getBuiltInPort(e[1]);if(a)try{return null==(t=a.open)||t.call(a,"w",null),j.Port("built-in",e[1],"w",null,"")}catch(o){throw o instanceof Error?j.Error("file-error",o.message):j.Error("file-error",`built-in port "${e[1]} open("w") failed.`)}else try{const r=n.openSync(e[1],"w");return j.Port("file",r,"w",null,"")}catch(o){throw o instanceof Error?j.Error("file-error",o.message):j.Error("file-error",`fs.openSync("${e[1]}", "w") failed.`)}}),!1,!0),$a=q("open-binary-output-file",[{name:"str"}],(({str:e},r)=>{var t;B(r);const n=r.getOptions().fs;B(n,xa),I.String(e);const a=r.getBuiltInPort(e[1]);if(a)try{return null==(t=a.open)||t.call(a,"w",null),j.Port("built-in",e[1],"w",null,[])}catch(o){throw o instanceof Error?j.Error("file-error",o.message):j.Error("file-error",`built-in port "${e[1]} open("w") failed.`)}else try{const r=n.openSync(e[1],"w");return j.Port("file",r,"w",null,[])}catch(o){throw o instanceof Error?j.Error("file-error",o.message):j.Error("file-error",`fs.openSync("${e[1]}", "w") failed.`)}}),!1,!0),La=q("file-exists?",[{name:"filename"}],(({filename:e},r)=>{B(r);const t=r.getOptions().fs;B(t,xa),I.String(e);try{return j.Boolean(t.existsSync(e[1]))}catch(n){throw n instanceof Error?j.Error("file-error",n.message):j.Error("file-error","fs.existsSync() failed.")}}),!1,!0),ka=q("delete-file",[{name:"filename"}],(({filename:e},r)=>{B(r);const t=r.getOptions().fs;B(t,xa),I.String(e);try{t.unlinkSync(e[1])}catch(n){throw n instanceof Error?j.Error("file-error",n.message):j.Error("file-error","fs.unlinkSync() failed.")}return j.Undefined()}),!1,!0),Va=[Ea,Na,Ia,Ba,Oa,Ca,Aa,$a,La,ka],za=[Pa],Ma=[q("environment",[{name:"sets",type:"variadic"}],(({sets:e},r,t)=>{I.Objects(e),B(r),B(t);const n=g(j.Undefined());return Zn.body({sets:e},r,n),j.EnvironmentSpec(h(n).env)}),!1,!0),q("eval",[{name:"expr"},{name:"spec"}],(({expr:e,spec:r},t,n)=>(I.Object(e),I.EnvironmentSpec(r),B(n),S(n,e,{env:r[1]}))),!1,!0)],_a=q("interaction-environment",[],(()=>{const e=g(j.Undefined());return j.EnvironmentSpec(h(e).env)}),!1,!0),qa=[_a],Ta=[q("load",[{name:"filename"},{name:"spec",type:"optional"}],(({filename:e,spec:r},t,n)=>{B(t),B(n),I.String(e),r?I.EnvironmentSpec(r):r=_a.body();const a=er.body({filename:e},t);return x.CallBuiltIn("eval",a,r)}),!0,!0)],Da="\n  * +  - /  < <=  = >  >= abs  acos and  angle append  apply asin  assoc assq  assv atan\n  begin boolean?  caaaar caaadr  caaar caadar  caaddr caadr  caar cadaar  cadadr cadar\n  caddar cadddr  caddr cadr  call-with-current-continuation  call-with-input-file call-with-output-file\n  call-with-values car  case cdaaar  cdaadr cdaar  cdadar cdaddr  cdadr cdar  cddaar cddadr\n  cddar cdddar  cddddr cdddr  cddr cdr  ceiling char->integer  char-alphabetic? char-ci<=?\n  char-ci<? char-ci=?  char-ci>=? char-ci>?  char-downcase char-lower-case?  char-numeric? char-ready?\n  char-upcase char-upper-case?  char-whitespace? char<=?  char<? char=?  char>=? char>?\n  char? close-input-port  close-output-port complex?  cond cons  cos current-input-port\n  current-output-port define  define-syntax delay  denominator display  do dynamic-wind\n  eof-object? eq?  equal? eqv?  eval even?  exact->inexact exact?  exp expt  floor for-each\n  force gcd  if imag-part  inexact->exact inexact?   input-port? integer->char\n  integer? interaction-environment  lambda lcm  length let\n  let* let-syntax  letrec letrec-syntax  list list->string  list->vector list-ref\n  list-tail list?  load log  magnitude make-polar  make-rectangular make-string\n  make-vector map  max member  memq memv  min modulo  negative? newline  not null-environment\n  null? number->string  number? numerator  odd? open-input-file  open-output-file or\n  output-port? pair?  peek-char positive?  procedure? quasiquote  quote quotient  rational? rationalize\n  read read-char  real-part real?  remainder reverse  round  scheme-report-environment\n  set! set-car!  set-cdr! sin  sqrt string  string->list string->number  string->symbol string-append\n  string-ci<=? string-ci<?  string-ci=? string-ci>=?  string-ci>? string-copy  string-fill! string-length\n  string-ref string-set!  string<=? string<?  string=? string>=?  string>? string?  substring symbol->string\n  symbol? tan  truncate values  vector vector->list  vector-fill! vector-length  vector-ref vector-set!\n  vector? with-input-from-file  with-output-to-file write  write-char zero?\n".split(/(\s|\n)+/).filter((e=>!/^\s*$/.test(e))),Ra="\n  and  begin  case  cond  do  if  lambda  let  let*  let-syntax  letrec  letrec-syntax  or  quasiquote  quote  set!\n".split(/(\s|\n)+/).filter((e=>!/^\s*$/.test(e))),Qa=q("scheme-report-environment",[{name:"version"}],(({version:e},r,t)=>{if(B(r),B(t),I.Number(e),5!==e[1])throw j.Error("error","scheme-report-environment only supports version 5.");const n=g(j.Undefined());for(const a of Da)r.getProcedureContent(j.Procedure("built-in",a))&&r.defineStatic(h(n).env.static,j.Symbol(a),j.Procedure("built-in",a));return j.EnvironmentSpec(h(n).env)}),!1,!0),Ua=q("null-environment",[{name:"version"}],(({version:e},r,t)=>{if(B(r),B(t),I.Number(e),5!==e[1])throw j.Error("error","scheme-report-environment only supports version 5.");const n=g(j.Undefined());for(const a of Ra)r.getProcedureContent(j.Procedure("built-in",a))&&r.defineStatic(h(n).env.static,j.Symbol(a),j.Procedure("built-in",a));return j.EnvironmentSpec(h(n).env)}),!1,!0),Fa=T("exact->inexact",an);Fa.hidden=!0;const Ja=T("inexact->exact",on);Ja.hidden=!0;const Xa=[Qa,Ua,Fa,Ja],Za=[...Object.values(ne),...Object.values(be),...Object.values(Pe),...Object.values(_e),...Object.values(Re),...Object.values(He),...Object.values(Tr),...Object.values(ft),...Object.values(cn),...Object.values(Jn),...Object.values(Xn),...Object.values(oa),...Object.values(ia),...Object.values(la),...Object.values(nr),...Object.values(rr)],Ka={"(scheme write)":e=>{sa.forEach((r=>e.setBuiltInProcedure(r)));const r={};return sa.forEach((({name:e})=>r[e]=j.Procedure("built-in",e))),r},"(scheme read)":e=>{ca.forEach((r=>e.setBuiltInProcedure(r)));const r={};return ca.forEach((({name:e})=>r[e]=j.Procedure("built-in",e))),r},"(scheme lazy)":e=>{[...fa,...ba].forEach((r=>e.setBuiltInProcedure(r)));const r={};return fa.forEach((({name:e})=>r[e]=j.Procedure("built-in",e))),r},"(scheme time)":e=>{[...ya].forEach((r=>e.setBuiltInProcedure(r)));const r={};return ya.forEach((({name:e})=>r[e]=j.Procedure("built-in",e))),r},"(scheme inexact)":e=>{[...ha].forEach((r=>e.setBuiltInProcedure(r)));const r={};return ha.forEach((({name:e})=>r[e]=j.Procedure("built-in",e))),r},"(scheme case-lambda)":e=>{ga.forEach((r=>e.setBuiltInProcedure(r)));const r={};return ga.forEach((({name:e})=>r[e]=j.Procedure("built-in",e))),r},"(scheme char)":e=>{va.forEach((r=>e.setBuiltInProcedure(r)));const r={};return va.forEach((({name:e})=>r[e]=j.Procedure("built-in",e))),r},"(scheme cxr)":e=>{wa.forEach((r=>e.setBuiltInProcedure(r)));const r={};return wa.forEach((({name:e})=>r[e]=j.Procedure("built-in",e))),r},"(scheme process-context)":e=>{ja.forEach((r=>e.setBuiltInProcedure(r)));const r={};return ja.forEach((({name:e})=>r[e]=j.Procedure("built-in",e))),r},"(scheme file)":e=>{[...Va,...za].forEach((r=>e.setBuiltInProcedure(r)));const r={};return Va.forEach((({name:e})=>r[e]=j.Procedure("built-in",e))),r},"(scheme eval)":e=>{Ma.forEach((r=>e.setBuiltInProcedure(r)));const r={};return Ma.forEach((({name:e})=>r[e]=j.Procedure("built-in",e))),r},"(scheme repl)":e=>{qa.forEach((r=>e.setBuiltInProcedure(r)));const r={};return qa.forEach((({name:e})=>r[e]=j.Procedure("built-in",e))),r},"(scheme load)":e=>{Ta.forEach((r=>e.setBuiltInProcedure(r)));const r={};return Ta.forEach((({name:e})=>r[e]=j.Procedure("built-in",e))),r},"(scheme r5rs)":e=>{Xa.forEach((r=>e.setBuiltInProcedure(r)));const r={};for(const t of Da)e.getProcedureContent(j.Procedure("built-in",t))&&(r[t]=j.Procedure("built-in",t));return r}},Wa=[],Ga=console;e.Interpreter=class{constructor(e){var r,t;__publicField(this,"options"),__publicField(this,"builtins",{jsObject:{},procedure:{},port:{"//input":{},"//output":{write:e=>{var r;(null==(r=null==process?void 0:process.stdout)?void 0:r.write)?process.stdout.write(e):Ga.log(e)}},"//error":{write:e=>{var r;(null==(r=null==process?void 0:process.stderr)?void 0:r.write)?process.stderr.write(e):Ga.warn(e)}}},static:{"current-input-port":j.Parameter("current-input-port",null),"current-output-port":j.Parameter("current-output-port",null),"current-error-port":j.Parameter("current-error-port",null)},dynamic:{"current-input-port":j.Port("built-in","//input","r",null,""),"current-output-port":j.Port("built-in","//output","w",null,""),"current-error-port":j.Port("built-in","//error","w",null,"")},library:{}}),__publicField(this,"fs",null),this.options=null!=e?e:{},this.fs=null!=(r=null==e?void 0:e.fs)?r:null,Wa.forEach((([e,r])=>this.setBuiltInJSObject(e,r))),Za.forEach((e=>this.setBuiltInProcedure(e))),Object.keys(Ka).forEach((e=>this.setBuiltInLibrary(e,Ka[e]))),null==(t=null==e?void 0:e.plugins)||t.forEach((e=>e(this)))}getOptions(){return this.options}setBuiltInProcedure(e,r=!1){const t=j.Procedure("built-in",e.name);return!r&&this.getProcedureContent(t)||(this.builtins.procedure[e.name]=e),t}setBuiltInJSObject(e,r,t=!1){const n=j.JS("built-in",e);return!t&&this.getJSObjectContent(n)||(this.builtins.jsObject[e]=r),n}setBuiltInPort(e,r,t=!1){var n;const a=j.Port("built-in",e,null,null,(null==(n=r.binary)?void 0:n.call(r))?[]:"");return!t&&this.getBuiltInPort(e)||(this.builtins.port[e]=r),a}setBuiltInLibrary(e,r,t=!1){return!t&&this.getBuiltInPort(e)||(this.builtins.library[e]=r,r(this)),j.Symbol(e)}getProcedureContent(e){if(P.Continuation(e))return{parameters:[{name:"arg",evaluate:!0,type:"variadic"}],body:e,isMacro:!1,env:null};if(P.Parameter(e))return{parameters:[],body:e,isMacro:!1,env:null};if("lambda"===e[1]){const[,,r,t,n,a]=e;return{parameters:r,body:t,isMacro:n,env:a}}{const[,,r]=e;if(k.call(this.builtins.procedure,r)){const{parameters:e,body:t,isMacro:n=!1}=this.builtins.procedure[r];return{parameters:e,body:t,isMacro:n,env:null}}return null}}getJSObjectContent(e){if("inline"===e[1])return e[2];{const r=e[2];return k.call(this.builtins.jsObject,r)?this.builtins.jsObject[r]:null}}getBuiltInPort(e){return k.call(this.builtins.port,e)?this.builtins.port[e]:null}getBuiltInLibrary(e){return k.call(this.builtins.library,e)?this.builtins.library[e]:null}defineStatic(e,r,t){const n=r[3]?r[3]:r[1];return e=r[2]?r[2]:e,f(e)[n]=t,n}defineDynamic(e,r,t){return f(e)[r]=t,r}setStatic(e,r,t){const n=r[3]?r[3]:r[1];for(let a=e=r[2]?r[2]:e;null!==a;a=p(a)){const e=f(a);if(k.call(e,n))return e[n]=t}return null}setDynamic(e,r,t){for(let n=e;null!==n;n=p(n)){const e=f(n);if(k.call(e,r))return e[r]=t}return null}getStatic(e,r){const t=r[3]?r[3]:r[1];for(let n=e=r[2]?r[2]:e;null!==n;n=p(n)){const e=f(n);if(k.call(e,t))return e[t]}return k.call(this.builtins.static,t)?this.builtins.static[t]:k.call(this.builtins.procedure,t)&&!this.builtins.procedure[t].hidden?["<procedure>","built-in",t]:null}getDynamic(e,r){for(let t=e;null!==t;t=p(t)){const e=f(t);if(k.call(e,r))return e[r]}return k.call(this.builtins.dynamic,r)?this.builtins.dynamic[r]:null}eval(e){return this.evalAST(Y(e))}evalJS(e){return this.evalAST(x.Begin(H(e)))}resume(e,r=j.Undefined()){if(C(e)&&!A(e))throw new Error("The content of envelope is not #SUSPEND# object.");const t=A(e)?e.content[1]:e[1];return this.evalAST(x.Begin(x.Call(t,r)))}evalAST(e){var n,a,o,i;const l=g(e);let s=null;try{for(let e=l;e;){if(h(e).depth>(null!=(n=this.options.stack)?n:16384))throw new Error("Call-stack overflow.");this.options.beforeExecute&&([e,s]=null!=(a=this.options.beforeExecute(e,s))?a:[e,s]),this.options.debug&&Ga.log(`Executing(${null!=(o=e[1].want)?o:"initial"}/depth:${e[1].depth}) ${c(e[1].expr)}`);const[r,t]=this.execute(e,s);if(this.options.debug){const n=r?b(r)===e?"wind":b(e)===r?"unwind":b(r)==b(r)?"transfer":"unknown":"finish";Ga.log(`Result: ${t?c(t):t} (${n}).`),r&&this.options.verbose&&Ga.log(`Next(${null!=(i=r[1].want)?i:"initial"}/depth:${r[1].depth}) ${c(r[1].expr)}`)}this.options.afterExecute&&this.options.afterExecute(r,t,e,s),[e,s]=[r,t]}}catch(u){if(P.Exception(u)){const[,e,r]=u,[,t,n]=P.Error(r)?r:[null,"exception",c(r)],a="Exception: "+(null!=n?n:t)+"\n"+y(e).map((([,{depth:e,want:r,expr:t,info:n}])=>`${e}: ${null!=r?r:"initial"}: ${c(t,{maxdepth:20}).slice(0,100)}: ${JSON.stringify(n)}`)).join("\n")+"\n";throw this.options.debug&&Ga.log(`UNHANDLED ERROR: ${t}, ${n}\n${a}`),Object.assign(new Error,{name:t,message:null!=n?n:t,stack:a})}if(P.Object(u)||P.SpecialObject(u)){throw{language:r,version:t,content:u}}throw u}if(!s)throw new Error("AST didn't return value");return s}execute(e,r){var t,n;const a=(e=>{const r=h(e),t=r.args;return["#CALL-STACK#",__spreadProps(__spreadValues({},r),{args:t?[...t]:null}),b(e)]})(e),o=h(a),{expr:i}=o;try{if(r){if("return"===o.want)return[b(a),r];if("macro"===o.want)return[S(a,r),null]}if(null===o.want){if(r){if(!P.MultiValue(r)||0!==r[1].length)throw j.Error("internal-error",`Call-frame was given a value without any want. "${o.want}"`);r=null}if(P.Symbol(i)){const e=this.getStatic(null!=(t=i[2])?t:h(a).env.static,i);if(e)return[b(a),e];throw j.Error("unbound-variable",`${i[1]} is not defined.`)}if(P.Null(i))throw j.Error("program-error","Evaluating an empty list is an error in Scheme.");if(!P.Pair(i))return[b(a),i];o.want="oper"}if(!P.Pair(i))throw j.Error("internal-error","Illegal status of call-frame. frane.want is not null, but expr is not a <pair>.");if("oper"===o.want)if(r){if(!P.Procedure(r))throw j.Error("not-a-procedure","Operator evaluation didn't return a valid procedure");o.oper=r,o.want="args",r=null}else{if(!P.Procedure(i[1])){if(P.Symbol(i[1])||P.Pair(i[1]))return[v(a,i[1]),null];throw j.Error("invalid-procedure","Operator is not a valid procedure.")}o.oper=i[1],o.want="args"}if(!o.oper)throw j.Error("internal-error","Illegal status of call-frame. frame.want is not null or oper, but oper is still null.");const l=this.getProcedureContent(o.oper);if(!l)throw j.Error("program-error","Operator is not a valid procedure.");const c=l.parameters.filter((e=>!e.type||"head"===e.type)),u=l.parameters.filter((e=>"optional"===e.type)),[m]=l.parameters.filter((e=>"variadic"===e.type)),d=l.parameters.filter((e=>"tail"===e.type));if("args"===o.want){let e;if(r)e=[r],r=null;else{const[r]=z(i);e=r.slice(1)}if(1===e.length&&P.MultiValue(e[0])){const[[,r]]=e;if(r.length<c.length+d.length||!m&&r.length>c.length+d.length+u.length)throw j.Error("arity-error","Length of items in `multiple-value' object does not match the length of parameters.");o.args=r,o.want="return"}else{if(e.length<c.length+d.length||!m&&e.length>c.length+d.length+u.length)throw j.Error("arity-error","Length of arguments does not match the length of parameters.");const r=Math.max(0,e.length-c.length-d.length),t=Math.max(0,e.length-c.length-u.length-d.length),n=[...c,...u.slice(0,r),...Array.from({length:t},(()=>m)),...d];o.args=e.map(((e,r)=>{var t;return(null==(t=n[r].evaluate)||t)&&P.Evaluatable(e)?null:e})),o.want=-1}}if(!o.args)throw j.Error("internal-error","Invalid status of call-frame. frame.want is not null, oper or args, but frame.args is still null.");if("number"==typeof o.want){r&&(o.args[o.want]=r,r=null);for(let e=0,r=o.args[e];e<o.args.length;r=o.args[++e])if(null===r){const r=V(i).slice(1);return o.want=e,[v(a,r[e]),null]}o.want="return"}if(!P.Objects(o.args))throw j.Error("internal-error","Invalid status of call-frame. frame.args contains non-objects.");const p=o.args,f=Math.max(0,p.length-c.length-d.length),g=Math.max(0,p.length-c.length-u.length-d.length),E=[...c,...u.slice(0,f),...Array.from({length:g},(()=>m)),...d];if("return"===o.want){if("function"==typeof l.body){const e=m?{[m.name]:[]}:{};for(let n=0;n<E.length;n++)"variadic"===E[n].type?e[E[n].name].push(p[n]):e[E[n].name]=p[n];let r;const{acceptableJSValue:t=(()=>!0)}=this.options;try{if(r=l.body(e,this,a),!P.Object(r)&&!P.CallStack(r)){if(!t(r))throw j.Error("not-acceptable-js-value",null);r=j.JS("inline",r)}}catch(s){throw P.Object(s)||P.SpecialObject(s)?P.Exception(s)||P.SpecialObject(s)?s:j.Exception(a,s,!1):s instanceof Error?s:j.Exception(a,j.JS("inline",s),!1)}return P.CallStack(r)?[r,null]:l.isMacro&&P.Evaluatable(r)?[S(a,r),null]:[b(a),r]}if(P.Continuation(l.body)){const e=l.body,r=y(a),t=y(e[1]).reverse(),o=new Set(t),i=null!=(n=r.find((e=>o.has(e))))?n:null,s=i?r.slice(0,r.indexOf(i)):r,c=i?t.slice(t.indexOf(i)+1):t,u=1===p.length?p[0]:j.MultiValue(p);for(const n of s){const r=h(n).after;if(r){const t=x.Begin(x.Call(r),x.Call(e,j.MultiValue([u])));return[S(n,t,{before:null,after:null}),null]}}for(const n of c){const r=h(n).before;if(r){const t=x.Begin(x.Call(r),x.Call(e,j.MultiValue([u])));return[v(n,t),null]}}return[e[1],u]}if(P.Parameter(l.body)){const e=this.getDynamic(h(a).env.dynamic,l.body[1]);if(!e)throw j.Error("unbound-variable","Parameter is not defined.");return[b(a),e]}{const{dynamic:r}=h(e).env,t=w(l.env.static),n=[];for(let e=0;e<E.length;e++)"variadic"!==E[e].type?this.defineStatic(t,j.Symbol(E[e].name),p[e]):n.push(p[e]);return m&&this.defineStatic(t,j.Symbol(m.name),M(n)),l.isMacro?(h(a).want="macro",[v(a,l.body,{env:{static:t,dynamic:r}}),null]):[S(a,l.body,{env:{static:t,dynamic:r}}),null]}}throw j.Error("internal-error",`Illegal status (want) of call-frame: ${o.want}`)}catch(s){if(s=P.Error(s)?j.Exception(a,s,!1):s,P.Exception(s)){const[,e,r,t]=s;if(o.handler){const n=f(o.handler);if(t){const t=j.Continuation(b(e)),a=x.Call(t,x.Call(n,j.MultiValue([r])));return[S(e,a,{handler:p(o.handler)}),null]}{const t=x.Raise(x.Call(n,j.MultiValue([r])));return[S(e,t,{handler:p(o.handler)}),null]}}throw s}if(P.JS(s)&&"built-in"===s[1]&&((l=s[2])&&("object"==typeof l||"function"==typeof l)&&"function"==typeof l.then)){const e=j.JSPromiseContinuation(j.Continuation(a),s[2],"pending");throw s[2].then((()=>e[3]="fulfilled"),(()=>e[3]="rejected")),e}throw s}var l}},e.arrayToList=M,e.assert=I,e.create=j,e.defineBuiltInProcedure=q,e.defineBuiltInProcedureAlias=T,e.exitValueFromEnvelope=e=>e.content[1],e.forkCS=v,e.forms=x,e.fromJS=H,e.fromReferentialJSON=(e,r)=>{const t=JSON.parse(e),n=new Map,a=e=>{e instanceof Array&&e[0]===r&&e.length>=3?(n.set(e[1],e[2]),Object.keys(e[2]).forEach((r=>a(e[2][r])))):"object"==typeof e&&null!==e&&Object.keys(e).forEach((r=>a(e[r])))};a(t);const o=e=>{if(e instanceof Array&&e[0]===r&&n.has(e[1])){if(e.length>=3){const r=e[2];if(r instanceof Array)return r.splice(0,r.length,...r.map((e=>o(e)))),r;{const e=Object.keys(r).reduce(((e,t)=>(e[t]=o(r[t]),e)),{});return Object.assign(r,e)}}return n.get(e[1])}return e instanceof Array?e.map((e=>o(e))):"object"==typeof e&&null!==e?Object.keys(e).reduce(((r,t)=>(r[t]=o(e[t]),r)),{}):e};return o(t)},e.is=P,e.isCurrentVersionEnvelope=e=>!!e&&"object"==typeof e&&e.language===r&&e.version===t&&(P.Object(e.content)||P.SpecialObject(e.content)),e.isEnvelope=C,e.isExitEnvelope=e=>C(e)&&P.Exit(e.content),e.isJSPromiseContinuationEnvelope=$,e.isPromiseEnvelope=L,e.isSuspendEnvelope=A,e.listToArray=V,e.pairToArrayWithEnd=z,e.parser=Y,e.promiseFromEnvelope=e=>e.content[2],e.promiseStatusFromEnvelope=e=>e.content[3],e.suspendValueFromEnvelope=e=>e.content[2],e.toJS=e=>s(e,{extended:!0}),e.toReferentialJSON=(e,r)=>{const t=new Set,n=new Set,a=e=>{var o,i;if(e instanceof Array&&e[0]===r){const e=new Error(`ReferenceTag "${r}" is already contained in the value.`);throw e.name="reference-tag",e}if("object"!=typeof e||null===e){if("number"!=typeof e||!Number.isNaN(e)&&Number.isFinite(e)){if(null===e||"boolean"==typeof e||"string"==typeof e||"number"==typeof e)return;throw new Error(`Unserializable object: <${typeof e}>`)}throw new Error("JSON can't contain Infinite/-Infinite/NaN")}{const r=null==(o=e.constructor)?void 0:o.name;if("Object"!==r&&"Array"!==r)throw new Error(`Unserializable object: <${typeof e} ${null==(i=e.constructor)?void 0:i.name}>`);t.has(e)?n.has(e)||n.add(e):(t.add(e),Object.keys(e).forEach((r=>a(e[r]))))}};a(e),t.clear();const o=new Map,i=(e,t=!1)=>!t&&o.has(e)?[r,o.get(e)]:!t&&n.has(e)?(o.set(e,o.size+1),[r,o.get(e),i(e,!0)]):e instanceof Array?e.map((e=>i(e))):"object"==typeof e&&null!==e?Object.keys(e).reduce(((r,t)=>(r[t]=i(e[t]),r)),{}):e,l=i(e);return n.clear(),o.clear(),JSON.stringify(l)},e.transferCS=S,e.unparser=u,e.wrapBuiltInProcedure=({name:e,parameters:r,body:t,isMacro:n,hidden:a})=>{const o=console;return{name:e,parameters:r,body:(a,i,l)=>{let s;o.log(`-----[Built-in Procedure Call "${e}"]-----\nIs${n?"":" NOT"} a macro procedure.\n-----[Parameters]-----\n`+r.map(((e,r)=>{const t=a[e.name];return P.Object(t)?`${r}:${e.name}: ${c(t,{maxdepth:20})}\n`:t instanceof Array?`${r}:${e.name}:length ${t.length}}\n`+t.map(((e,r)=>` [${r}]: ${c(e,{maxdepth:20})}\n`)).join(""):`${r}:${e.name}: ${t}\n`})).join("")+" --------------------------------------------\nCalling now...\n");try{s=t(a,i,l)}catch(u){throw o.log(`-----[Exception]-----\nException is${P.Object(u)?"":" NOT"} a LISP Object.\n`+(P.Object(u)?c(u,{maxdepth:20}):`${u}`)+"\n-----------------------"),u}return o.log(`-----[Return]-----\nReturn value is ${P.Object(s)?"":"NOT"} a LISP Object.\n`+(P.Object(s)?c(s,{maxdepth:20}):`${s}`)+"\n-----------------------"),s},isMacro:n,hidden:a}},e.writeObject=c,Object.defineProperty(e,"__esModule",{value:!0}),e[Symbol.toStringTag]="Module"}));
