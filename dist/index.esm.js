var e=Object.defineProperty,r=Object.defineProperties,t=Object.getOwnPropertyDescriptors,n=Object.getOwnPropertySymbols,a=Object.prototype.hasOwnProperty,o=Object.prototype.propertyIsEnumerable,i=(r,t,n)=>t in r?e(r,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):r[t]=n,l=(e,r)=>{for(var t in r||(r={}))a.call(r,t)&&i(e,t,r[t]);if(n)for(var t of n(r))o.call(r,t)&&i(e,t,r[t]);return e},s=(e,n)=>r(e,t(n)),c=("undefined"!=typeof require&&require,(e,r,t)=>(i(e,"symbol"!=typeof r?r+"":r,t),t));const u="cumalis-lisp",m={quote:"'",quasiquote:"`",unquote:",","unquote-splicing":",@"},d=/^(?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+$/,p={"":"\\a","\b":"\\b","\t":"\\t","\n":"\\n","\r":"\\r",'"':'\\"',"\\":"\\\\","|":"\\|"},f=e=>{let r="",t="";for(const n of e){const e=n.length>2&&0===n.indexOf('""')?n.replace(/^""/,"").replace(/""$/,""):n;r=r+(""===r||"("===t.slice(-1)||")"===n||Object.values(m).indexOf(t)>=0||/^#\d+=$/.test(t)&&"("===n?"":" ")+e,t=n}return r},b=e=>{const r=e=>{const t=[];for(const n of e)if("string"==typeof n)t.push(n);else if(n instanceof Array)if("string"==typeof n[0]&&Object.values(m).includes(n[0]))t.push(...r(n));else if("#"===n[0]||"#u8"===n[0]){if(2!==n.length||!(n[1]instanceof Array))throw new Error("Illegal token tree: #/#u8 must have only one token array");t.push(`${n[0]}(`),t.push(...r(n[1])),t.push(")")}else if("string"==typeof n[0]&&/^#\d+=/.exec(n[0])){if(2!==n.length)throw new Error("Illegal token tree: datum label must have the content");t.push(n[0],...r(n.splice(1)))}else t.push("("),t.push(...r(n)),t.push(")");return t};return r(e)},y=(e,r)=>{const{extended:t=!1,style:n="write",labels:a="cyclic",maxdepth:o=1/0}=null!=r?r:{},i=new Set,l=new Set,s=(e,r,n)=>{if(V.Object(e),!t&&r>o)return;if(!t&&("cyclic"===a&&n.has(e)||"shared"===a&&i.has(e)))return void l.add(e);i.add(e);const c=new Set(n);c.add(e),L.Pair(e)?(s(e[1],r+1,c),s(e[2],r+1,c)):L.Vector(e)&&e[1].forEach((e=>s(e,r+1,c)))};s(e,0,new Set);const c=new Map,u=(e,r,a=!1)=>{var i;if(V.Object(e),!t&&r>o)return"...";if(!a&&!t&&l.has(e)){if(c.has(e))return`#${c.get(e)}#`;{const t=c.size+1;c.set(e,t);return[`#${t}=`,u(e,r,!0)]}}switch(e[0]){case"<symbol>":return t||d.test(e[1])?e[1]:"|"+e[1].replace(/[\x00-\x1f\x7f"|\\]/g,(e=>{var r,t;return null!=(t=p[e])?t:`\\x${null==(r=e.codePointAt(0))?void 0:r.toString(16)}`}))+"|";case"<null>":return t?null:[];case"<string>":return t?e[1]:"display"!==n?'"'+e[1].replace(/[\x00-\x1f\x7f]"|\\/g,(e=>{var r,t;return null!=(t=p[e])?t:`\\x${null==(r=e.codePointAt(0))?void 0:r.toString(16)}`}))+'"':'""'+e[1]+'""';case"<number>":return t?S(e):`${e[1]}`;case"<boolean>":return t?e[1]:e[1]?"#t":"#f";case"<character>":if(t)return e[1];if("display"!==n){const[r]=null!=(i=Object.entries(de).find((([,r])=>r===e[1])))?i:[];return`#\\${null!=r?r:e[1]}`}return'""'+e[1]+'""';case"<vector>":return["#",[...e[1].map((e=>u(e,r+1)))]];case"<bytevector>":return["#u8",[...e[1].map((e=>`${e}`))]];case"<pair>":const[,a,o]=e;if("<null>"===o[0])return[u(a,r+1)];if("<pair>"!==o[0])return[u(a,r+1),".",u(o,r+1)];if("<symbol>"===a[0]&&m[a[1]]){const e=u(o,r+1);return e instanceof Array&&!L.Object(e)?[m[a[1]],...e]:[m[a[1]],e]}{const e=u(a,r+1),t=u(o,r+1);return t instanceof Array&&!L.Object(t)?[e,...t]:[e,".",t]}case"<js>":return t?["&",e[1]]:`#<$js[${null===e[1]?"null":typeof e[1]}]>`;case"<procedure>":return t?e:"built-in"===e[1]?`#<procedure[built-in/${e[2]}]>`:`#<procedure[${e[1]}]>`;default:return t?e:`#${e[0]}`}};return u(e,0)},h=e=>y(e,{extended:!0}),g=(e,r={})=>{try{const t=y(e,s(l({maxdepth:8},r),{extended:!1})),n=b([t]);return f(n)}catch(t){return"<!!WRITE-ERROR!!>"}},v=(e,r={})=>{const t=y(e,s(l({},r),{extended:!1}));if(!(t instanceof Array&&"begin"===t[0]))throw new Error('fromASTToText error: The top of AST is must be a "begin" expression.');const n=b(t.slice(1));return f(n)},S=e=>"number"==typeof e[1]?e[1]:"+inf.0"===e[1]?1/0:"-inf.0"===e[1]?-1/0:NaN,w=e=>A.Number(Number.isFinite(e)?Number.isNaN(e)?"+nan.0":e:e<0?"-inf.0":"+inf.0"),j=e=>e[2],x=e=>e[1],P=e=>e[2],E=e=>{const r=[];for(let t=e;t;t=P(t))r.push(t);return r},N=e=>e[1],I=e=>["#CALL-STACK#",{depth:0,env:{static:A.StaticNS({},null),dynamic:A.DynamicNS({},null)},expr:e,want:null,oper:null,args:null,before:null,after:null,handler:null,info:L.Pair(e)&&e[4]||null},null],B=(e,r,t={})=>{var n,a,o;const{env:i,handler:l,depth:s,info:c}=N(e);return["#CALL-STACK#",{depth:s+1,env:null!=(n=t.env)?n:i,expr:r,want:null,oper:null,args:null,before:null!=(a=t.before)?a:null,after:null!=(o=t.after)?o:null,handler:l,info:L.Pair(r)&&r[4]||c},e]},O=(e,r,t={})=>{var n,a,o;const{env:i,handler:l,depth:s,info:c,before:u,after:m}=N(e);return["#CALL-STACK#",{depth:s,env:null!=(n=t.env)?n:i,expr:r,want:null!=(a=t.want)?a:null,oper:null!=(o=t.oper)?o:null,args:null,before:void 0===t.before?u:t.before,after:void 0===t.after?m:t.after,handler:void 0!==t.handler?t.handler:l,info:L.Pair(r)&&r[4]||c},P(e)]},C=e=>[e[0],{},e],A={Symbol:(...e)=>["<symbol>",...e],String:(...e)=>["<string>",...e],Number:(...e)=>["<number>",...e],Boolean:(...e)=>["<boolean>",...e],Character:(...e)=>["<character>",...e],Pair:(e,r,t=!1,n)=>n?["<pair>",e,r,t,n]:["<pair>",e,r,t],Null:()=>["<null>"],Vector:(...e)=>["<vector>",...e],ByteVector:(...e)=>["<bytevector>",...e],EndOfFile:(...e)=>["<end-of-file>",...e],Procedure:(...e)=>["<procedure>",...e],Port:(...e)=>["<port>",...e],RecordType:(...e)=>["<record-type>",...e],Record:(...e)=>["<record>",...e],SyntaxRules:(...e)=>["<syntax-rules>",...e],Parameter:(...e)=>["<parameter>",...e],MultiValue:(...e)=>["<multi-value>",...e],Exception:(...e)=>["<exception>",...e],Undefined:(...e)=>["<undefined>",...e],Promise:(...e)=>["<promise>",...e],Error:(e,r,t=[])=>["<error>",e,r,t],Continuation:(...e)=>["<continuation>",...e],EnvironmentSpec:(...e)=>["<environment-spec>",...e],Library:(...e)=>["<library>",...e],JS:(...e)=>["<js>",...e],List:(...e)=>e.reverse().reduce(((e,r)=>["<pair>",r,e,!1]),["<null>"]),Suspend:(...e)=>["#SUSPEND#",...e],JSPromiseContinuation:(...e)=>["#JS-PROMISE-CONTINUATION#",...e],Exit:(...e)=>["#EXIT#",...e],StaticNS:(...e)=>["#STATIC-NS-STACK#",...e],DynamicNS:(...e)=>["#DYNAMIC-NS-STACK#",...e],HandlerStack:(...e)=>["#HANDLER-STACK#",...e]},$={Call:(e,...r)=>A.List(e,...r),CallBuiltIn:(e,...r)=>A.List(A.Procedure("built-in",e),...r),Lambda:(...e)=>L.List(e[0])?$.CallBuiltIn("lambda",...e):$.CallBuiltIn("lambda",H(e[0],e[1]),...e.slice(2)),CallThunk:(...e)=>$.Call($.CallBuiltIn("lambda",["<null>"],...e)),Begin:(...e)=>$.CallBuiltIn("begin",...e),Quote:e=>$.CallBuiltIn("quote",e),Set:(e,r)=>$.CallBuiltIn("set!",e,r),Raise:e=>$.CallBuiltIn("raise",e),RaiseContinuable:e=>$.CallBuiltIn("raise-continuable",e),Let:(e,...r)=>$.CallBuiltIn("let",A.List(...e.map((e=>A.List(...e)))),...r),If:(e,r,t)=>t?$.CallBuiltIn("if",e,r,t):$.CallBuiltIn("if",e,r),And:(...e)=>$.CallBuiltIn("and",...e),Or:(...e)=>$.CallBuiltIn("or",...e),Cond:(e,...r)=>$.CallBuiltIn("cond",e,...r),Case:(e,r)=>$.CallBuiltIn("case",e,A.List(...r.map((e=>A.List(...e))))),Define:(...e)=>$.CallBuiltIn("define",...e),DefineValues:(e,r)=>$.CallBuiltIn("define-values",L.List(e)?e:A.List(...e),r),Append:(...e)=>$.CallBuiltIn("append",...e),Cons:(...e)=>$.CallBuiltIn("cons",...e),Values:(...e)=>$.CallBuiltIn("values",...e),BeginIfMultiple:(...e)=>0===e.length?["<undefined>"]:1===e.length?e[0]:$.Begin(...e)},L={Symbol:e=>e instanceof Array&&"<symbol>"===e[0],String:e=>e instanceof Array&&"<string>"===e[0],Number:e=>e instanceof Array&&"<number>"===e[0],Boolean:e=>e instanceof Array&&"<boolean>"===e[0],Character:e=>e instanceof Array&&"<character>"===e[0],Pair:e=>e instanceof Array&&"<pair>"===e[0],Null:e=>e instanceof Array&&"<null>"===e[0],Vector:e=>e instanceof Array&&"<vector>"===e[0],ByteVector:e=>e instanceof Array&&"<bytevector>"===e[0],EndOfFile:e=>e instanceof Array&&"<end-of-file>"===e[0],Port:e=>e instanceof Array&&"<port>"===e[0],RecordType:e=>e instanceof Array&&"<record-type>"===e[0],Record:e=>e instanceof Array&&"<record>"===e[0],MultiValue:e=>e instanceof Array&&"<multi-value>"===e[0],SyntaxRules:e=>e instanceof Array&&"<syntax-rules>"===e[0],SyntaxRulePattern:e=>e instanceof Array&&"<syntax-rule-pattern>"===e[0],Parameter:e=>e instanceof Array&&"<parameter>"===e[0],EnvironmentSpec:e=>e instanceof Array&&"<environment-spec>"===e[0],Exception:e=>e instanceof Array&&"<exception>"===e[0],Undefined:e=>e instanceof Array&&"<undefined>"===e[0],Promise:e=>e instanceof Array&&"<promise>"===e[0],Error:e=>e instanceof Array&&"<error>"===e[0],Continuation:e=>e instanceof Array&&"<continuation>"===e[0],Library:e=>e instanceof Array&&"<library>"===e[0],JS:e=>e instanceof Array&&"<js>"===e[0],List:e=>L.Pair(e)||L.Null(e),Procedure:e=>e instanceof Array&&("<procedure>"===e[0]||"<continuation>"===e[0]||"<parameter>"===e[0]),Object:e=>e instanceof Array&&"string"==typeof e[0]&&/^<.*>/.test(e[0]),Evaluatable:e=>L.List(e)||L.Symbol(e),False:e=>L.Boolean(e)&&!1===e[1],RealNumber:e=>L.Number(e)&&"number"==typeof e[1],IntegerNumber:e=>L.Number(e)&&"number"==typeof e[1]&&Number.isInteger(e[1]),Objects:e=>e instanceof Array&&e.every((e=>L.Object(e))),Suspend:e=>e instanceof Array&&"#SUSPEND#"===e[0],JSPromiseContinuation:e=>e instanceof Array&&"#JS-PROMISE-CONTINUATION#"===e[0],Exit:e=>e instanceof Array&&"#EXIT#"===e[0],CallStack:e=>e instanceof Array&&"#CALL-STACK#"===e[0],SpecialObject:e=>e instanceof Array&&"string"==typeof e[0]&&/^#.+#$/.test(e[0]),Dictionary:e=>"object"==typeof e&&!!e&&e.constructor===Object,Stack:e=>e instanceof Array&&3===e.length&&"string"==typeof e[0]&&/^#.*-STACK#$/.test(e[0])},k=(e,r)=>(t,n)=>{if(!e(t))throw A.Error("domain-error",null!=n?n:r)},z=(e,r)=>(t,n)=>{if(!(t instanceof Array))throw A.Error("domain-error",null!=n?n:r);for(const a of t)if(!e(a))throw A.Error("domain-error",null!=n?n:r)},V={List:k(L.List,"A <pair> or <null> is expected."),Pair:k(L.Pair,"A <pair> is expected."),Symbol:k(L.Symbol,"A <symbol> is expected."),Number:k(L.Number,"A <number> is expected."),Boolean:k(L.Boolean,"A <boolean> is expected."),Object:k(L.Object,"A Scheme object is expected."),String:k(L.String,"A <string> is expected."),Vector:k(L.Vector,"A <vector> is expected."),ByteVector:k(L.ByteVector,"A <bytevector> is expected."),Character:k(L.Character,"A <character> is expected."),Promise:k(L.Promise,"A <promise> is expected."),Error:k(L.Error,"A <error> is expected."),Procedure:k(L.Procedure,"A <procedure> is expected."),SyntaxRules:k(L.SyntaxRules,"A <syntax-rules> is expected."),Parameter:k(L.Parameter,"A <parameter> is expected."),EnvironmentSpec:k(L.EnvironmentSpec,"A <environment-spec> is expected."),RecordType:k(L.RecordType,"A <record-type> is expected."),Record:k(L.Record,"A <record> is expected."),MultiValue:k(L.MultiValue,"A <multi-value> is expected."),Port:k(L.Port,"A <port> is expected."),Library:k(L.Library,"A <library> is expected."),Lists:z(L.List,"An array of <pair>/<null> is expected."),Pairs:z(L.Pair,"An array of <pair> is expected."),Symbols:z(L.Symbol,"An array of <symbol> is expected."),Numbers:z(L.Number,"An array of <number> is expected."),Booleans:z(L.Boolean,"An array of <boolean> is expected."),Objects:z(L.Object,"An array of Scheme object is expected."),Strings:z(L.String,"An array of <string> is expected."),Vectors:z(L.Vector,"An array of <vector> is expected."),ByteVectors:z(L.ByteVector,"An array of  <bytevector> is expected."),Characters:z(L.Character,"An array of <character> is expected."),RealNumber:k(L.RealNumber,"A real <number> (not infinite, not NaN) is expected."),IntegerNumber:k(L.IntegerNumber,"A integer <number> is expected."),RealNumbers:z(L.RealNumber,"An array of real <number> is expected."),IntegerNumbers:z(L.IntegerNumber,"An array of integer <number> is expected.")},M=(e,r)=>{if(null==e)throw A.Error("program-error",null!=r?r:"Required object.")},q=e=>"object"==typeof e&&null!==e&&"Object"===e.constructor.name,T=e=>!!e&&"object"==typeof e&&e.language===u&&!!e.version&&(L.Object(e.content)||L.SpecialObject(e.content)),D=e=>!!e&&"object"==typeof e&&e.language===u&&"0.6.0"===e.version&&(L.Object(e.content)||L.SpecialObject(e.content)),R=e=>T(e)&&L.Suspend(e.content),Q=e=>e.content[2],U=e=>T(e)&&L.JSPromiseContinuation(e.content),F=U,J=e=>e.content[2],_=e=>e.content[3],X=e=>T(e)&&L.Exit(e.content),Z=e=>e.content[1],K=Object.prototype.hasOwnProperty,W=e=>{const r=new Set,t=e=>{if(L.Pair(e)){const[,n,a]=e;if(r.has(a))throw new Error("Circular list detected.");return r.add(a),[n,...t(L.List(a)?a:["<null>"])]}return[]};return t(e)},G=e=>{const r=new Set;return(e=>{const[,t,n]=e;if(L.Pair(n)){if(r.has(n))throw new Error("Circular list detected.");r.add(n);const[e,a]=G(n);return[[t,...e],a]}return[[t],n]})(e)},H=(e,r,t=!1,n)=>e.reverse().reduce(((r,a,o)=>n&&o===e.length-1?A.Pair(a,r,t,n):A.Pair(a,r,t)),r||["<null>"]),Y=(()=>{let e=0,r=0,t=0;return()=>"::"+"T-S-XXXXXXX".replace(/[TSX]/g,(n=>(r=Date.now(),"T"===n?`0000000000000${r.toString(16)}`.slice(-14):"S"===n?`000${(e===r?(e=r,t=0):t++).toString(16)}`.slice(-4):`000${(65536*Math.random()|0).toString(16)}`.slice(-4))))})(),ee=(e,r,t,n=!1,a=!1)=>{if(r.filter((e=>"variadic"===e.type)).length>1)throw new Error("Only one variadic parameter is allowed.");return{name:e,parameters:r,body:t,isMacro:n,hidden:a}},re=(e,r)=>s(l({},r),{name:e}),te=({name:e,parameters:r,body:t,isMacro:n,hidden:a})=>{const o=console;return{name:e,parameters:r,body:(a,i,l)=>{let s;o.log(`-----[Built-in Procedure Call "${e}"]-----\nIs${n?"":" NOT"} a macro procedure.\n-----[Parameters]-----\n`+r.map(((e,r)=>{const t=a[e.name];return L.Object(t)?`${r}:${e.name}: ${g(t,{maxdepth:20})}\n`:t instanceof Array?`${r}:${e.name}:length ${t.length}}\n`+t.map(((e,r)=>` [${r}]: ${g(e,{maxdepth:20})}\n`)).join(""):`${r}:${e.name}: ${t}\n`})).join("")+" --------------------------------------------\nCalling now...\n");try{s=t(a,i,l)}catch(c){throw o.log(`-----[Exception]-----\nException is${L.Object(c)?"":" NOT"} a LISP Object.\n`+(L.Object(c)?g(c,{maxdepth:20}):`${c}`)+"\n-----------------------"),c}return o.log(`-----[Return]-----\nReturn value is ${L.Object(s)?"":"NOT"} a LISP Object.\n`+(L.Object(s)?g(s,{maxdepth:20}):`${s}`)+"\n-----------------------"),s},isMacro:n,hidden:a}},ne=(e,r)=>e.length===r.length&&e.every(((e,t)=>e===r[t])),ae=e=>{var r,t;if(L.List(e)){if(L.Null(e))return[[],null];{const[t,n]=G(e);return V.Symbols(t),L.Null(n)||V.Symbol(n),[t.map((e=>{var r;return{name:null!=(r=e[3])?r:e[1]}})),L.Null(n)?null:{name:null!=(r=n[3])?r:n[1],type:"variadic"}]}}return V.Symbol(e),[[],{name:null!=(t=e[3])?t:e[1],type:"variadic"}]},oe=(e,r)=>{const t=new Set,n=new Set,a=e=>{var o,i;if(e instanceof Array&&e[0]===r){const e=new Error(`ReferenceTag "${r}" is already contained in the value.`);throw e.name="reference-tag",e}if("object"!=typeof e||null===e){if("number"!=typeof e||!Number.isNaN(e)&&Number.isFinite(e)){if(null===e||"boolean"==typeof e||"string"==typeof e||"number"==typeof e)return;throw new Error(`Unserializable object: <${typeof e}>`)}throw new Error("JSON can't contain Infinite/-Infinite/NaN")}{const r=null==(o=e.constructor)?void 0:o.name;if("Object"!==r&&"Array"!==r)throw new Error(`Unserializable object: <${typeof e} ${null==(i=e.constructor)?void 0:i.name}>`);t.has(e)?n.has(e)||n.add(e):(t.add(e),Object.keys(e).forEach((r=>a(e[r]))))}};a(e),t.clear();const o=new Map,i=(e,t=!1)=>!t&&o.has(e)?[r,o.get(e)]:!t&&n.has(e)?(o.set(e,o.size+1),[r,o.get(e),i(e,!0)]):e instanceof Array?e.map((e=>i(e))):"object"==typeof e&&null!==e?Object.keys(e).reduce(((r,t)=>(r[t]=i(e[t]),r)),{}):e,l=i(e);return n.clear(),o.clear(),JSON.stringify(l)},ie=(e,r)=>{const t=JSON.parse(e),n=new Map,a=e=>{e instanceof Array&&e[0]===r&&e.length>=3?(n.set(e[1],e[2]),Object.keys(e[2]).forEach((r=>a(e[2][r])))):"object"==typeof e&&null!==e&&Object.keys(e).forEach((r=>a(e[r])))};a(t);const o=e=>{if(e instanceof Array&&e[0]===r&&n.has(e[1])){if(e.length>=3){const r=e[2];if(r instanceof Array)return r.splice(0,r.length,...r.map((e=>o(e)))),r;{const e=Object.keys(r).reduce(((e,t)=>(e[t]=o(r[t]),e)),{});return Object.assign(r,e)}}return n.get(e[1])}return e instanceof Array?e.map((e=>o(e))):"object"==typeof e&&null!==e?Object.keys(e).reduce(((r,t)=>(r[t]=o(e[t]),r)),{}):e};return o(t)},le={"µ":"μ","ͅ":"ι","ς":"σ","ϐ":"β","ϑ":"θ","ϕ":"φ","ϖ":"π","ϰ":"κ","ϱ":"ρ","ϵ":"ε","ᏸ":"Ᏸ","ᏹ":"Ᏹ","ᏺ":"Ᏺ","ᏻ":"Ᏻ","ᏼ":"Ᏼ","ᏽ":"Ᏽ","ᲀ":"в","ᲁ":"д","ᲂ":"о","ᲃ":"с","ᲄ":"т","ᲅ":"т","ᲆ":"ъ","ᲇ":"ѣ","ᲈ":"ꙋ","ẛ":"ṡ","ι":"ι","ꭰ":"Ꭰ","ꭱ":"Ꭱ","ꭲ":"Ꭲ","ꭳ":"Ꭳ","ꭴ":"Ꭴ","ꭵ":"Ꭵ","ꭶ":"Ꭶ","ꭷ":"Ꭷ","ꭸ":"Ꭸ","ꭹ":"Ꭹ","ꭺ":"Ꭺ","ꭻ":"Ꭻ","ꭼ":"Ꭼ","ꭽ":"Ꭽ","ꭾ":"Ꭾ","ꮀ":"Ꮀ","ꮁ":"Ꮁ","ꮂ":"Ꮂ","ꮃ":"Ꮃ","ꮄ":"Ꮄ","ꮅ":"Ꮅ","ꮆ":"Ꮆ","ꮇ":"Ꮇ","ꮈ":"Ꮈ","ꮉ":"Ꮉ","ꮊ":"Ꮊ","ꮋ":"Ꮋ","ꮌ":"Ꮌ","ꮍ":"Ꮍ","ꮎ":"Ꮎ","ꮐ":"Ꮐ","ꮑ":"Ꮑ","ꮒ":"Ꮒ","ꮓ":"Ꮓ","ꮔ":"Ꮔ","ꮕ":"Ꮕ","ꮖ":"Ꮖ","ꮗ":"Ꮗ","ꮘ":"Ꮘ","ꮙ":"Ꮙ","ꮚ":"Ꮚ","ꮛ":"Ꮛ","ꮜ":"Ꮜ","ꮝ":"Ꮝ","ꮞ":"Ꮞ","ꮠ":"Ꮠ","ꮡ":"Ꮡ","ꮢ":"Ꮢ","ꮣ":"Ꮣ","ꮤ":"Ꮤ","ꮥ":"Ꮥ","ꮦ":"Ꮦ","ꮧ":"Ꮧ","ꮨ":"Ꮨ","ꮩ":"Ꮩ","ꮪ":"Ꮪ","ꮫ":"Ꮫ","ꮬ":"Ꮬ","ꮭ":"Ꮭ","ꮮ":"Ꮮ","ꮰ":"Ꮰ","ꮱ":"Ꮱ","ꮲ":"Ꮲ","ꮳ":"Ꮳ","ꮴ":"Ꮴ","ꮵ":"Ꮵ","ꮶ":"Ꮶ","ꮷ":"Ꮷ","ꮸ":"Ꮸ","ꮹ":"Ꮹ","ꮺ":"Ꮺ","ꮻ":"Ꮻ","ꮼ":"Ꮼ","ꮽ":"Ꮽ","ꮾ":"Ꮾ"},se=new RegExp("["+Object.keys(le).join("")+"]","gu"),ce=e=>e.replace(se,(e=>le[e])).toLowerCase(),ue=new RegExp("(?:"+[/\s+/.source,/;[^\n]*(?:\n|$)/.source,/(?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+/.source,/\|(?:[^|\\]|\n|\\(?:.|\n))+\|/.source,/#!(?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+/.source,/"(?:[^"\\]|\n|\\(?:.|\n))*"/.source,/(?:[()[\]{}'`]|,(?!@)|,@)/.source,/#(?:t(?:rue)?|f(?:alse)?|\(|u8\(|\d+[#=]|;)/.source,/#[dDbBoOxXeEiI](?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+/.source,/#\\(?:(?:[^A-Za-z]|\n)|[A-Za-z](?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])*)/.source,Array(16).fill(/#\|(?:[^|#]|\|[^#]|#[^|]|\n|(?:NEST))*\|#/.source).reduce(((e,r)=>e.replace("NEST",r)))].join("|")+")","y"),me={a:"",b:"\b",t:"\t",n:"\n",r:"\r"},de={alarm:"",backspace:"\b",delete:"",escape:"",newline:"\n",null:"\0",return:"\r",space:" ",tab:"\t"},pe=(e,r)=>{var t;const n=(e=>{const r=[0],t=/\n/g;for(let n;n=t.exec(e);)r.push(n.index+1);return t=>{var n;const a=r.filter((e=>e<=t)).slice(-1)[0],o=e.slice(a,t);return[r.indexOf(a)+1,o.length+(null!=(n=o.match(/[^\x01-\x7E\xA1-\xDF]/g))?n:[]).length+1]}})(e),a=[];ue.lastIndex=0;let o=!1;for(;ue.lastIndex<e.length;){const i=ue.lastIndex,[l,s]=n(i),c=r?{filename:r,line:l,column:s}:{line:l,column:s};let[u]=null!=(t=ue.exec(e))?t:[];if(null==u){const r=e.slice(i).split(/(\s|\n)+/,2)[0]||e[i],t=r.length>10?r.slice(0,10)+"...":r;throw new Error(`Tokenize failed. Unexpected token is: "${t}": ${JSON.stringify(c)}`)}"#!fold-case"!==u&&"#!no-fold-case"!==u?(o&&(u.match(/^(?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+$/)||u.match(/#\\(?:(?:[^A-Za-z]|\n)|[A-Za-z](?:[A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])*)/))&&(u=ce(u)),a.push([u,c])):o=!u.includes("#!no-")}return a},fe=e=>{const r=e.filter((e=>!e[0].match(/^(\s|;|#\||#!(no-)?fold-case)/))),t=()=>{const e=[];for(let n=r.shift();n;n=r.shift()){const[r,a]=n;if(!r.match(/^(\s|;|#\|)/))if("("===r)e.push(t().concat(a));else if(["#(","#u8("].includes(r))e.push([r.slice(0,-1),t(),a]);else{if(["'","`",",",",@","#;"].includes(r)||r.match(/^#\d+=$/)){const n=t(),o=n.shift();if(null==o)throw`Unexpected end of source after quoting/datum label "${r}": ${JSON.stringify(a)}`;return"#;"!==r&&e.push([r,o]),e.push(...n),e}if(")"===r)return e;e.push(r)}}return e};return[t(),r]},be=(e,r=null,t,n=new Map)=>{var a;if("string"==typeof e){let t;if(t=/^([+-])(nan|inf)\.0$/i.exec(e))return A.Number(t[0].toLowerCase());if(t=/^(?:#d)?[-+]?\d+(?:\.\d*)?(?:e[-+]?\d+)?$/i.exec(e))return w(Number(e.replace(/^(#d)?0*/i,"")));if(t=/^(?:#b[-+]?[01]+|#o[-+]?[0-7]+|#x[-+]?[0-9A-Fa-f]+)/i.exec(e))return w(Number(e.replace(/^#([xob])([+-]?)/i,"0$1"))*(e.includes("-")?-1:1));if(/^#[dboxei]/i.exec(e))throw new Error(`Unsupported type of number literal: ${e}: ${JSON.stringify(r)}`);if(t=/^"((?:.|\n)*)"$/.exec(e)){const e=t[1].replace(/\\(x[0-9a-fA-F]+;|[ \t]*\n[ \t]*|[^x \t\n])/g,(e=>{var r;return"x"===e[1]?String.fromCodePoint(Number(`0x${e.replace(/;$/,"").slice(2)}`)):/\s|\n/.test(e[1])?"":null!=(r=me[e[1]])?r:e[1]}));return A.String(e,!0)}if(t=/^#([tf])/.exec(e))return A.Boolean("t"===t[1]);if(t=/^#\\((.|\n)*)$/.exec(e)){const e=1===t[1].length?t[1]:t[1].match(/^x[0-9A-Fa-f]+$/)?String.fromCodePoint(Number(`0x${t[1].slice(1)}`)):de[t[1]];if(!e)throw new Error(`Illegal character literal: ${e}: ${JSON.stringify(r)}`);return A.Character(e)}if("."!==e&&(t=/^(([A-Za-z0-9]|[^\x00-\x7f]|[!$%&*+\-./:<=>?@^_~])+)$/.exec(e)))return A.Symbol(t[1]);if("."!==e&&(t=/^\|(([^\\]|\n|\\(.|\n))+)\|$/.exec(e))){const e=t[1].replace(/\\(x[0-9a-fA-F]+;|\s*\n\s*|[^x\s\n])/g,(e=>{var r;return"x"===e[1]?String.fromCodePoint(Number(`0x${e.replace(/;$/,"").slice(2)}`)):/\s|\n/.test(e[1])?"":null!=(r=me[e[1]])?r:e[1]}));return A.Symbol(e)}if(t=/^#(\d+)#$/.exec(e)){const a=t[1];if(!n.has(a))throw new Error(`Invalid datum reference (${e}): ${JSON.stringify(r)}`);return n.get(a)}throw new Error(`Parse error: unexpected token: "${e}": ${JSON.stringify(r)}`)}if(e instanceof Array&&"&"!==e[0]){r=null!=(a=e.find((e=>q(e))))?a:r;const o=e.filter((e=>!q(e)));if(0===o.length)return A.Null();if(2===o.length&&"."===o[0])return be(o[1],r,t,n);if("#"===o[0]){if(2!==o.length)throw new Error(`Illegal vector literal. No datum: ${JSON.stringify(r)}`);if(!(o[1]instanceof Array))throw new Error(`Illegal vector literal. Datum is not an array: ${JSON.stringify(r)}`);return A.Vector(o[1].map((e=>be(e,r,t,n))),!0)}if("#u8"===o[0]){if(2!==o.length)throw new Error(`Illegal byte vector literal. No datum: ${JSON.stringify(r)}`);if(!(o[1]instanceof Array))throw new Error(`Illegal byte vector literal. Byte vector must have an array: ${JSON.stringify(r)}`);const e=o[1].map((e=>be(e,r,t,n)));if(!e.every((e=>L.RealNumber(e)&&Number.isInteger(e[1])&&e[1]>=0&&e[1]<=255)))throw new Error(`Illegal byte vector literal. All the contents of a byte vector must be 0-255.: ${JSON.stringify(r)}`);return A.ByteVector(e.map(S),!0)}if("string"==typeof o[0]&&["'","`",",",",@"].includes(o[0])){if(2!==o.length)throw new Error(`Illegal quote "${o[0]}". Quoted item must be a datum: ${JSON.stringify(r)}`);const e={"'":"quote","`":"quasiquote",",":"unquote",",@":"unquote-splicing"}[o[0]];return A.Pair(A.Symbol(e),A.Pair(be(o[1],r,t,n),A.Null(),!0),!0,(null==t?void 0:t.removeLineInfo)?null:r)}if("string"==typeof o[0]&&/^#(\d+)=$/.exec(o[0])){const[,e]=/^#(\d+)=$/.exec(o[0]);if(2!==o.length)throw new Error(`Illegal datum label. No next datum: ${JSON.stringify(r)}`);const a=A.Symbol(o[0]);n.set(e,a);const i=be(o[1],r,t,n);return a.splice(0,a.length,...i),a}if((null==t?void 0:t.extended)&&L.Object(e))return e;if((null==t?void 0:t.extended)&&"&"===e[0]){if(2!=e.length)throw new Error(`Parse error: JS Node must be like ["&", <object>]: ${typeof e} value: ${e}`);return A.JS("inline",e[1])}return A.Pair(be(o[0],r,t,n),be(o.slice(1),r,t,n),!0,(null==t?void 0:t.removeLineInfo)?null:r)}if((null==t?void 0:t.extended)&&null===e)return A.Null();if((null==t?void 0:t.extended)&&"number"==typeof e)return w(e);if((null==t?void 0:t.extended)&&"boolean"==typeof e)return A.Boolean(e);throw new Error(`Parse error: unexpected node type: ${typeof e} value: ${e}`)},ye=(e,r=null,t)=>be(e,r,s(l({},null!=t?t:{}),{extended:!0})),he=(e,r)=>{const t=pe(e,null==r?void 0:r.filename),[n,a]=fe(t);if(a.length>0)throw new Error(`Parse error: extra tokens. (missing right curly?), ${JSON.stringify(a[0][1])}`);return be(["begin",...n],null,r)},ge=ee("not",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.False(e))))),ve=ee("boolean?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.Boolean(e))))),Se=ee("boolean=?",[{name:"boolean1"},{name:"boolean2"},{name:"booleans",type:"variadic"}],(({boolean1:e,boolean2:r,booleans:t})=>(V.Boolean(e),V.Boolean(r),V.Booleans(t),A.Boolean([r,...t].every((r=>r[1]===e[1])))))),we={not:ge,booleanQ:ve,booleanEQ:Se},je=ee("bytevector?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.ByteVector(e))))),xe=ee("make-bytevector",[{name:"k"},{name:"byte",type:"optional"}],(({k:e,byte:r})=>(V.IntegerNumber(e),r&&V.IntegerNumber(r),A.ByteVector(Array(e[1]).fill(r?r[1]:0),!1)))),Pe=ee("bytevector",[{name:"bytes",type:"variadic"}],(({bytes:e})=>(V.IntegerNumbers(e),A.ByteVector(e.map((e=>e[1])),!1)))),Ee=ee("bytevector-length",[{name:"bvec"}],(({bvec:e})=>(V.ByteVector(e),A.Number(e[1].length)))),Ne=ee("bytevector-u8-ref",[{name:"bvec"},{name:"k"}],(({bvec:e,k:r})=>{if(V.ByteVector(e),V.IntegerNumber(r),!(r[1]in e[1]))throw A.Error("out-of-range","Index is out of range.");return A.Number(e[1][r[1]])})),Ie=ee("bytevector-u8-set!",[{name:"bvec"},{name:"k"},{name:"byte"}],(({bvec:e,k:r,byte:t})=>{if(V.ByteVector(e),V.IntegerNumber(r),V.IntegerNumber(t),!(r[1]in e[1]))throw A.Error("out-of-range","Index is out of range.");return e[1][r[1]]=t[1],["<undefined>"]})),Be=ee("bytevector-copy",[{name:"bvec"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({bvec:e,start:r,end:t})=>{V.ByteVector(e);const n=e[1];if(0===n.length)return A.ByteVector([],!1);const a=L.Number(r)?r[1]:0,o=L.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw A.Error("domain-error","Index must be integer.");return A.ByteVector(n.slice(a,o),!1)})),Oe=ee("bytevector-copy!",[{name:"to"},{name:"at"},{name:"from"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({to:e,at:r,from:t,start:n,end:a})=>{V.ByteVector(e),V.IntegerNumber(r),V.ByteVector(t);const o=L.Number(n)?n[1]:0,i=L.Number(a)?a[1]:t[1].length;if("number"!=typeof o||!Number.isInteger(o)||"number"!=typeof i||!Number.isInteger(i))throw A.Error("domain-error","Index must be integer.");if(!(r[1]in e[1]))throw A.Error("out-of-range","Index is out of range.");if(e[1].length-r[1]<i-o)throw A.Error("out-of-range","Index is out of range.");const l=t[1].slice(o,i);return e[1].splice(r[1],l.length,...l),["<undefined>"]})),Ce=ee("bytevector-append",[{name:"vecs",type:"variadic"}],(({vecs:e})=>(V.ByteVectors(e),A.ByteVector(e.map((e=>e[1])).flat(),!1)))),Ae=ee("utf8->string",[{name:"bvec"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({bvec:e,start:r,end:t})=>{V.ByteVector(e);const n=e[1],a=L.Number(r)?r[1]:0,o=L.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw A.Error("domain-error","Index must be integer.");const i=new Uint8Array(n.slice(a,o));return A.String((new TextDecoder).decode(i),!1)})),$e=ee("string->utf8",[{name:"str"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,start:r,end:t})=>{V.String(e);const n=Array.from(e[1]),a=L.Number(r)?r[1]:0,o=L.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw A.Error("domain-error","Index must be integer.");const i=(new TextEncoder).encode(n.slice(a,o).join(""));return A.ByteVector(Array.from(i),!1)})),Le={bytevectorQ:je,makeBytevector:xe,bytevector:Pe,bytevectorLength:Ee,bytevectorU8Ref:Ne,bytevectorU8SetD:Ie,bytevectorCopy:Be,bytevectorCopyD:Oe,bytevectorAppend:Ce,utf8ToString:Ae,stringToUtf8:$e},ke=ee("char?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.Character(e))))),ze=ee("char=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>(V.Character(e),V.Character(r),V.Characters(t),A.Boolean([r,...t].every((r=>r[1]===e[1])))))),Ve=ee("char<?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{V.Character(e),V.Character(r),V.Characters(t);const n=[e,r,...t].map((e=>e[1]));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]<e)))})),Me=ee("char>?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{V.Character(e),V.Character(r),V.Characters(t);const n=[e,r,...t].map((e=>e[1]));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]>e)))})),qe=ee("char<=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{V.Character(e),V.Character(r),V.Characters(t);const n=[e,r,...t].map((e=>e[1]));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]<=e)))})),Te=ee("char>=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{V.Character(e),V.Character(r),V.Characters(t);const n=[e,r,...t].map((e=>e[1]));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]>=e)))})),De=ee("char->integer",[{name:"char"}],(({char:e})=>{V.Character(e);const r=e[1].codePointAt(0);if(void 0===r)throw A.Error("out-of-range","Can't convert character to codepoint.");return A.Number(r)})),Re=ee("integer->char",[{name:"n"}],(({n:e})=>(V.IntegerNumber(e),A.Character(String.fromCodePoint(e[1]))))),Qe={charQ:ke,charEQ:ze,charLtQ:Ve,charGtQ:Me,charLeQ:qe,charGeQ:Te,charToInteger:De,integerToChar:Re},Ue=ee("procedure?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.Procedure(e)))),!0),Fe=ee("apply",[{name:"proc"},{name:"args",type:"variadic"}],(({proc:e,args:r},t,n)=>{let a;if(V.Procedure(e),V.Objects(r),M(t),M(n),0===r.length)a=[];else{const[e,t]=[r.slice(0,r.length-1),r[r.length-1]];V.List(t),a=[...e,...W(t)]}return $.Call(e,A.MultiValue(a))}),!0),Je=ee("map",[{name:"proc"},{name:"list1"},{name:"lists",type:"variadic"}],(({proc:e,list1:r,lists:t})=>{V.Procedure(e),V.List(r),V.Lists(t);const n=[r,...t];return n.every((e=>L.Pair(e)))?$.Cons($.Call(e,A.MultiValue(n.map((e=>e[1])))),$.CallBuiltIn("map",A.MultiValue([e,...n.map((e=>e[2]))]))):$.Quote(["<null>"])}),!0),_e=ee("string-map",[{name:"proc"},{name:"str1"},{name:"strs",type:"variadic"}],(({proc:e,str1:r,strs:t})=>{V.Procedure(e),V.String(r),V.Strings(t);const n=[Array.from(r[1]),...t.map((e=>Array.from(e[1])))];return n.every((e=>e.length>1))?$.CallBuiltIn("string-append",$.CallBuiltIn("string",$.Call(e,...n.map((e=>A.Character(e[0]))))),$.CallBuiltIn("string-map",e,...n.map((e=>A.String(e.slice(1).join(""),!1))))):n.every((e=>e.length>=1))?$.CallBuiltIn("string",$.Call(e,...n.map((e=>A.Character(e[0]))))):A.String("",!1)}),!0),Xe=ee("vector-map",[{name:"proc"},{name:"vector1"},{name:"vectors",type:"variadic"}],(({proc:e,vector1:r,vectors:t})=>{V.Procedure(e),V.Vector(r),V.Vectors(t);const n=[r,...t];return n.every((e=>e[1].length>1))?$.CallBuiltIn("vector-append",$.CallBuiltIn("vector",$.Call(e,A.MultiValue(n.map((e=>e[1][0]))))),$.CallBuiltIn("vector-map",e,...n.map((e=>A.Vector(e[1].slice(1),!1))))):n.every((e=>e[1].length>=1))?$.CallBuiltIn("vector",$.Call(e,A.MultiValue(n.map((e=>e[1][0]))))):A.Vector([],!1)}),!0),Ze=ee("for-each",[{name:"proc"},{name:"list1"},{name:"lists",type:"variadic"}],(({proc:e,list1:r,lists:t})=>{V.Procedure(e),V.List(r),V.Lists(t);const n=[r,...t];return n.every((e=>L.Pair(e)))?$.Begin($.Call(e,A.MultiValue(n.map((e=>e[1])))),$.CallBuiltIn("for-each",A.MultiValue([e,...n.map((e=>e[2]))]))):["<undefined>"]}),!0),Ke=ee("string-for-each",[{name:"proc"},{name:"str1"},{name:"strs",type:"variadic"}],(({proc:e,str1:r,strs:t})=>{V.Procedure(e),V.String(r),V.Strings(t);const n=[Array.from(r[1]),...t.map((e=>Array.from(e[1])))];return n.every((e=>e.length>1))?$.Begin($.Call(e,...n.map((e=>A.Character(e[0])))),$.CallBuiltIn("string-for-each",e,...n.map((e=>A.String(e.slice(1).join(""),!1))))):n.every((e=>e.length>=1))?$.Call(e,...n.map((e=>A.Character(e[0])))):["<undefined>"]}),!0),We=ee("vector-for-each",[{name:"proc"},{name:"vector1"},{name:"vectors",type:"variadic"}],(({proc:e,vector1:r,vectors:t})=>{V.Procedure(e),V.Vector(r),V.Vectors(t);const n=[r,...t];return n.every((e=>e[1].length>1))?$.Begin($.Call(e,A.MultiValue(n.map((e=>e[1][0])))),$.CallBuiltIn("vector-for-each",e,...n.map((e=>A.Vector(e[1].slice(1),!1))))):n.every((e=>e[1].length>=1))?$.Call(e,A.MultiValue(n.map((e=>e[1][0])))):$.Quote(["<null>"])}),!0),Ge=ee("call-with-current-continuation",[{name:"proc"}],(({proc:e},r,t)=>(V.Procedure(e),M(t),$.Call(e,A.Continuation(P(t))))),!0),He=re("call/cc",Ge),Ye=ee("values",[{name:"objs",type:"variadic"}],(({objs:e})=>(V.Objects(e),1===e.length?e[0]:A.MultiValue(e)))),er=ee("call-with-values",[{name:"producer"},{name:"consumer"}],(({producer:e,consumer:r},t,n)=>{V.Procedure(e),V.Procedure(r),M(n);const a=O(n,A.List(r),{want:"args",oper:r});return B(a,A.List(e))})),rr=ee("dynamic-wind",[{name:"before"},{name:"thunk"},{name:"after"}],(({before:e,thunk:r,after:t},n,a)=>{V.Procedure(e),V.Procedure(r),V.Procedure(t),M(a);const o=A.Continuation(P(a));return B(a,$.Begin($.Call(e),$.Call(o,$.Call(r))),{before:e,after:t})})),tr={procedureQ:Ue,apply:Fe,map:Je,stringMap:_e,vectorMap:Xe,forEach:Ze,stringForEach:Ke,vectorForEach:We,callWithCurrentContinuation:Ge,callCC:He,values:Ye,callWithValues:er,dynamicWind:rr},nr=ee("eqv?",[{name:"obj1"},{name:"obj2"}],(({obj1:e,obj2:r})=>{V.Object(e),V.Object(r);const t=e=>L.String(e)||L.ByteVector(e)||L.Vector(e)?e.slice(0,e.length-1):L.Pair(e)?e.slice(0,3):L.Symbol(e)?e.slice(0,2):e;return A.Boolean(e===r||ne(t(e),t(r)))})),ar=re("eq?",nr),or=ee("equal?",[{name:"obj1"},{name:"obj2"}],(({obj1:e,obj2:r})=>{V.Object(e),V.Object(r);const t=(e,r)=>e===r||(L.Pair(e)&&L.Pair(r)?t(e[1],r[1])&&t(e[2],r[2]):L.Vector(e)&&L.Vector(r)?e[1]===r[1]||e[1].length===r[1].length&&e[1].every(((e,n)=>t(e,r[1][n]))):L.ByteVector(e)&&L.ByteVector(r)?ne(e[1],r[1]):nr.body({obj1:e,obj2:r})[1]);return A.Boolean(t(e,r))})),ir={eqvQ:nr,eqQ:ar,equalQ:or},lr=ee("with-exception-handler",[{name:"handler"},{name:"thunk"}],(({handler:e,thunk:r},t,n)=>(V.Procedure(e),V.Procedure(r),M(n),O(n,$.Call(r),{handler:A.HandlerStack(e,N(n).handler)})))),sr=ee("raise",[{name:"obj"}],(({obj:e},r,t)=>{throw V.Object(e),M(t),A.Exception(t,e,!1)})),cr=ee("raise-continuable",[{name:"obj"}],(({obj:e},r,t)=>{throw V.Object(e),M(t),A.Exception(t,e,!0)})),ur=ee("error",[{name:"message"},{name:"objs",type:"variadic"}],(({message:e,objs:r},t,n)=>{throw V.String(e),V.Objects(r),M(n),A.Exception(n,A.Error("error",e[1],r),!0)})),mr=ee("error-object?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.Error(e))))),dr=ee("error-object-message",[{name:"err"}],(({err:e})=>{var r;return V.Error(e),A.String(null!=(r=e[2])?r:e[1],!1)})),pr=ee("error-object-irritants",[{name:"err"}],(({err:e})=>(V.Error(e),A.List(...e[3])))),fr=ee("read-error?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.Error(e)&&"read-error"===e[1])))),br=ee("file-error?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.Error(e)&&"file-error"===e[1])))),yr={withExceptionHandler:lr,raise:sr,raiseContinuable:cr,error:ur,errorObjectQ:mr,errorObjectMessage:dr,errorObjectIrritants:pr,readErrorQ:fr,fileErrorQ:br},hr=ee("suspend",[{name:"obj",type:"optional"}],(({obj:e},r,t)=>{throw M(t),e&&V.Object(e),A.Suspend(A.Continuation(P(t)),null!=e?e:A.Undefined())})),gr=ee("read-file",[{name:"filename"},{name:"cli",type:"optional"}],(({filename:e,cli:r},t)=>{if(M(t),V.String(e),r&&V.Boolean(r),!(null==t?void 0:t.fs))throw A.Error("program-error",'No interpreter object or No Node.js "fs" object set on Interpreter.');let n,a;try{n=t.fs.readFileSync(e[1]).toString()}catch{throw A.Error("read-error",`Can't read file from ${e[1]}.`)}try{a=he(r&&r[1]?"#!fold-case "+n:n,{filename:e[1]})}catch(o){throw o instanceof Error?A.Error("read-error",o.message):A.Error("read-error","Error occured while reading.")}return a}),!1,!0),vr={suspend:hr,readFile:gr},Sr=ee("features",[],(()=>A.List(A.Symbol("r7rs"),A.Symbol(u),A.Symbol(u+"-0.6.0")))),wr={features:Sr},jr=ee("quote",[{name:"value",evaluate:!1}],(({value:e})=>(V.Object(e),e))),xr=ee("lambda",[{name:"formals",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({formals:e,body:r},t,n)=>{V.Object(e),V.Objects(r),M(n);const[a,o]=ae(e);return A.Procedure("lambda",o?[...a,o]:a,$.BeginIfMultiple(...r),!1,N(n).env)})),Pr=ee("if",[{name:"test"},{name:"consequent",evaluate:!1},{name:"alternate",type:"optional",evaluate:!1}],(({test:e,consequent:r,alternate:t})=>(V.Object(e),V.Object(r),L.False(e)?t?(V.Object(t),t):["<undefined>"]:r)),!0),Er=ee("set!",[{name:"variable",evaluate:!1},{name:"expr"}],(({variable:e,expr:r},t,n)=>{if(M(t),M(n),V.Symbol(e),V.Object(r),L.Undefined(r))throw A.Error("undefined-variable",`Attempt to set undefined value to a variable "${e[1]}"`);if(!t.setStatic(N(n).env.static,e,r))throw A.Error("unbound-variable",`Attempt to set value to an unbound variable "${e[1]}"`);return["<undefined>"]})),Nr=ee("include",[{name:"str1"},{name:"strs",type:"variadic"}],(({str1:e,strs:r},t,n)=>{M(t),M(n),V.String(e),V.Strings(r);const a=[e,...r].map((e=>gr.body({filename:e},t)));return 1===a.length?a[0]:$.Begin(...a)}),!0),Ir=ee("include-cli",[{name:"str1"},{name:"strs",type:"variadic"}],(({str1:e,strs:r},t,n)=>{M(t),M(n),V.String(e),V.Strings(r);const a=[e,...r].map((e=>gr.body({filename:e,cli:A.Boolean(!0)},t)));return 1===a.length?a[0]:$.Begin(...a)}),!0),Br=ee("cond",[{name:"clause",evaluate:!1},{name:"clauses",type:"variadic",evaluate:!1}],(({clause:e,clauses:r})=>{V.Pair(e),V.Pairs(r);const t=0===r.length?["<undefined>"]:$.Cond(r[0],...r.splice(1)),[n,a,...o]=W(e);if(L.Symbol(n)&&"else"===n[1])return $.BeginIfMultiple(a,...o);if(a){if(L.Symbol(a)&&"=>"===a[1]){if(1!==o.length)throw A.Error("syntax-error","Illegal cond syntax (test => expression).");const e=A.Symbol(Y());return $.Let([[e,n]],$.If(e,$.Call(o[0],e),t))}return $.If(n,$.BeginIfMultiple(a,...o),t)}return $.Or(n,t)}),!0),Or=ee("case",[{name:"key"},{name:"clauses",type:"variadic",evaluate:!1}],(({key:e,clauses:r})=>{V.Object(e),V.Pairs(r);const t=r.find(((t,n)=>{if(L.Symbol(t[1])&&"else"===t[1][1]){if(n!==r.length-1)throw A.Error("syntax-error","Illegal case syntax (else placement).");return!0}return V.Pair(t[1]),W(t[1]).some((r=>nr.body({obj1:r,obj2:e})[1]))}));if(t){const[,r,...n]=W(t);if(r){if(L.Symbol(r)&&"=>"===r[1]){if(1!==n.length)throw A.Error("syntax-error","Illegal cond syntax (test => expression).");return $.Call(n[0],A.MultiValue([e]))}return $.BeginIfMultiple(r,...n)}throw A.Error("syntax-error","Illegal cond syntax (short clause).")}return["<undefined>"]}),!0),Cr=ee("and",[{name:"first",type:"optional"},{name:"rest",type:"variadic",evaluate:!1}],(({first:e,rest:r})=>e?(V.Object(e),V.Objects(r),0===r.length||L.False(e)?$.Quote(e):$.And(...r)):A.Boolean(!0)),!0),Ar=ee("or",[{name:"first",type:"optional"},{name:"rest",type:"variadic",evaluate:!1}],(({first:e,rest:r})=>e?(V.Object(e),V.Objects(r),0!==r.length&&L.False(e)?$.Or(...r):$.Quote(e)):A.Boolean(!1)),!0),$r=ee("when",[{name:"test"},{name:"expr",evaluate:!1},{name:"exprs",type:"variadic",evaluate:!1}],(({test:e,expr:r,exprs:t})=>(V.Object(e),V.Object(r),V.Objects(t),L.False(e)?["<undefined>"]:$.BeginIfMultiple(r,...t))),!0),Lr=ee("unless",[{name:"test"},{name:"expr",evaluate:!1},{name:"exprs",type:"variadic",evaluate:!1}],(({test:e,expr:r,exprs:t})=>(V.Object(e),V.Object(r),V.Objects(t),L.False(e)?$.BeginIfMultiple(r,...t):["<undefined>"])),!0),kr=ee("cond-expand",[{name:"clause1",evaluate:!1},{name:"clauses",type:"variadic",evaluate:!1}],(({clause1:e,clauses:r},t,n)=>{V.Pair(e),V.Pairs(r),M(t),M(n);const a=[e,...r],o=W(Sr.body()),i=e=>{if(L.Symbol(e))return o.some((r=>L.Symbol(r)&&r[1]===e[1]));if(L.Pair(e)){const[,r,a]=e;if(L.Symbol(r)&&L.List(a)){if("and"===r[1])return W(a).every((e=>i(e)));if("or"===r[1])return W(a).some((e=>i(e)));if("not"===r[1]){if(L.Pair(a))return!i(a[1])}else if("library"===r[1]&&L.Pair(a)){const e=g(a[1]);if(t.getBuiltInLibrary(e))return!0;{const r=t.getStatic(N(n).env.static,A.Symbol(e));return L.Library(r)}}}}return!1},l=a.find((e=>i(e[1])));return l?A.Pair(A.Procedure("built-in","begin"),l[2]):A.Undefined()}),!0),zr=ee("let",[{name:"args",type:"variadic",evaluate:!1}],(({args:e},r,t)=>{V.Objects(e);const[n,a,...o]=L.Symbol(e[0])?e:[null,...e];V.List(a),V.Objects(o),M(t);const i=W(a).map((e=>{V.Pair(e),V.Symbol(e[1]),V.Pair(e[2]);const[,r,[,t]]=e;return[r,t]})),l=i.map((([e])=>e)),s=i.map((([,e])=>e)),c=$.Lambda(l,null,...o);return n?(V.Symbol(n),$.CallThunk($.Define(n,c),$.Call(n,...s))):$.Call(c,...s)}),!0),Vr=ee("let*",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{if(V.List(e),V.Objects(r),M(n),L.Pair(e)){V.Pair(e[1]),V.Pair(e[1][2]);const[,[,t,[,n]],a]=e;return V.Symbol(t),$.Call($.Lambda([t],null,$.CallBuiltIn("let*",a,...r)),n)}return $.BeginIfMultiple(...r)}),!0),Mr=ee("letrec",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{V.List(e),V.Objects(r),M(t),M(n);const a=W(e).map((e=>{V.Pair(e),V.Symbol(e[1]),V.Pair(e[2]);const[,r,[,t]]=e;return[r,t]})),{static:o,dynamic:i}=N(n).env,l=C(o);return a.forEach((([e])=>t.defineStatic(l,e,["<undefined>"]))),$.Call(A.Procedure("lambda",[],$.Begin($.DefineValues(a.map((([e])=>e)),$.Values(...a.map((([,e])=>e)))),...r),!1,{static:l,dynamic:i}))}),!0),qr=ee("letrec*",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{V.List(e),V.Objects(r),M(t),M(n);const a=W(e).map((e=>{V.Pair(e),V.Symbol(e[1]),V.Pair(e[2]);const[,r,[,t]]=e;return[r,t]})),{static:o,dynamic:i}=N(n).env,l=C(o);return a.forEach((([e])=>t.defineStatic(l,e,["<undefined>"]))),$.Call(A.Procedure("lambda",[],$.Begin(...a.map((([e,r])=>$.Set(e,r))),...r),!1,{static:l,dynamic:i}))}),!0),Tr=ee("let-values",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>(V.List(e),V.Objects(r),M(n),$.CallThunk(...W(e).map((e=>{V.Pair(e),V.Pair(e[2]);const[,r,[,t]]=e,a=A.Procedure("lambda",[],t,!1,N(n).env);return $.CallBuiltIn("define-values",r,$.Call(a))})),...r))),!0),Dr=ee("let*-values",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{if(V.List(e),V.Objects(r),M(n),L.Pair(e)){V.Pair(e[1]),V.Pair(e[1][2]);const[,[,t,[,n]],a]=e;return $.CallThunk($.CallBuiltIn("define-values",t,n),$.CallBuiltIn("let*-values",a,...r))}return $.BeginIfMultiple(...r)}),!0),Rr=ee("begin",[{name:"exprs",type:"variadic",evaluate:!0},{name:"last",type:"tail",evaluate:!1}],(({exprs:e,last:r},t,n)=>(((e,r)=>{if(!(e instanceof Array))throw A.Error("program-error",null!=r?r:"An array is expected.")})(e),V.Object(r),M(n),0===N(n).depth?B(n,r):r)),!0),Qr=ee("do",[{name:"specs",evaluate:!1},{name:"clause",evaluate:!1},{name:"commands",type:"variadic",evaluate:!1}],(({specs:e,clause:r,commands:t})=>{V.List(e),V.List(r),V.Objects(t);const n=W(e).map((e=>{V.Pair(e),V.Pair(e[2]),V.Symbol(e[1]);const[,r,[,t,n]]=e;return[r,t,L.Pair(n)?n[1]:null]})),[,a,o]=r;return V.Object(a),V.List(o),$.Let(n.map((([e,r])=>[e,r])),$.If(a,L.Null(o)?A.Undefined():$.Begin(...W(o)),$.Begin(...t,$.CallBuiltIn("do",A.List(...n.map((([e,,r])=>A.List(e,null!=r?r:e,null!=r?r:e)))),r,...t))))}),!0),Ur=ee("make-parameter",[{name:"init"},{name:"converter",type:"optional"}],(({init:e,converter:r},t,n)=>{V.Object(e),M(t),M(n);let a=Y();for(;a in N(n).env.dynamic[1];)a=Y();return r&&V.Procedure(r),t.defineDynamic(N(n).env.dynamic,a,e),A.Parameter(a,null!=r?r:null)})),Fr=ee("parameterize",[{name:"assocs",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({assocs:e,body:r},t,n)=>{V.Pair(e),V.Pairs(r),M(t),M(n);const{env:a}=N(n),o=W(e).map((e=>{V.Pair(e),V.Pair(e[2]);const[,r,[,t]]=e;return[r,t]})),i={static:a.static,dynamic:A.DynamicNS({},a.dynamic)},l=$.BeginIfMultiple(...o.map((([e,r])=>$.CallBuiltIn("define-parameter",e,r))),...r);return O(n,l,{env:i})})),Jr=ee("define-parameter",[{name:"param"},{name:"value",evaluate:!1}],(({param:e,value:r},t,n)=>{V.Parameter(e),V.Object(r),M(t),M(n);const[,,a]=e;return $.CallBuiltIn("define-parameter-1",e,a?$.Call(a,r):r)}),!0,!0),_r=ee("define-parameter-1",[{name:"param"},{name:"value"}],(({param:e,value:r},t,n)=>{var a;if(V.Parameter(e),V.Object(r),M(t),M(n),!L.Undefined(null!=(a=x(N(n).env.dynamic)[e[1]])?a:["<undefined>"]))throw A.Error("redefine-variable",null);return t.defineDynamic(N(n).env.dynamic,e[1],r),["<undefined>"]}),!1,!0),Xr=ee("guard",[{name:"arg1",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({arg1:e,body:r},t,n)=>{V.Pair(e),V.Objects(r),V.Symbol(e[1]),V.Pair(e[2]),M(n);const[,a,o]=e,i=A.Continuation(P(n)),l=A.Procedure("lambda",[{name:a[1]}],$.Call(i,$.CallBuiltIn("cond",...W(o),A.List(A.Symbol("else"),$.RaiseContinuable(a)))),!1,N(n).env);return $.CallBuiltIn("with-exception-handler",l,$.Lambda([],null,...r))}),!0),Zr=ee("quasiquote",[{name:"template",evaluate:!1}],(({template:e})=>{V.Object(e);const r=[],t=[],n=(e,a)=>{if(L.Pair(e)){const[,o,i]=e;if(L.Symbol(o)&&"quasiquote"===o[1])return A.Pair(o,n(i,a+1));if(L.Symbol(o)&&"unquote"===o[1]||"unquote-splicing"===o[1]){if(0!==a)return A.Pair(o,n(i,a-1));{const e=A.Symbol("unquote-splicing"===o[1]?"@"+Y():Y());return V.Pair(i),r.push(e),t.push(i[1]),e}}return A.Pair(n(o,a),n(i,a))}return L.Vector(e)?A.Vector(e[1].map((e=>n(e,a))),!1):e},a=n(e,0);return $.CallBuiltIn("quasiquote-1",a,A.List(...r),...t)}),!0),Kr=ee("quasiquote-1",[{name:"template",evaluate:!1},{name:"marks",evaluate:!1},{name:"exprs",type:"variadic"}],(({template:e,marks:r,exprs:t})=>{V.Object(e),V.List(r),V.Objects(t);const n=W(r);V.Symbols(n);const a=new Map;if(n.length!==t.length)throw A.Error("arity-error","quasiquote-1: marks and exprs unmatch.");n.forEach(((e,r)=>a.set(e[1],t[r])));const o=e=>{if(L.Pair(e)){const[,r,t]=e;if(L.Symbol(r)&&"@"===r[1][0]&&a.has(r[1])){const e=a.get(r[1]);if(L.List(e))return L.Null(e)?o(t):H(W(e),o(t));throw A.Error("error","unquote-splicing evaluated as non-list object.")}return A.Pair(o(r),o(t))}return L.Vector(e)?A.Vector(e[1].map((e=>{if(L.Symbol(e)&&"@"===e[1][0]&&a.has(e[1])){const r=a.get(e[1]);if(L.List(r))return L.Null(r)?[]:W(r);throw A.Error("error","unquote-splicing evaluated as non-list object.")}return[o(e)]})).flat(),!1):L.Symbol(e)&&a.has(e[1])&&"@"!==e[1][0]?a.get(e[1]):e};return o(e)}),!1,!0),Wr=ee("let-syntax",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{V.List(e,"aa"),V.Objects(r),M(n);const a=W(e).map((e=>{V.Pair(e),V.Pair(e[2]),V.Symbol(e[1]);const[,r,[,t]]=e;return[r,A.Procedure("lambda",[],t,!1,N(n).env)]}));return $.CallThunk(...a.map((([e,r])=>$.CallBuiltIn("define-syntax",e,$.Call(r)))),...r)}),!0),Gr=ee("letrec-syntax",[{name:"bindings",evaluate:!1},{name:"body",type:"variadic",evaluate:!1}],(({bindings:e,body:r},t,n)=>{V.List(e),V.Objects(r),M(t),M(n);const a=W(e).map((e=>{V.Pair(e),V.Pair(e[2]),V.Symbol(e[1]);const[,r,[,t]]=e;return[r,t]})),{static:o,dynamic:i}=N(n).env,l=C(o);return a.forEach((([e])=>t.defineStatic(l,e,["<undefined>"]))),$.Call(A.Procedure("lambda",[],$.Begin(...a.map((([e,r])=>$.CallBuiltIn("define-syntax",e,r))),...r),!1,{static:l,dynamic:i}))}),!0),Hr=(e,r,t=!0)=>{var n;const[a,o]=G(e),i=a.findIndex((e=>L.Symbol(e)&&e[1]===r)),l=t?i<0?a.slice(1):a.slice(1,i-1):i<0?a:a.slice(0,i-1),s=i<0?[]:a.slice(i+1),c=i<0?null:null!=(n=a[i-1])?n:null;return["<syntax-rule-pattern>",l.map((e=>L.Pair(e)?Hr(e,r,!1):e)),c?L.Pair(c)?Hr(c,r,!1):c:null,s.map((e=>L.Pair(e)?Hr(e,r,!1):e)),L.Null(o)?null:o]},Yr=ee("syntax-rules",[{name:"arg1",evaluate:!1},{name:"arg2",evaluate:!1},{name:"args",type:"variadic",evaluate:!1}],(({arg1:e,arg2:r,args:t},n,a)=>{V.Object(e),V.Object(r),V.Objects(t),M(n),M(a);const[o,i,l]=L.Symbol(e)?[e[1],r,t]:["...",e,[r,...t]];V.List(i);const s=W(i).map((e=>(V.Symbol(e),e[1]))),c=(e,r=new Map)=>{var t;if(L.Pair(e))return A.Pair(c(e[1],r),c(e[2],r));if(L.Symbol(e)){if(n.getStatic(N(a).env.static,e))return A.Symbol(e[1],N(a).env.static,null!=(t=e[3])?t:null);if(s.includes(e[1])||o===e[1]||"_"===e[1])return e;if(r.has(e[1]))return r.get(e[1]);{const t=A.Symbol(e[1],null,Y());return r.set(e[1],t),t}}return e};V.Pairs(l);const u=[];for(const m of l){const e=c(m);V.Pair(e),V.Pair(e[2]);const[,r,[,t]]=e;V.Pair(r);const[n,a]=G(r);if(!L.Null(a)&&n.some((e=>L.Symbol(e)&&e[1]===o)))throw A.Error("syntax-error","The root of a syntax-rules pattern with ellipsis must be a proper list.");u.push([Hr(r,o),t])}return A.SyntaxRules(o,s,u)})),et=(e,r)=>{if(L.SyntaxRulePattern(e)){const[,t,n,a,o]=e;return[...t,...n?[n]:[],...a,...o?[o]:[]].map((e=>et(e,r))).flat()}return L.Symbol(e)&&!r.includes(e[1])?"_"===e[1]?[]:[e[1]]:[]},rt=(e,r,t,n,a,o)=>{if(L.SyntaxRulePattern(e)){if(!L.List(r))return null;const[,i,l,s,c]=e;if(L.Null(r))return 0!==i.length||l||0!==s.length||c?null:new Map;const[u,m]=G(r);if(l||c){if(u.length<i.length+s.length)return null}else if(u.length!==i.length+s.length)return null;let d;if(l){const e=u.length-i.length-s.length;d=[...i,...Array(e).fill(l),...s],c&&(d.push(c),u.push(m))}else d=[...i],c&&(d.push(c),u.push(H(u.slice(i.length),m)));const p=new Map;l&&et(l,o).forEach((e=>p.set(e,[])));for(let e=0;e<d.length;e++){const[r,i]=[d[e],u[e]],s=rt(r,i,t,n,a,o);if(!s)return null;if(r===l)for(const[e,t]of s.entries()){const r=p.get(e);if(!r||L.Object(r))throw A.Error("syntax-error",`Internal error: illegal behavior of syntax-rules. No array prepared for variadic variable "${e}".`);L.Object(t)?p.set(e,[...r,t]):p.set(e,[...r,...t])}else for(const[e,t]of s.entries()){if(p.has(e))throw A.Error("syntax-error","The same pattern variable appeared more than once in a pattern.");p.set(e,t)}}return p}if(L.Symbol(e)&&o.includes(e[1])){if(!L.Symbol(r))return null;const o=t.getStatic(a,e),i=t.getStatic(n,e);return e[1]===r[1]&&o===i?new Map:null}return L.Symbol(e)?"_"===e[1]?new Map:new Map([[e[1],r]]):or.body({obj1:e,obj2:r})[1]?new Map:null},tt=ee("use-syntax-rules",[{name:"spec"},{name:"args"}],(({spec:e,args:r},t,n)=>{V.SyntaxRules(e),V.List(r),M(t),M(n);const[,a,o,i]=e,l=N(P(n)).env.static,s=N(n).env.static;let c,u;{let e,n;for(const a of i)if(e=rt(a[0],r,t,l,s,o)){n=a[1];break}if(!e||!n)throw A.Error("syntax-error","No rules match arguments.");[c,u]=[e,n]}const m=e=>{if(L.Pair(e)){const[,r,t]=e;if(L.Symbol(r)&&c.has(r[1])&&L.Symbol(t[1])&&t[1][1]===a){const e=c.get(r[1]);if(!e||L.Object(e))throw A.Error("syntax-error",`Pattern variable "${r[1]} is not variadic." `);return H(e,m(t[2]))}return L.Pair(r)&&L.Symbol(r[1])&&r[1][1]===a&&L.Pair(r[2])?A.Pair(m(r[2][1]),m(t)):A.Pair(m(r),m(t))}if(L.Symbol(e)&&c.has(e[1])){const r=c.get(e[1]);if(!L.Object(r))throw A.Error("syntax-error",`Pattern variable "${e[1]}" must be variadic. (add "${a}" after the symbol)" `);return r}return e};return m(u)}),!1,!0),nt=ee("syntax-error",[{name:"message"},{name:"args",type:"variadic"}],(({message:e,args:r})=>{throw V.String(e),V.Objects(r),A.Error("syntax-error",e[1],r)})),at={quote:jr,lambda:xr,If:Pr,setD:Er,include:Nr,includeCli:Ir,cond:Br,Case:Or,and:Cr,or:Ar,when:$r,unless:Lr,condExpand:kr,Let:zr,LetStar:Vr,letrecStar:qr,letrec:Mr,letValues:Tr,letStarValues:Dr,begin:Rr,Do:Qr,makeParameter:Ur,parameterize:Fr,defineParameter:Jr,defineParameter1:_r,guard:Xr,quasiquote:Zr,quasiquote1:Kr,letSyntax:Wr,letrecSyntax:Gr,syntaxRules:Yr,applySyntaxRules:tt,syntaxError:nt},ot=ee("pair?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.Pair(e))))),it=ee("cons",[{name:"obj1"},{name:"obj2"}],(({obj1:e,obj2:r})=>(V.Object(e),V.Object(r),A.Pair(e,r)))),lt=ee("car",[{name:"pair"}],(({pair:e})=>(V.Pair(e),e[1]))),st=ee("cdr",[{name:"pair"}],(({pair:e})=>(V.Pair(e),e[2]))),ct=ee("set-car!",[{name:"pair"},{name:"obj"}],(({pair:e,obj:r})=>{if(V.Pair(e),V.Object(r),e[3])throw A.Error("immutable-object","Specified list is immutable");return e[1]=r,e})),ut=ee("set-cdr!",[{name:"pair"},{name:"obj"}],(({pair:e,obj:r})=>{if(V.Pair(e),V.Object(r),e[3])throw A.Error("immutable-object","Specified list is immutable");return e[2]=r,e})),mt=ee("caar",[{name:"pair"}],(({pair:e})=>(V.Pair(e),V.Pair(e[1]),e[1][1]))),dt=ee("cadr",[{name:"pair"}],(({pair:e})=>(V.Pair(e),V.Pair(e[2]),e[2][1]))),pt=ee("cdar",[{name:"pair"}],(({pair:e})=>(V.Pair(e),V.Pair(e[1]),e[1][2]))),ft=ee("cddr",[{name:"pair"}],(({pair:e})=>(V.Pair(e),V.Pair(e[2]),e[2][2]))),bt=ee("null?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.Null(e))))),yt=ee("list?",[{name:"obj"}],(({obj:e})=>{if(V.Object(e),!L.List(e))return A.Boolean(!1);if(L.Null(e))return A.Boolean(!0);try{const[,r]=G(e);return A.Boolean(L.Null(r))}catch(r){return A.Boolean(!1)}})),ht=ee("make-list",[{name:"k"},{name:"fill",type:"optional"}],(({k:e,fill:r})=>(V.IntegerNumber(e),r?(V.Object(r),A.List(...Array.from({length:e[1]},(()=>r)))):A.List(...Array.from({length:e[1]},(()=>["<undefined>"])))))),gt=ee("list",[{name:"objs",type:"variadic"}],(({objs:e})=>(V.Objects(e),A.List(...e)))),vt=ee("length",[{name:"list"}],(({list:e})=>(V.List(e),A.Number(W(e).length)))),St=ee("append",[{name:"args",type:"variadic"}],(({args:e})=>{if(V.Objects(e),0===e.length)return["<null>"];if(1===e.length)return e[0];{const[r,t]=[e.slice(0,e.length-1),e[e.length-1]];return V.Lists(r),H(r.map((e=>W(e))).flat(),t)}})),wt=ee("reverse",[{name:"list"}],(({list:e})=>(V.List(e),A.List(...W(e).reverse())))),jt=ee("list-tail",[{name:"list"},{name:"k"}],(({list:e,k:r})=>{if(V.Object(e),V.IntegerNumber(r),0===r[1])return e;V.List(e);for(let t=e,n=0;L.Pair(t);t=t[2],n++)if(n===r[1])return t;throw A.Error("out-of-range",`Specified list is shorter than specified number ${r[1]}`)})),xt=ee("list-ref",[{name:"list"},{name:"k"}],(({list:e,k:r})=>{V.Pair(e),V.IntegerNumber(r);for(let t=e,n=0;L.Pair(t);t=t[2],n++)if(n===r[1])return t[1];throw A.Error("out-of-range",`Specified list is shorter than specified number ${r[1]}`)})),Pt=ee("list-set!",[{name:"list"},{name:"k"},{name:"obj"}],(({list:e,k:r,obj:t})=>{V.Pair(e),V.IntegerNumber(r),V.Object(t);for(let n=e,a=0;L.Pair(n);n=n[2],a++)if(a===r[1]){if(n[3])throw A.Error("immutable-object","Specified list is immutable");return n[1]=t,["<undefined>"]}throw A.Error("out-of-range",`Specified list is shorter than specified number ${r[1]}`)})),Et=ee("memq",[{name:"obj"},{name:"list"}],(({obj:e,list:r})=>{V.Object(e),V.List(r);const t=W(r).findIndex((r=>ar.body({obj1:e,obj2:r})[1]));return t<0?A.Boolean(!1):jt.body({list:r,k:A.Number(t)})})),Nt=ee("memv",[{name:"obj"},{name:"list"}],(({obj:e,list:r})=>{V.Object(e),V.List(r);const t=W(r).findIndex((r=>nr.body({obj1:e,obj2:r})[1]));return t<0?A.Boolean(!1):jt.body({list:r,k:A.Number(t)})})),It=ee("member",[{name:"obj"},{name:"list"},{name:"compare",type:"optional"}],(({obj:e,list:r,compare:t})=>{if(V.Object(e),V.List(r),L.Null(r))return A.Boolean(!1);if(t){V.Procedure(t);const[,n,a]=r;return $.If($.Call(t,A.MultiValue([n,e])),$.Quote(r),$.CallBuiltIn("member",A.MultiValue([e,a,t])))}{const t=W(r).findIndex((r=>or.body({obj1:e,obj2:r})[1]));return t<0?A.Boolean(!1):$.Quote(jt.body({list:r,k:A.Number(t)}))}}),!0),Bt=ee("assq",[{name:"obj"},{name:"alist"}],(({obj:e,alist:r})=>{V.Object(e),V.List(r);const t=W(r).find((r=>(V.Pair(r),ar.body({obj1:e,obj2:r[1]})[1])));return null!=t?t:A.Boolean(!1)})),Ot=ee("assv",[{name:"obj"},{name:"alist"}],(({obj:e,alist:r})=>{V.Object(e),V.List(r);const t=W(r).find((r=>(V.Pair(r),nr.body({obj1:e,obj2:r[1]})[1])));return null!=t?t:A.Boolean(!1)})),Ct=ee("assoc",[{name:"obj"},{name:"alist"},{name:"compare",type:"optional"}],(({obj:e,alist:r,compare:t})=>{if(V.Object(e),V.List(r),L.Null(r))return A.Boolean(!1);if(t){V.Procedure(t);const[,n,a]=r;return V.Pair(n),$.If($.Call(t,A.MultiValue([n[1],e])),$.Quote(n),$.CallBuiltIn("assoc",A.MultiValue([e,a,t])))}{const t=W(r).find((r=>(V.Pair(r),or.body({obj1:e,obj2:r[1]})[1])));return t?$.Quote(t):A.Boolean(!1)}}),!0),At=ee("list-copy",[{name:"obj"}],(({obj:e})=>{if(V.Object(e),L.List(e)){if(L.Null(e))return["<null>"];{const[r,t]=G(e);return H(r,t)}}return e})),$t={pairQ:ot,cons:it,car:lt,cdr:st,setCarD:ct,setCdrD:ut,caar:mt,cadr:dt,cdar:pt,cddr:ft,nullQ:bt,listQ:yt,makeList:ht,list:gt,length:vt,append:St,reverse:wt,listTail:jt,listRef:xt,listSetD:Pt,memq:Et,memv:Nt,member:It,assq:Bt,assv:Ot,assoc:Ct,listCopy:At},Lt=ee("number?",[{name:"obj"}],(({obj:e})=>A.Boolean(L.Number(e)))),kt=ee("real?",[{name:"obj"}],(({obj:e})=>A.Boolean(L.Number(e)))),zt=ee("integer?",[{name:"obj"}],(({obj:e})=>A.Boolean(L.Number(e)&&Number.isInteger(S(e))))),Vt=ee("exact?",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e);return A.Boolean(Number.isSafeInteger(r))})),Mt=ee("inexact?",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e);return A.Boolean(!Number.isSafeInteger(r))})),qt=re("exact-integer?",Vt),Tt=ee("=",[{name:"z1"},{name:"z2"},{name:"zs",type:"variadic"}],(({z1:e,z2:r,zs:t})=>{V.Number(e),V.Number(r),V.Numbers(t);const n=[e,r,...t].map(S);return A.Boolean(n.slice(1).every((e=>n[0]===e)))})),Dt=ee("<",[{name:"z1"},{name:"z2"},{name:"zs",type:"variadic"}],(({z1:e,z2:r,zs:t})=>{V.Number(e),V.Number(r),V.Numbers(t);const n=[e,r,...t].map(S);return A.Boolean(n.every(((e,r)=>0===r||n[r-1]<e)))})),Rt=ee(">",[{name:"z1"},{name:"z2"},{name:"zs",type:"variadic"}],(({z1:e,z2:r,zs:t})=>{V.Number(e),V.Number(r),V.Numbers(t);const n=[e,r,...t].map(S);return A.Boolean(n.every(((e,r)=>0===r||n[r-1]>e)))})),Qt=ee("<=",[{name:"z1"},{name:"z2"},{name:"zs",type:"variadic"}],(({z1:e,z2:r,zs:t})=>{V.Number(e),V.Number(r),V.Numbers(t);const n=[e,r,...t].map(S);return A.Boolean(n.every(((e,r)=>0===r||n[r-1]<=e)))})),Ut=ee(">=",[{name:"z1"},{name:"z2"},{name:"zs",type:"variadic"}],(({z1:e,z2:r,zs:t})=>{V.Number(e),V.Number(r),V.Numbers(t);const n=[e,r,...t].map(S);return A.Boolean(n.every(((e,r)=>0===r||n[r-1]>=e)))})),Ft=ee("nan?",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e);return A.Boolean(Number.isNaN(r))})),Jt=ee("zero?",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e);return A.Boolean(0===r)})),_t=ee("positive?",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e);return A.Boolean(r>0)})),Xt=ee("negative?",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e);return A.Boolean(r<0)})),Zt=ee("odd?",[{name:"n"}],(({n:e})=>{V.Number(e);const r=S(e);return A.Boolean(Number.isInteger(r)&&1===Math.abs(r%2))})),Kt=ee("even?",[{name:"n"}],(({n:e})=>{V.Number(e);const r=S(e);return A.Boolean(Number.isInteger(r)&&0===Math.abs(r%2))})),Wt=ee("max",[{name:"xs",type:"variadic"}],(({xs:e})=>(V.Numbers(e),w(Math.max(...e.map(S)))))),Gt=ee("min",[{name:"xs",type:"variadic"}],(({xs:e})=>(V.Numbers(e),w(Math.min(...e.map(S)))))),Ht=ee("+",[{name:"zs",type:"variadic"}],(({zs:e})=>(V.Numbers(e),w(e.map(S).reduce(((e,r)=>e+r),0))))),Yt=ee("-",[{name:"z1"},{name:"zs",type:"variadic"}],(({z1:e,zs:r})=>{V.Number(e),V.Numbers(r);const t=S(e),n=r.map(S);return w(0===n.length?-t:n.reduce(((e,r)=>e-r),t))})),en=ee("*",[{name:"zs",type:"variadic"}],(({zs:e})=>(V.Numbers(e),w(e.map(S).reduce(((e,r)=>e*r),1))))),rn=ee("/",[{name:"z1"},{name:"zs",type:"variadic"}],(({z1:e,zs:r})=>{V.Number(e),V.Numbers(r);const t=S(e),n=r.map(S);return n.includes(0)?A.Error("division-by-zero",null):w(0===n.length?1/t:n.reduce(((e,r)=>e/r),t))})),tn=ee("abs",[{name:"x"}],(({x:e})=>{V.Number(e);const r=S(e);return w(Math.abs(r))})),nn=ee("floor/",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{V.Number(e),V.Number(r);const t=S(e),n=S(r),a=(t%n+n)%n,o=(t-a)/n;return A.MultiValue([w(o),w(a)])})),an=ee("floor-quotient",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{V.Number(e),V.Number(r);const t=S(e),n=S(r);return w((t-(t%n+n)%n)/n)})),on=ee("floor-remainder",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{V.Number(e),V.Number(r);const t=S(e),n=S(r);return w((t%n+n)%n)})),ln=ee("truncate/",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{V.Number(e),V.Number(r);const t=S(e),n=S(r),a=t%n,o=(t-a)/n;return A.MultiValue([w(o),w(a)])})),sn=ee("truncate-quotient",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{V.Number(e),V.Number(r);const t=S(e),n=S(r);return w((t-t%n)/n)})),cn=ee("truncate-remainder",[{name:"n1"},{name:"n2"}],(({n1:e,n2:r})=>{V.Number(e),V.Number(r);const t=S(e),n=S(r);return w(t%n)})),un=re("quotient",sn),mn=re("remainder",cn),dn=re("modulo",on),pn=ee("gcd",[{name:"ns",type:"variadic"}],(({ns:e})=>{if(V.Numbers(e),0===e.length)return w(0);const r=(e,t)=>0!==t?r(t,e%t):e;return w(Math.abs(e.map(S).reduce(r)))})),fn=ee("lcm",[{name:"ns",type:"variadic"}],(({ns:e})=>{if(V.Numbers(e),0===e.length)return w(1);const r=(e,t)=>0!==t?r(t,e%t):e;return w(Math.abs(e.map(S).reduce(((e,t)=>e*t/r(e,t)))))})),bn=ee("floor",[{name:"x"}],(({x:e})=>{V.Number(e);const r=S(e);return w(Math.floor(r))})),yn=ee("ceiling",[{name:"x"}],(({x:e})=>{V.Number(e);const r=S(e);return w(Math.ceil(r))})),hn=ee("truncate",[{name:"x"}],(({x:e})=>{V.Number(e);const r=S(e);return w(Math.trunc(r))})),gn=ee("round",[{name:"x"}],(({x:e})=>{V.Number(e);const r=S(e);return w(Math.round(r))})),vn=ee("rationalize",[{name:"x"},{name:"y"}],(()=>{throw A.Error("not-supported",'"Fraction numbers are not supported.')})),Sn=ee("square",[{name:"x"}],(({x:e})=>{V.Number(e);const r=S(e);return w(r**2)})),wn=ee("exact-integer-sqrt",[{name:"k"}],(({k:e})=>{V.IntegerNumber(e);const r=S(e);if(!Number.isSafeInteger(r)||r<0)throw A.Error("out-of-range","exact-integer-sqrt can calculate exact & non-negative value.");const t=Math.floor(Math.sqrt(r)),n=r-t**2;return A.MultiValue([w(t),w(n)])})),jn=ee("expt",[{name:"z1"},{name:"z2"}],(({z1:e,z2:r})=>{V.Number(e),V.Number(r);const t=S(e),n=S(r);return w(t**n)})),xn=ee("inexact",[{name:"z"}],(({z:e})=>(V.Number(e),e))),Pn=ee("exact",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e),t=Number(r.toFixed());if(!Number.isSafeInteger(t))throw A.Error("out-of-range",`"exact" can't calculate exact number for ${e[1]}.`);return e})),En=ee("number->string",[{name:"z"},{name:"radix",type:"optional"}],(({z:e,radix:r})=>{V.Number(e),V.Number(r);const t=S(e);if(isNaN(t))return A.String("+nan.0",!1);if(isFinite(t)){r&&V.IntegerNumber(r);const e=r?S(r):10;if(![2,8,10,16].includes(e))throw A.Error("out-of-range","radix must be one of 2, 8, 10, 16.");return A.String(t.toString(e),!1)}return A.String((t>0?"+":"-")+"inf.0",!1)})),Nn=ee("string->number",[{name:"str"},{name:"radix",type:"optional"}],(({str:e,radix:r})=>{V.String(e);let t,n=e[1];if(r){if(V.IntegerNumber(r),![2,8,10,16].includes(S(r)))throw A.Error("out-of-range","radix must be one of 2, 8, 10, 16.");const e=`#${{2:"b",8:"o",10:"d",16:"x"}[S(r)]}`;n=n.replace(/^(#[dDbBoOxX])?/,e)}try{t=ye(n)}catch(a){return A.Boolean(!1)}return L.Number(t)?t:A.Boolean(!1)})),In={numberQ:Lt,realQ:kt,integerQ:zt,exactQ:Vt,inexactQ:Mt,exactIntegerQ:qt,eq:Tt,lt:Dt,gt:Rt,le:Qt,ge:Ut,nanQ:Ft,zeroQ:Jt,positiveQ:_t,negativeQ:Xt,oddQ:Zt,evenQ:Kt,max:Wt,min:Gt,add:Ht,sub:Yt,mul:en,div:rn,abs:tn,floorS:nn,floorQuotient:an,floorRemainder:on,truncateS:ln,truncateQuotient:sn,truncateRemainder:cn,quotient:un,remainder:mn,modulo:dn,gcd:pn,lcm:fn,floor:bn,ceiling:yn,truncate:hn,rationalize:vn,round:gn,square:Sn,exactIntegerSqrt:wn,expt:jn,inexact:xn,exact:Pn,numberToString:En,stringToNumber:Nn},Bn='"fs" is not set. To use filesystems, import/require "fs" and set it on Interpreter\'s constructor parameter.',On=ee("call-with-port",[{name:"port"},{name:"proc"}],(({port:e,proc:r})=>(V.Port(e),V.Procedure(r),$.Begin($.Call(r,e),$.CallBuiltIn("close-port",e))))),Cn=ee("input-port?",[{name:"obj"}],(({obj:e})=>{var r;return V.Object(e),A.Boolean(!(!L.Port(e)||!(null==(r=e[3])?void 0:r.includes("r"))))})),An=ee("output-port?",[{name:"obj"}],(({obj:e})=>{var r;return V.Object(e),A.Boolean(!(!L.Port(e)||!(null==(r=e[3])?void 0:r.includes("w"))))})),$n=ee("textual-port?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.Port(e)&&"string"==typeof e[5])))),Ln=ee("binary-port?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.Port(e)&&"string"!=typeof e[5])))),kn=ee("port?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.Port(e))))),zn=ee("input-port-open?",[{name:"port"}],(({port:e})=>{var r;return V.Port(e),A.Boolean(!!(null==(r=e[3])?void 0:r.includes("r")))})),Vn=ee("output-port-open?",[{name:"port"}],(({port:e})=>{var r;return V.Port(e),A.Boolean(!!(null==(r=e[3])?void 0:r.includes("w")))})),Mn=ee("close-port",[{name:"port"}],(({port:e},r)=>{var t;if(V.Port(e),!e[3])return["<undefined>"];if("built-in"===e[1]){if(!r)throw A.Error("program-error","No interpreter object.");const n=r.getBuiltInPort(e[2]);if(!n)throw A.Error("program-error","Illegal built-in file object.");null==(t=n.close)||t.call(n)}else if("string"!==e[1]){if("file"===e[1]){if(!(null==r?void 0:r.fs))throw A.Error("program-error",'No interpreter object or No Node.js "fs" object set on Interpreter.');return r.fs.closeSync(e[2]),A.Boolean(!0)}throw A.Error("program-error",`Unknown port type "${e[1]}"`)}return e[3]=null,["<undefined>"]})),qn=ee("close-input-port",[{name:"port"}],(({port:e})=>{var r;if(V.Port(e),!(null==(r=e[3])?void 0:r.includes("r")))return["<undefined>"];if("built-in"===e[1])throw A.Error("program-error","Can't close only output port for built-in port.");if("string"===e[1]);else if("bytevector"!==e[1])throw"file"===e[1]?A.Error("program-error","Can't close only input port for file port."):A.Error("program-error",`Unknown port type "${e[1]}"`);return e[3]=e[3].replace("r","")||null,["<undefined>"]})),Tn=ee("close-output-port",[{name:"port"}],(({port:e})=>{var r;if(V.Port(e),!(null==(r=e[3])?void 0:r.includes("w")))return["<undefined>"];if("built-in"===e[1])throw A.Error("program-error","Can't close only output port for built-in port.");if("string"===e[1]);else if("bytevector"!==e[1])throw"file"===e[1]?A.Error("program-error","Can't close only output port for file port."):A.Error("program-error",`Unknown port type "${e[1]}"`);return e[3]=e[3].replace("w","")||null,["<undefined>"]})),Dn=ee("open-input-string",[{name:"str"}],(({str:e})=>(V.String(e),A.Port("string",e[1],"r",null,"")))),Rn=ee("open-output-string",[],(()=>A.Port("string","","w",null,""))),Qn=ee("get-output-string",[{name:"port"}],(({port:e})=>{var r;if(V.Port(e),"string"!==e[1]||!(null==(r=e[3])?void 0:r.includes("w")))throw A.Error("read-error","Not a port created by open-output-string.");return A.String(e[2],!1)})),Un=ee("open-input-bytevector",[{name:"bvec"}],(({bvec:e})=>(V.ByteVector(e),A.Port("bytevector",[...e[1]],"r",null,[])))),Fn=ee("open-output-bytevector",[],(()=>A.Port("bytevector",[],"w",null,[]))),Jn=ee("get-output-bytevector",[{name:"port"}],(({port:e})=>{var r;if(V.Port(e),"bytevector"!==e[1]||!(null==(r=e[3])?void 0:r.includes("w")))throw A.Error("read-error","Not a port created by open-output-string.");return A.ByteVector([...e[2]],!1)})),_n=ee("read-char",[{name:"port",type:"optional"}],(({port:e},r,t)=>{var n,a;if(M(r),M(t),e||(e=r.getDynamic(N(t).env.dynamic,"current-input-port")),V.Port(e),!(null==(n=e[3])?void 0:n.includes("r")))throw A.Error("read-error","Port is not open.");if("string"!=typeof e[5])throw A.Error("read-error","Not a text port.");let o;if(e[5].length>0)/^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e[5])?(o=e[5].slice(0,2),e[5]=e[5].slice(2)):(o=e[5].slice(0,1),e[5]=e[5].slice(1));else if("built-in"===e[1]){const t=null==r?void 0:r.getBuiltInPort(e[2]);o=null==(a=null==t?void 0:t.read)?void 0:a.call(t,"character",null)}else if("string"===e[1])0===e[2].length?o=null:/^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e[2])?(o=e[2].slice(0,2),e[2]=e[2].slice(2)):(o=e[2].slice(0,1),e[2]=e[2].slice(1));else{if("file"!==e[1])throw A.Error("program-error","Illegal type of port.");{if(!(null==r?void 0:r.fs))throw A.Error("read-error",Bn);const t=Buffer.alloc(4);for(let n=0;;n++){if(!r.fs.readSync(e[2],t,{length:1,offset:n})){o=null;break}const a=t.toString("utf8",0,n+1);if(!a.includes("�")){o=a;break}if(n>=4)throw A.Error("read-error","Not a valid text(UTF-8) file.")}}}if(null===o)return A.EndOfFile();if(void 0===o)throw A.Error("read-error",null);if("string"!=typeof o)throw A.Error("read-error","Read-data is not a expected format (number).");return A.Character(o)})),Xn=ee("peek-char",[{name:"port",type:"optional"}],(({port:e},r,t)=>{M(r),M(t),e||(e=r.getDynamic(N(t).env.dynamic,"current-input-port")),V.Port(e);const n=_n.body({port:e},r,t);return L.EndOfFile(n)||(e[5]="string"==typeof e[5]?n[1]+e[5]:n[1]),n})),Zn=ee("read-line",[{name:"port",type:"optional"}],(({port:e},r,t)=>{M(r),M(t),e||(e=r.getDynamic(N(t).env.dynamic,"current-input-port")),V.Port(e);let n="";for(;;){const a=_n.body({port:e},r,t);if(L.EndOfFile(a))return""===n?a:A.String(n,!1);if("\r"===a[1]){const a=_n.body({port:e},r,t);return L.EndOfFile(a)||"\n"===a[1]||(e[5]="string"==typeof e[5]?a[1]+e[5]:a[1]),A.String(n,!1)}if("\n"===a[1])return A.String(n,!1);n+=a[1]}})),Kn=ee("eof-object?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.EndOfFile(e))))),Wn=ee("eof-object",[],(()=>A.EndOfFile())),Gn=ee("char-ready?",[{name:"port",type:"optional"}],(({port:e},r,t)=>{var n,a;if(M(r),M(t),e||(e=r.getDynamic(N(t).env.dynamic,"current-input-port")),V.Port(e),!(null==(n=e[3])?void 0:n.includes("r")))return A.Boolean(!1);if("built-in"===e[1]){if(!r)throw A.Error("program-error","No interpreter object.");const t=r.getBuiltInPort(e[2]);if(!t)throw A.Error("program-error","Illegal built-in file object.");return A.Boolean(!!(null==(a=t.ready)?void 0:a.call(t)))}if("string"===e[1])return A.Boolean(!0);if("bytevector"===e[1])return A.Boolean(!1);throw"file"===e[1]?A.Error("program-error",'"Node.js file "ready" method is not implemented."'):A.Error("program-error",`Unknown port type "${e[1]}"`)})),Hn=ee("read-string",[{name:"k"},{name:"port",type:"optional"}],(({k:e,port:r},t,n)=>{V.IntegerNumber(e),M(t),M(n),r||(r=t.getDynamic(N(n).env.dynamic,"current-input-port")),V.Port(r);let a="";for(;;){const o=_n.body({port:r},t,n);if(L.EndOfFile(o))return 0===a.length?o:A.String(a,!1);if(a+=o[1],a.length>=e[1])return A.String(a,!1)}})),Yn=ee("read-u8",[{name:"port",type:"optional"}],(({port:e},r,t)=>{var n,a;if(M(r),M(t),e||(e=r.getDynamic(N(t).env.dynamic,"current-input-port")),V.Port(e),!(null==(n=e[3])?void 0:n.includes("r")))throw A.Error("read-error","Port is not open.");if("string"==typeof e[5])throw A.Error("read-error","Not a binary port.");let o;if(e[5].length>0)o=e[5][0],e[5]=e[5].slice(1);else if("built-in"===e[1]){const t=null==r?void 0:r.getBuiltInPort(e[2]);o=null==(a=null==t?void 0:t.read)?void 0:a.call(t,"byte",null)}else if("bytevector"===e[1])e[2].length>0?(o=e[2][0],e[2]=e[2].slice(1)):o=null;else{if("file"!==e[1])throw A.Error("program-error","Illegal type of port.");{if(!(null==r?void 0:r.fs))throw A.Error("read-error",Bn);const t=Buffer.alloc(1);o=r.fs.readSync(e[2],t)?t[0]:null}}if(null===o)return A.EndOfFile();if(void 0===o)throw A.Error("read-error",null);if("number"!=typeof o)throw A.Error("read-error","Read-data is not a expected format (string).");return A.Number(o)})),ea=ee("peek-u8",[{name:"port",type:"optional"}],(({port:e},r,t)=>{M(r),M(t),e||(e=r.getDynamic(N(t).env.dynamic,"current-input-port")),V.Port(e);const n=Yn.body({port:e},r,t);return L.EndOfFile(n)||(e[5]="string"!=typeof e[5]?[n[1],...e[5]]:[n[1]]),n})),ra=ee("u8-ready?",[{name:"port",type:"optional"}],(({port:e},r,t)=>{var n,a;if(M(r),M(t),e||(e=r.getDynamic(N(t).env.dynamic,"current-input-port")),V.Port(e),!(null==(n=e[3])?void 0:n.includes("r")))return A.Boolean(!1);if("built-in"===e[1]){if(!r)throw A.Error("program-error","No interpreter object.");const t=r.getBuiltInPort(e[2]);if(!t)throw A.Error("program-error","Illegal built-in file object.");return A.Boolean(!!(null==(a=t.ready)?void 0:a.call(t)))}if("string"===e[1])return A.Boolean(!1);if("bytevector"===e[1])return A.Boolean(!0);if("file"===e[1]){if(!(null==r?void 0:r.fs))throw A.Error("read-error",Bn);throw A.Error("program-error",'"Node.js file "ready" method is not implemented."')}throw A.Error("program-error",`Unknown port type "${e[1]}"`)})),ta=ee("read-bytevector",[{name:"k"},{name:"port",type:"optional"}],(({k:e,port:r},t,n)=>{V.IntegerNumber(e),M(t),M(n),r||(r=t.getDynamic(N(n).env.dynamic,"current-input-port")),V.Port(r);const a=[];for(;;){const o=Yn.body({port:r},t,n);if(L.EndOfFile(o))return 0===a.length?o:A.ByteVector(a,!1);if(a.push(o[1]),a.length>=e[1])return A.ByteVector(a,!1)}})),na=ee("read-bytevector!",[{name:"bvec"},{name:"port",type:"optional"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({bvec:e,port:r,start:t,end:n},a,o)=>{V.ByteVector(e),M(a),M(o);const i=L.Number(t)?t[1]:0,l=L.Number(n)?n[1]:e[1].length;if("number"!=typeof i||!Number.isInteger(i)||"number"!=typeof l||!Number.isInteger(l))throw A.Error("domain-error","Index must be integer.");const s=l-i,c=ta.body({k:A.Number(s),port:r},a,o);if(L.EndOfFile(c))return c;for(let u=0;u<c[1].length;u++)e[1][i+u]=c[1][u];return A.Number(c[1].length)})),aa=ee("newline",[{name:"port",type:"optional"}],(({port:e},r,t)=>ia.body({str:A.String("\n",!1),port:e,start:null,end:null},r,t))),oa=ee("write-char",[{name:"char"},{name:"port",type:"optional"}],(({char:e,port:r},t,n)=>(V.Character(e),ia.body({str:A.String(e[1],!1),port:r,start:null,end:null},t,n)))),ia=ee("write-string",[{name:"str"},{name:"port",type:"optional"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,port:r,start:t,end:n},a,o)=>{var i;V.String(e),M(a),M(o);const l=L.Number(t)?t[1]:0,s=L.Number(n)?n[1]:e[1].length;if("number"!=typeof l||!Number.isInteger(l)||"number"!=typeof s||!Number.isInteger(s))throw A.Error("domain-error","Index must be integer.");const c=Array.from(e[1]).slice(l,s).join("");if(r||(r=a.getDynamic(N(o).env.dynamic,"current-output-port")),V.Port(r),!(null==(i=r[3])?void 0:i.includes("w")))throw A.Error("write-error","Port is not open for writing.");if("string"!=typeof r[5])throw A.Error("write-error","Not a text port.");if("built-in"===r[1]){if(!a)throw A.Error("program-error","No interpreter object.");const e=a.getBuiltInPort(r[2]);if(!e||!e.write)throw A.Error("program-error","No built-in method defined to write.");e.write(c)}else if("string"===r[1])r[2]=r[2]+c;else{if("file"!==r[1])throw A.Error("program-error","Illegal type of port for writing.");if(!(null==a?void 0:a.fs))throw A.Error("write-error",Bn);a.fs.writeSync(r[2],c)}return["<undefined>"]})),la=ee("write-u8",[{name:"byte"},{name:"port",type:"optional"}],(({byte:e,port:r},t,n)=>(V.IntegerNumber(e),sa.body({bvec:A.ByteVector([e[1]],!1),port:r},t,n)))),sa=ee("write-bytevector",[{name:"bvec"},{name:"port",type:"optional"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({bvec:e,port:r,start:t,end:n},a,o)=>{var i;V.ByteVector(e),M(a),M(o);const l=L.Number(t)?t[1]:0,s=L.Number(n)?n[1]:e[1].length;if("number"!=typeof l||!Number.isInteger(l)||"number"!=typeof s||!Number.isInteger(s))throw A.Error("domain-error","Index must be integer.");const c=e[1].slice(l,s);if(r||(r=a.getDynamic(N(o).env.dynamic,"current-output-port")),V.Port(r),!(null==(i=r[3])?void 0:i.includes("w")))throw A.Error("write-error","Port is not open for writing.");if("string"==typeof r[5])throw A.Error("write-error","Not a binary port.");if("built-in"===r[1]){if(!a)throw A.Error("program-error","No interpreter object.");const e=a.getBuiltInPort(r[2]);if(!e||!e.write)throw A.Error("program-error","No built-in method defined to write.");e.write(new Uint8Array(c))}else if("bytevector"===r[1])r[2].push(...c);else{if("file"!==r[1])throw A.Error("program-error","Illegal type of port for writing.");if(!(null==a?void 0:a.fs))throw A.Error("write-error",Bn);a.fs.writeSync(r[2],new Uint8Array(c))}return["<undefined>"]})),ca=ee("flush-output-port",[{name:"port",type:"optional"}],(({port:e},r,t)=>{var n,a;if(M(r),M(t),e||(e=r.getDynamic(N(t).env.dynamic,"current-output-port")),V.Port(e),!(null==(n=e[3])?void 0:n.includes("w")))throw A.Error("write-error","Port is not open for writing.");if("built-in"===e[1]){if(!r)throw A.Error("program-error","No interpreter object.");const t=r.getBuiltInPort(e[2]);if(!t)throw A.Error("program-error","No built-in method defined to write.");null==(a=t.flush)||a.call(t)}else if("file"===e[1]){if(!(null==r?void 0:r.fs))throw A.Error("write-error",Bn);r.fs.fsyncSync(e[2])}return["<undefined>"]})),ua={callWithPort:On,inputPortQ:Cn,outputPortQ:An,textualPortQ:$n,binaryPortQ:Ln,portQ:kn,inputPortOpenQ:zn,outputPortOpenQ:Vn,closePort:Mn,closeInputPort:qn,closeOutputPort:Tn,openInputString:Dn,openOutputString:Rn,getOutputString:Qn,openInputBytevector:Un,openOutputBytevector:Fn,getOutputBytevector:Jn,readChar:_n,peekChar:Xn,readLine:Zn,eofObjectQ:Kn,eofObject:Wn,charReadyQ:Gn,readString:Hn,readU8:Yn,peekU8:ea,u8ReadyQ:ra,readBytevector:ta,readBytevectorD:na,newline:aa,writeChar:oa,writeString:ia,writeU8:la,writeBytevector:sa,flushOutputPort:ca},ma={stringQ:ee("string?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.String(e))))),makeString:ee("make-string",[{name:"k"},{name:"char",type:"optional"}],(({k:e,char:r})=>(V.IntegerNumber(e),r&&V.Character(r),A.String((r?r[1]:" ").repeat(e[1]),!1)))),string:ee("string",[{name:"chars",type:"variadic"}],(({chars:e})=>(V.Characters(e),A.String(e.map((e=>e[1])).join(""),!1)))),stringLength:ee("string-length",[{name:"str"}],(({str:e})=>(V.String(e),A.Number(Array.from(e[1]).length)))),stringRef:ee("string-ref",[{name:"str"},{name:"k"}],(({str:e,k:r})=>{V.String(e),V.IntegerNumber(r);const t=Array.from(e[1])[r[1]];if(!t)throw A.Error("out-of-range",`The specified string doesn't have character with index ${r[1]}.`);return A.Character(t)})),stringSetD:ee("string-set!",[{name:"str"},{name:"k"},{name:"char"}],(({str:e,k:r,char:t})=>{V.String(e),V.IntegerNumber(r),V.Character(t);const n=Array.from(e[1]),a=n.slice(0,r[1]),o=n.slice(r[1]+1);return e[1]=[...a,t[1],...o].join(""),["<undefined>"]})),stringEQ:ee("string=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>(V.String(e),V.String(r),V.Strings(t),A.Boolean([r,...t].every((r=>r[1]===e[1])))))),stringLtQ:ee("string<?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{V.String(e),V.String(r),V.Strings(t);const n=[e,r,...t].map((e=>e[1]));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]<e)))})),stringGtQ:ee("string>?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{V.String(e),V.String(r),V.Strings(t);const n=[e,r,...t].map((e=>e[1]));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]>e)))})),stringLeQ:ee("string<=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{V.String(e),V.String(r),V.Strings(t);const n=[e,r,...t].map((e=>e[1]));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]<=e)))})),stringGeQ:ee("string>=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{V.String(e),V.String(r),V.Strings(t);const n=[e,r,...t].map((e=>e[1]));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]>=e)))})),substring:ee("substring",[{name:"str"},{name:"start"},{name:"end"}],(({str:e,start:r,end:t})=>(V.String(e),V.IntegerNumber(r),V.IntegerNumber(t),A.String(Array.from(e[1]).slice(r[1],t[1]).join(""),!1)))),stringAppend:ee("string-append",[{name:"strs",type:"variadic"}],(({strs:e})=>(V.Strings(e),A.String(e.map((e=>e[1])).join(""),!1)))),stringToList:ee("string->list",[{name:"str"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,start:r,end:t})=>{V.String(e);const n=Array.from(e[1]),a=L.Number(r)?r[1]:0,o=L.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw A.Error("domain-error","Index must be integer.");return A.List(...n.slice(a,o).map((e=>A.Character(e))))})),listToString:ee("list->string",[{name:"list"}],(({list:e})=>{V.List(e);const r=W(e);return V.Characters(r),A.String(r.map((e=>e[1])).join(""),!1)})),stringCopy:ee("string-copy",[{name:"str"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,start:r,end:t})=>{V.String(e);const n=Array.from(e[1]),a=L.Number(r)?r[1]:0,o=L.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw A.Error("domain-error","Index must be integer.");return A.String(n.slice(a,o).join(""),!1)})),stringCopyD:ee("string-copy!",[{name:"to"},{name:"at"},{name:"from"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({to:e,at:r,from:t,start:n,end:a})=>{V.String(e),V.IntegerNumber(r),V.String(t);const o=Array.from(t[1]),i=Array.from(e[1]),l=L.Number(n)?n[1]:0,s=L.Number(a)?a[1]:o.length;if("number"!=typeof l||!Number.isInteger(l)||"number"!=typeof s||!Number.isInteger(s))throw A.Error("domain-error","Index must be integer.");if(r[1]<0||r[1]>=o.length)throw A.Error("out-of-range","Index is out of range.");if(o.length-r[1]<s-l)throw A.Error("out-of-range","Index is out of range.");const c=o.slice(l,s),u=i.slice(0,r[1]),m=i.slice(r[1]+c.length);return e[1]=[...u,...c,...m].join(""),["<undefined>"]})),stringFillD:ee("string-fill!",[{name:"str"},{name:"fill"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,fill:r,start:t,end:n})=>{V.String(e),V.Character(r);const a=Array.from(e[1]),o=L.Number(t)?t[1]:0,i=L.Number(n)?n[1]:a.length;if("number"!=typeof o||!Number.isInteger(o)||"number"!=typeof i||!Number.isInteger(i))throw A.Error("domain-error","Index must be integer.");const l=a.slice(o,i),s=a.slice(0,o),c=a.slice(i);return e[1]=[...s,...r[1].repeat(l.length),...c].join(""),["<undefined>"]}))},da=ee("import",[{name:"sets",type:"variadic",evaluate:!1}],(({sets:e},r,t)=>{var n;V.Objects(e),M(r),M(t);const a=!j(N(t).env.static),o=e=>{if(L.Pair(e)&&L.Symbol(e[1])&&(n=e[1][1],["only","except","prefix","rename"].includes(n))){const r=e[1][1],[,t,...n]=W(e);if(!t)throw A.Error("error","Illegal import syntax. No import set after only, except, prefix, or rename.");if("only"===r){V.Symbols(n,"Illegal import syntax (only).");const e={};for(const[r,a]of Object.entries(o(t)))n.some((e=>e[1]===r))&&(e[r]=a);return e}if("except"===r){V.Symbols(n,"Illegal import syntax (except).");const e={};for(const[r,a]of Object.entries(o(t)))n.some((e=>e[1]!==r))&&(e[r]=a);return e}if("prefix"===r){0===n.length&&L.Symbol(n[0])||V.Symbols(n,"Illegal import syntax (prefix).");const e=n[0][1],r={};for(const[n,a]of Object.entries(o(t)))r[e+n]=a;return r}if("rename"===r){const e=o(t);for(const r of n){V.Pair(r,"Illegal import syntax (rename)."),V.Symbol(r[1],"Illegal import syntax (rename)."),V.Pair(r[2],"Illegal import syntax (rename)."),V.Symbol(r[2][1],"Illegal import syntax (rename).");const[,t,[,n]]=r,a=e[t[1]];M(a,`Identifier ${t[1]} is not found in the original set.`),delete e[t[1]],e[n[1]]=a}return e}return{}}{const n=g(e);if("(scheme base)"===n)return{};const a=r.getBuiltInLibrary(n);if(a)return a(r);const o=r.getStatic(N(t).env.static,A.Symbol(n));if(L.Library(o)){const e={},[,t,n]=o;for(const[a,o]of Object.entries(t)){const t=r.getStatic(n.static,A.Symbol(a));if(!t)throw A.Error("error",`Invalid library export "${a[1]}" (exported as "${o[1]}")`);e[o]=t}return e}throw A.Error("error",`Library "${n}" not found.`)}var n};for(const i of e){const e=o(i);for(const o of Object.keys(e)){if(!a&&!L.Undefined(null!=(n=x(N(t).env.static)[o])?n:["<undefined>"]))throw A.Error("redefine-variable",null);r.defineStatic(N(t).env.static,A.Symbol(o),e[o])}}return["<undefined>"]})),pa=ee("define",[{name:"arg1",evaluate:!1},{name:"arg2",type:"variadic",evaluate:!1}],(({arg1:e,arg2:r},t,n)=>{var a,o;V.Object(e),V.Objects(r),M(t),M(n);const i=!j(N(n).env.static);if(L.Symbol(e)){const o=e,[l]=r;if(!i&&!L.Undefined(null!=(a=x(N(n).env.static)[o[1]])?a:["<undefined>"]))throw A.Error("redefine-variable",null);return t.defineStatic(N(n).env.static,o,["<undefined>"]),$.Set(o,l)}{V.Pair(e);const[[,a,l],s]=[e,r];if(V.Symbol(a),V.List(l),!i&&!L.Undefined(null!=(o=x(N(n).env.static)[a[1]])?o:["<undefined>"]))throw A.Error("redefine-variable",null);const[c,u]=ae(l);return t.defineStatic(N(n).env.static,a,A.Procedure("lambda",u?[...c,u]:c,$.BeginIfMultiple(...s),!1,N(n).env)),["<undefined>"]}}),!0),fa=ee("define-values",[{name:"formals",evaluate:!1},{name:"expr"}],(({formals:e,expr:r},t,n)=>{var a;V.Object(e),V.Object(r),M(t),M(n);const o=!j(N(n).env.static),[i,l]=ae(e),s=L.MultiValue(r)?r[1]:[r];for(let c=0;c<i.length;c++){if(!s[c])throw A.Error("arity-error",null);if(!o&&!L.Undefined(null!=(a=x(N(n).env.static)[i[c].name])?a:["<undefined>"]))throw A.Error("redefine-variable",null);t.defineStatic(N(n).env.static,A.Symbol(i[c].name),s[c])}return l&&t.defineStatic(N(n).env.static,A.Symbol(l.name),A.List(...s.slice(i.length))),["<undefined>"]})),ba=ee("define-syntax",[{name:"keyword",evaluate:!1},{name:"spec",evaluate:!1}],(({keyword:e,spec:r},t,n)=>{var a;V.Symbol(e),V.Object(r),M(t),M(n);if(!!j(N(n).env.static)&&!L.Undefined(null!=(a=x(N(n).env.static)[e[1]])?a:["<undefined>"]))throw A.Error("redefine-variable",null);return t.defineStatic(N(n).env.static,e,A.Undefined()),$.CallBuiltIn("define-syntax-1",e,r)}),!0),ya=ee("define-syntax-1",[{name:"keyword",evaluate:!1},{name:"spec"}],(({keyword:e,spec:r},t,n)=>{V.Symbol(e),V.SyntaxRules(r),M(t),M(n);const a=A.Procedure("lambda",[{name:"exprs",type:"variadic",evaluate:!1}],$.CallBuiltIn("use-syntax-rules",r,A.Symbol("exprs")),!0,N(n).env);return t.defineStatic(N(n).env.static,e,a),["<undefined>"]}),!1,!0),ha=ee("define-record-type",[{name:"name",evaluate:!1},{name:"ctor",evaluate:!1},{name:"pred",evaluate:!1},{name:"fields",evaluate:!1,type:"variadic"}],(({name:e,ctor:r,pred:t,fields:n},a,o)=>{var i,l,s,c;V.Symbol(e),V.Pair(r),V.Symbol(t),V.Pairs(n),M(a),M(o);const u=!j(N(o).env.static);if(!(u||L.Undefined(null!=(i=x(N(o).env.static)[e[1]])?i:["<undefined>"])&&L.Undefined(null!=(l=x(N(o).env.static)[t[1]])?l:["<undefined>"])))throw A.Error("redefine-variable",null);const m=N(o).env,d=A.RecordType(e[1]),[p,...f]=W(r);V.Symbol(p),V.Symbols(f);{const e=A.Symbol("rec");a.defineStatic(N(o).env.static,p,A.Procedure("lambda",f.map((e=>({name:e[1]}))),$.BeginIfMultiple($.Define(e,$.CallBuiltIn("make-record",d)),...f.map((r=>$.CallBuiltIn("record-set!",e,r,r))),e),!1,m))}{const e=A.Symbol("rec");a.defineStatic(N(o).env.static,t,A.Procedure("lambda",[{name:e[1]}],$.CallBuiltIn("record-type?",e,d),!1,m))}for(const b of n){const[e,r,t]=W(b);if(V.Symbol(e),V.Symbol(r),!f.some((r=>r[1]===e[1])))throw A.Error("domain-error","Unknown field name");{if(!u&&!L.Undefined(null!=(s=x(N(o).env.static)[r[1]])?s:["<undefined>"]))throw A.Error("redefine-variable",null);const t=A.Symbol("rec");a.defineStatic(N(o).env.static,r,A.Procedure("lambda",[{name:t[1]}],$.CallBuiltIn("record-get",t,e),!1,m))}if(t){if(V.Symbol(t),!u&&!L.Undefined(null!=(c=x(N(o).env.static)[t[1]])?c:["<undefined>"]))throw A.Error("redefine-variable",null);const r=A.Symbol("rec"),n=A.Symbol("value");a.defineStatic(N(o).env.static,t,A.Procedure("lambda",[{name:r[1]},{name:n[1]}],$.CallBuiltIn("record-set!",r,e,n),!1,m))}}return["<undefined>"]})),ga=ee("make-record",[{name:"type"}],(({type:e})=>(V.RecordType(e),A.Record(e,{}))),!1,!0),va=ee("record-type?",[{name:"rec"},{name:"type"}],(({rec:e,type:r})=>(V.Object(e),V.RecordType(r),L.Record(e)?nr.body({obj1:e[1],obj2:r}):A.Boolean(!1))),!1,!0),Sa=ee("record-get",[{name:"rec"},{name:"field",evaluate:!1}],(({rec:e,field:r})=>{var t;V.Record(e),V.Symbol(r);return null!=(t=e[2][r[1]])?t:["<undefined>"]}),!1,!0),wa=ee("record-set!",[{name:"rec"},{name:"field",evaluate:!1},{name:"value"}],(({rec:e,field:r,value:t})=>{if(V.Record(e),V.Symbol(r),V.Object(t),L.Undefined(t))throw A.Error("undefined-value","Attempt to set an undefined value.");return e[2][r[1]]=t,["<undefined>"]}),!1,!0),ja=ee("define-library",[{name:"name",evaluate:!1},{name:"decls",type:"variadic",evaluate:!1}],(({name:e,decls:r},t,n)=>{var a;V.Object(e),V.Pairs(r),M(t),M(n);const o=g(e);if(!!j(N(n).env.static)&&!L.Undefined(null!=(a=x(N(n).env.static)[o])?a:["<undefined>"]))throw A.Error("redefine-variable",null);const i=N(I(A.Undefined())).env,l=A.Library({},i),s=[],c=[],u=e=>{for(const r of e){const[,e,a]=r;if(V.Symbol(e,"Illegal syntax of define-library-syntax"),"export"===e[1]){V.List(a,"Illegal syntax of export.");for(const e of W(a))if(L.Symbol(e))t.defineStatic(i.static,e,A.Undefined()),l[1][e[1]]=e[1];else{if(!L.Pair(e))throw A.Error("error","Illegal syntax of export in define-library");if(!(L.Symbol(e[1])&&"rename"===e[1][1]&&L.Pair(e[2])&&L.Pair(e[2][2])))throw A.Error("error","Illegal syntax of export in define-library");{const[,r,[,n]]=e[2];V.Symbol(r,"Illegal renaming symbol(from) of export in define-library"),V.Symbol(n,"Illegal renaming symbol(to) of export in define-library"),t.defineStatic(i.static,r,A.Undefined()),l[1][r[1]]=n[1]}}}else if("include-library-declarations"===e[1]){V.List(a,"Illegal syntax of include-library-declarations");const e=W(a);V.Strings(e,"Illegal filename of include-library-declarations");for(const r of e)if(!c.includes(r[1])){const e=gr.body({filename:r},t);V.Pair(e),V.List(e[2]);const n=W(e[2]);V.Pairs(n,`Illegal declarations in file ${r[1]}`),u(n)}}else if("cond-expand"===e[1]){V.List(a,"Illegal syntax of cond-expand in define-library");const[e,...r]=W(a),o=kr.body({clause1:e,clauses:r},t,n);if(!L.Undefined(o)){const[,...e]=W(o);V.Pairs(e,"Illegal result of cond-expand in define-library"),u(e)}}else{if(!["import","begin","include","include-cli"].includes(e[1]))throw A.Error("error","Illegal declaration in define-library");s.push(r)}}};u(r);const m=O(n,$.Define(A.Symbol(o),l));return B(m,$.Begin(...s,A.MultiValue([])),{env:i})})),xa={Import:da,define:pa,defineValues:fa,defineSyntax:ba,defineSyntax1:ya,defineRecordType:ha,makeRecord:ga,recordTypeQ:va,recordGet:Sa,recordSetD:wa,defineLibrary:ja},Pa={symbolQ:ee("symbol?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.Symbol(e))))),symbolEQ:ee("symbol=?",[{name:"symbol1"},{name:"symbol2"},{name:"symbols",type:"variadic"}],(({symbol1:e,symbol2:r,symbols:t})=>(V.Symbol(e),V.Symbol(r),V.Symbols(t),A.Boolean([r,...t].every((r=>r[1]===e[1])))))),symbolToString:ee("symbol->string",[{name:"obj"}],(({obj:e})=>(V.Symbol(e),A.String(e[1],!0)))),stringToSymbol:ee("string->symbol",[{name:"obj"}],(({obj:e})=>(V.String(e),A.Symbol(e[1]))))},Ea={vectorQ:ee("vector?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.Vector(e))))),makeVector:ee("make-vector",[{name:"k"},{name:"fill",type:"optional"}],(({k:e,fill:r})=>(V.IntegerNumber(e),r&&V.Object(r),A.Vector(Array(e[1]).fill(r||["<undefined>"]),!1)))),vector:ee("vector",[{name:"objs",type:"variadic"}],(({objs:e})=>(V.Objects(e),A.Vector(e,!1)))),vectorLength:ee("vector-length",[{name:"vec"}],(({vec:e})=>(V.Vector(e),A.Number(e[1].length)))),vectorRef:ee("vector-ref",[{name:"vec"},{name:"k"}],(({vec:e,k:r})=>{if(V.Vector(e),V.IntegerNumber(r),!(r[1]in e[1]))throw A.Error("out-of-range","Index is out of range.");return e[1][r[1]]})),vectorSetD:ee("vector-set!",[{name:"vec"},{name:"k"},{name:"obj"}],(({vec:e,k:r,obj:t})=>{if(V.Vector(e),V.IntegerNumber(r),V.Object(t),!(r[1]in e[1]))throw A.Error("out-of-range","Index is out of range.");if(L.Undefined(t))throw A.Error("undefined-value","Attempt to set a undefined value to vector.");return e[1][r[1]]=t,["<undefined>"]})),vector2list:ee("vector->list",[{name:"vec"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({vec:e,start:r,end:t})=>{V.Vector(e);const n=e[1],a=L.Number(r)?r[1]:0,o=L.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw A.Error("domain-error","Index must be integer.");return A.List(...n.slice(a,o))})),list2vector:ee("list->vector",[{name:"list"}],(({list:e})=>(V.List(e),A.Vector(W(e),!1)))),vector2string:ee("vector->string",[{name:"vec"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({vec:e,start:r,end:t})=>{V.Vector(e);const n=e[1],a=L.Number(r)?r[1]:0,o=L.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw A.Error("domain-error","Index must be integer.");return A.String(n.slice(a,o).map((e=>(V.Character(e),e[1]))).join(""),!1)})),string2vector:ee("string->vector",[{name:"str"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({str:e,start:r,end:t})=>{V.String(e);const n=Array.from(e[1]),a=L.Number(r)?r[1]:0,o=L.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw A.Error("domain-error","Index must be integer.");return A.Vector(n.slice(a,o).map((e=>A.Character(e))),!1)})),vectorCopy:ee("vector-copy",[{name:"vec"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({vec:e,start:r,end:t})=>{V.Vector(e);const n=e[1];if(0===n.length)return A.Vector([],!1);const a=L.Number(r)?r[1]:0,o=L.Number(t)?t[1]:n.length;if("number"!=typeof a||!Number.isInteger(a)||"number"!=typeof o||!Number.isInteger(o))throw A.Error("domain-error","Index must be integer.");return A.Vector(n.slice(a,o),!1)})),vectorCopyD:ee("vector-copy!",[{name:"to"},{name:"at"},{name:"from"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({to:e,at:r,from:t,start:n,end:a})=>{V.Vector(e),V.IntegerNumber(r),V.Vector(t);const o=L.Number(n)?n[1]:0,i=L.Number(a)?a[1]:t[1].length;if("number"!=typeof o||!Number.isInteger(o)||"number"!=typeof i||!Number.isInteger(i))throw A.Error("domain-error","Index must be integer.");if(!(r[1]in e[1]))throw A.Error("out-of-range","Index is out of range.");if(e[1].length-r[1]<i-o)throw A.Error("out-of-range","Index is out of range.");const l=t[1].slice(o,i);return e[1].splice(r[1],l.length,...l),["<undefined>"]})),vectorAppend:ee("vector-append",[{name:"vecs",type:"variadic"}],(({vecs:e})=>(V.Vectors(e),A.Vector(e.map((e=>e[1])).flat(),!1)))),vectorFillD:ee("vector-fill!",[{name:"vec"},{name:"fill"},{name:"start",type:"optional"},{name:"end",type:"optional"}],(({vec:e,fill:r,start:t,end:n})=>{if(V.Vector(e),V.Object(r),L.Undefined(r))throw A.Error("undefined-value","Attempt to fill vector with an undefined value.");const a=e[1],o=L.Number(t)?t[1]:0,i=L.Number(n)?n[1]:a.length;if("number"!=typeof o||!Number.isInteger(o)||"number"!=typeof i||!Number.isInteger(i))throw A.Error("domain-error","Index must be integer.");for(let l=o;l<i;l++)l in a&&(a[l]=r);return e}))},Na=[ee("write",[{name:"obj"},{name:"port",type:"optional"}],(({obj:e,port:r})=>{let t;V.Object(e),r&&V.Object(r);try{t=f(b([y(e)]))}catch(n){if(n instanceof Error)throw A.Error("write-error",n.message);throw n}return r?$.CallBuiltIn("write-string",A.String(t,!1),r):$.CallBuiltIn("write-string",A.String(t,!1))}),!0,!0),ee("write-shared",[{name:"obj"},{name:"port",type:"optional"}],(({obj:e,port:r})=>{let t;V.Object(e),r&&V.Object(r);try{t=f(b([y(e,{labels:"shared"})]))}catch(n){if(n instanceof Error)throw A.Error("write-error",n.message);throw n}return r?$.CallBuiltIn("write-string",A.String(t,!1),r):$.CallBuiltIn("write-string",A.String(t,!1))}),!0,!0),ee("write-simple",[{name:"obj"},{name:"port",type:"optional"}],(({obj:e,port:r})=>{let t;V.Object(e),r&&V.Object(r);try{t=f(b([y(e,{labels:"simple"})]))}catch(n){if(n instanceof Error)throw A.Error("write-error",n.message);throw n}return r?$.CallBuiltIn("write-string",A.String(t,!1),r):$.CallBuiltIn("write-string",A.String(t,!1))}),!0,!0),ee("display",[{name:"obj"},{name:"port",type:"optional"}],(({obj:e,port:r})=>{let t;V.Object(e),r&&V.Object(r);try{t=f(b([y(e,{style:"display"})]))}catch(n){if(n instanceof Error)throw A.Error("write-error",n.message);throw n}return r?$.CallBuiltIn("write-string",A.String(t,!1),r):$.CallBuiltIn("write-string",A.String(t,!1))}),!0,!0)],Ia=[ee("read",[{name:"port",type:"optional"}],(({port:e},r,t)=>{if(M(r),M(t),e||(e=r.getDynamic(N(t).env.dynamic,"current-input-port")),V.Port(e),"string"!=typeof e[5])throw A.Error("read-error","Not a text port.");let n,a,o="";for(;;){const n=_n.body({port:e},r,t);if(L.EndOfFile(n))break;o+=n[1]}try{const e=pe(o);[n,a]=fe(e)}catch(m){throw m instanceof Error?A.Error("read-error",m.message):A.Error("read-error","Error occured while reading.")}if(0===n.length){if(a.length>0)throw A.Error("read-error","The external representation is incomplete and therefore not parsable,");return A.EndOfFile()}const[i,...l]=n,s=be(i,null,{removeLineInfo:!0}),c=b(l),u=f(c);return e[5]=u+e[5],s}),!1,!0)],Ba=ee("delay",[{name:"expr",evaluate:!1}],(({expr:e},r,t)=>{V.Object(e),M(t);const n=A.Procedure("lambda",[],e,!1,N(t).env);return A.Promise(n,null)}),!1,!0),Oa=ee("delay-force",[{name:"expr",evaluate:!1}],(({expr:e},r,t)=>{V.Object(e),M(t);const n=A.Procedure("lambda",[],e,!1,N(t).env),a=A.Promise(n,null);return $.CallBuiltIn("force",a)}),!0,!0),Ca=ee("force",[{name:"promise"}],(({promise:e})=>{if(V.Object(e),L.Promise(e)){if(e[2])return $.Quote(e[2]);{const r=e[1];if(!r)throw A.Error("error","Illegal promise.");return $.CallBuiltIn("force-1",e,$.Call(r))}}return $.Quote(e)}),!0,!0),Aa=ee("force-1",[{name:"promise"},{name:"obj"}],(({promise:e,obj:r})=>(V.Promise(e),V.Object(r),e[2]=r,r)),!1,!0),$a=[Ba,Oa,Ca,ee("promise?",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Boolean(L.Promise(e)))),!1,!0),ee("make-promise",[{name:"obj"}],(({obj:e})=>(V.Object(e),A.Promise(null,e))),!1,!0)],La=[Aa],ka=[ee("current-second",[],(()=>A.Number(Date.now()/1e3)),!1,!0),ee("current-jiffy",[],(()=>{const e=Function("return this")();return A.Number(Math.round(e.performance?performance.now():Date.now()))}),!1,!0),ee("jiffies-per-second",[],(()=>A.Number(1e3)),!1,!0)],za=[ee("finite?",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e);return A.Boolean(Number.isFinite(r))}),!1,!0),ee("infinite?",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e);return A.Boolean(!Number.isNaN(r)&&!Number.isFinite(r))}),!1,!0),ee("exp",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e);return w(Math.exp(r))}),!1,!0),ee("log",[{name:"z1"},{name:"z2",type:"optional"}],(({z1:e,z2:r})=>{V.Number(e);const t=S(e);if(r){V.Number(r);const e=S(r);return w(Math.log(t)/Math.log(e))}return w(Math.log(t))}),!1,!0),ee("sin",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e);return w(Math.sin(r))}),!1,!0),ee("cos",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e);return w(Math.cos(r))}),!1,!0),ee("tan",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e);return w(Math.tan(r))}),!1,!0),ee("asin",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e);return w(Math.asin(r))}),!1,!0),ee("acos",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e);return w(Math.acos(r))}),!1,!0),ee("atan",[{name:"z1"},{name:"z2",type:"optional"}],(({z1:e,z2:r})=>{V.Number(e);const t=S(e);if(r){V.Number(r);const e=S(r);return w(Math.atan2(t,e))}return w(Math.atan(t))}),!1,!0),ee("sqrt",[{name:"z"}],(({z:e})=>{V.Number(e);const r=S(e);return w(Math.sqrt(r))}),!1,!0)],Va=[ee("case-lambda",[{name:"clauses",type:"variadic",evaluate:!1}],(({clauses:e})=>{V.Pairs(e);const r=Y(),t=Y(),n=A.Procedure("built-in","lambda"),a=A.Procedure("built-in","cond"),o=A.Procedure("built-in","define"),i=A.Procedure("built-in","apply"),l=A.Procedure("built-in","error");return ye([n,r,[o,t,["length",r]],[a,...e.map((([,e,n])=>{const[a,o]=ae(e);return[[o?">=":"=",t,a.length],[i,["lambda",e,...n],r]]})),["else",[l,'"No matching clause for case-lambda"']]]])}),!0,!0)],Ma=[ee("char-ci=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{V.Character(e),V.Character(r),V.Characters(t);const n=[e,r,...t].map((e=>ce(e[1])));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]===e)))}),!1,!0),ee("char-ci<?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{V.Character(e),V.Character(r),V.Characters(t);const n=[e,r,...t].map((e=>ce(e[1])));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]<e)))}),!1,!0),ee("char-ci>?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{V.Character(e),V.Character(r),V.Characters(t);const n=[e,r,...t].map((e=>ce(e[1])));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]>e)))}),!1,!0),ee("char-ci<=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{V.Character(e),V.Character(r),V.Characters(t);const n=[e,r,...t].map((e=>ce(e[1])));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]<=e)))}),!1,!0),ee("char-ci>=?",[{name:"char1"},{name:"char2"},{name:"chars",type:"variadic"}],(({char1:e,char2:r,chars:t})=>{V.Character(e),V.Character(r),V.Characters(t);const n=[e,r,...t].map((e=>ce(e[1])));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]>=e)))}),!1,!0),ee("char-alphabetic?",[{name:"char"}],(({char:e})=>(V.Character(e),A.Boolean(/\p{Alphabetic}/u.test(e[1])))),!1,!0),ee("char-numeric?",[{name:"char"}],(({char:e})=>(V.Character(e),A.Boolean(/\p{Decimal_Number}/u.test(e[1])))),!1,!0),ee("char-whitespace?",[{name:"char"}],(({char:e})=>(V.Character(e),A.Boolean(/\p{White_Space}/u.test(e[1])))),!1,!0),ee("char-upper-case?",[{name:"char"}],(({char:e})=>(V.Character(e),A.Boolean(/\p{Uppercase}/u.test(e[1])))),!1,!0),ee("char-lower-case?",[{name:"char"}],(({char:e})=>(V.Character(e),A.Boolean(/\p{Lowercase}/u.test(e[1])))),!1,!0),ee("digit-value",[{name:"char"}],(({char:e})=>{var r;V.Character(e);const t=null!=(r=e[1].codePointAt(0))?r:0,n=[48,1632,1776,1984,2406,2534,2662,2790,2918,3046,3174,3302,3430,3558,3664,3792,3872,4160,4240,6112,6160,6470,6608,6784,6800,6992,7088,7232,7248,42528,43216,43264,43472,43504,43600,44016,65296,66720,69734,69872,69942,70096,70384,70864,71248,71360,71472,71904,92768,93008,120782,120792,120802,120812,120822].find((e=>t>=e&&t<=e+9));return n?A.Number(t-n):A.Boolean(!1)}),!1,!0),ee("char-upcase",[{name:"char"}],(({char:e})=>(V.Character(e),A.Character(e[1].toUpperCase()))),!1,!0),ee("char-downcase",[{name:"char"}],(({char:e})=>(V.Character(e),A.Character(e[1].toLowerCase()))),!1,!0),ee("char-foldcase",[{name:"char"}],(({char:e})=>(V.Character(e),A.Character(ce(e[1])))),!1,!0),ee("string-ci=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{V.String(e),V.String(r),V.Strings(t);const n=[e,r,...t].map((e=>ce(e[1])));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]===e)))}),!1,!0),ee("string-ci<?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{V.String(e),V.String(r),V.Strings(t);const n=[e,r,...t].map((e=>ce(e[1])));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]<e)))}),!1,!0),ee("string-ci>?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{V.String(e),V.String(r),V.Strings(t);const n=[e,r,...t].map((e=>ce(e[1])));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]>e)))}),!1,!0),ee("string-ci<=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{V.String(e),V.String(r),V.Strings(t);const n=[e,r,...t].map((e=>ce(e[1])));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]<=e)))}),!1,!0),ee("string-ci>=?",[{name:"str1"},{name:"str2"},{name:"strs",type:"variadic"}],(({str1:e,str2:r,strs:t})=>{V.String(e),V.String(r),V.Strings(t);const n=[e,r,...t].map((e=>ce(e[1])));return A.Boolean(n.every(((e,r)=>0===r||n[r-1]>=e)))}),!1,!0),ee("string-upcase",[{name:"str"}],(({str:e})=>(V.String(e),A.String(e[1].toUpperCase(),!1))),!1,!0),ee("string-downcase",[{name:"str"}],(({str:e})=>(V.String(e),A.String(e[1].toLowerCase(),!1))),!1,!0),ee("string-foldcase",[{name:"str"}],(({str:e})=>(V.String(e),A.String(ce(e[1]),!1))),!1,!0)],qa=(e,r)=>{const t=(r=r.replace(/^c/,"").replace(/r$/,"")).slice(-1),[,n,a]=e;if("a"===t)return r.length<=1?n:(V.Pair(n),qa(n,r.slice(0,r.length-1)));if("d"===t)return r.length<=1?a:(V.Pair(a),qa(a,r.slice(0,r.length-1)));throw A.Error("error",`Illegal cxr parameter ${r}`)},Ta=[ee("caaaar",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"caaaar"))),!1,!0),ee("caaadr",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"caaadr"))),!1,!0),ee("caaar",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"caaar"))),!1,!0),ee("caadar",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"caadar"))),!1,!0),ee("caaddr",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"caaddr"))),!1,!0),ee("caadr",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"caadr"))),!1,!0),ee("cadaar",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cadaar"))),!1,!0),ee("cadadr",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cadadr"))),!1,!0),ee("cadar",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cadar"))),!1,!0),ee("caddar",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"caddar"))),!1,!0),ee("cadddr",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cadddr"))),!1,!0),ee("caddr",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"caddr"))),!1,!0),ee("cdaaar",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cdaaar"))),!1,!0),ee("cdaadr",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cdaadr"))),!1,!0),ee("cdaar",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cdaar"))),!1,!0),ee("cdadar",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cdadar"))),!1,!0),ee("cdaddr",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cdaddr"))),!1,!0),ee("cdadr",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cdadr"))),!1,!0),ee("cddaar",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cddaar"))),!1,!0),ee("cddadr",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cddadr"))),!1,!0),ee("cddar",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cddar"))),!1,!0),ee("cdddar",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cdddar"))),!1,!0),ee("cddddr",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cddddr"))),!1,!0),ee("cdddr",[{name:"pair"}],(({pair:e})=>(V.Pair(e),qa(e,"cdddr"))),!1,!0)],Da=[ee("command-line",[],(()=>{if(!(null==process?void 0:process.argv))throw A.Error("error","No process.argv (Maybe not running on Node.js)");return A.List(...process.argv.map((e=>A.String(e,!0))))}),!1,!0),ee("exit",[{name:"obj",type:"optional"}],(({obj:e},r,t)=>{M(t),e&&V.Object(e);const n=e?$.CallBuiltIn("emergency-exit",A.MultiValue([e])):$.CallBuiltIn("emergency-exit"),a=A.Continuation(I(n));return $.Call(a)}),!0,!0),ee("emergency-exit",[{name:"obj",type:"optional"}],(({obj:e})=>{throw e&&V.Object(e),A.Exit(null!=e?e:null)}),!1,!0),ee("get-environment-variable",[{name:"name"}],(({name:e})=>{if(V.String(e),!(null==process?void 0:process.env))throw A.Error("error","No process.env (Maybe not running on Node.js)");const r=process.env[e[1]];return r?A.String(r,!0):A.Boolean(!1)}),!1,!0),ee("get-environment-variables",[],(()=>{if(!(null==process?void 0:process.env))throw A.Error("error","No process.env (Maybe not running on Node.js)");return A.List(...Object.keys(process.env).map((e=>{var r;return A.Pair(A.String(e,!0),A.String(null!=(r=process.env[e])?r:"",!0))})))}),!1,!0)],Ra='"fs" is not set. To use filesystems, import/require "fs" and set it on Interpreter\'s constructor parameter.',Qa=ee("eval-close",[{name:"obj"},{name:"port"}],(({obj:e,port:r},t)=>(V.Object(e),V.Port(r),M(t),Mn.body({port:r},t),e)),!1,!0),Ua=ee("call-with-input-file",[{name:"str"},{name:"proc"}],(({str:e,proc:r},t,n)=>{M(t),M(n);const a=t.getOptions().fs;M(a,Ra),V.String(e),V.Procedure(r);const o=Xa.body({str:e},t);return $.CallBuiltIn("eval-close",$.Call(r,o),o)}),!0,!0),Fa=ee("call-with-output-file",[{name:"str"},{name:"proc"}],(({str:e,proc:r},t)=>{M(t);const n=t.getOptions().fs;M(n,Ra),V.String(e),V.Procedure(r);const a=Ka.body({str:e},t);return $.CallBuiltIn("eval-close",$.Call(r,a),a)}),!0,!0),Ja=ee("with-input-from-file",[{name:"str"},{name:"thunk"}],(({str:e,thunk:r},t)=>{M(t);const n=t.getOptions().fs;M(n,Ra),V.String(e),V.Procedure(r);const a=Xa.body({str:e},t);return $.CallBuiltIn("parameterize",A.List(A.List(A.Symbol("current-input-port"),a)),$.CallBuiltIn("eval-close",$.Call(r),a))}),!0,!0),_a=ee("with-output-to-file",[{name:"str"},{name:"thunk"}],(({str:e,thunk:r},t)=>{M(t);const n=t.getOptions().fs;M(n,Ra),V.String(e),V.Procedure(r);const a=Ka.body({str:e},t);return $.CallBuiltIn("parameterize",A.List(A.List(A.Symbol("current-output-port"),a)),$.CallBuiltIn("eval-close",$.Call(r),a))}),!0,!0),Xa=ee("open-input-file",[{name:"str"}],(({str:e},r)=>{var t;M(r);const n=r.getOptions().fs;M(n,Ra),V.String(e);const a=r.getBuiltInPort(e[1]);if(a)try{return null==(t=a.open)||t.call(a,"r",null),A.Port("built-in",e[1],"r",null,"")}catch(o){throw o instanceof Error?A.Error("file-error",o.message):A.Error("file-error",`built-in port "${e[1]} open("r") failed.`)}else try{const r=n.openSync(e[1],"r");return A.Port("file",r,"r",null,"")}catch(o){throw o instanceof Error?A.Error("file-error",o.message):A.Error("file-error",`fs.openSync("${e[1]}", "r") failed.`)}}),!1,!0),Za=ee("open-binary-input-file",[{name:"str"}],(({str:e},r)=>{var t;M(r);const n=r.getOptions().fs;M(n,Ra),V.String(e);const a=r.getBuiltInPort(e[1]);if(a)try{return null==(t=a.open)||t.call(a,"r",null),A.Port("built-in",e[1],"r",null,[])}catch(o){throw o instanceof Error?A.Error("file-error",o.message):A.Error("file-error",`built-in port "${e[1]} open("r") failed.`)}else try{const r=n.openSync(e[1],"r");return A.Port("file",r,"r",null,[])}catch(o){throw o instanceof Error?A.Error("file-error",o.message):A.Error("file-error",`fs.openSync("${e[1]}", "r") failed.`)}}),!1,!0),Ka=ee("open-output-file",[{name:"str"}],(({str:e},r)=>{var t;M(r);const n=r.getOptions().fs;M(n,Ra),V.String(e);const a=r.getBuiltInPort(e[1]);if(a)try{return null==(t=a.open)||t.call(a,"w",null),A.Port("built-in",e[1],"w",null,"")}catch(o){throw o instanceof Error?A.Error("file-error",o.message):A.Error("file-error",`built-in port "${e[1]} open("w") failed.`)}else try{const r=n.openSync(e[1],"w");return A.Port("file",r,"w",null,"")}catch(o){throw o instanceof Error?A.Error("file-error",o.message):A.Error("file-error",`fs.openSync("${e[1]}", "w") failed.`)}}),!1,!0),Wa=ee("open-binary-output-file",[{name:"str"}],(({str:e},r)=>{var t;M(r);const n=r.getOptions().fs;M(n,Ra),V.String(e);const a=r.getBuiltInPort(e[1]);if(a)try{return null==(t=a.open)||t.call(a,"w",null),A.Port("built-in",e[1],"w",null,[])}catch(o){throw o instanceof Error?A.Error("file-error",o.message):A.Error("file-error",`built-in port "${e[1]} open("w") failed.`)}else try{const r=n.openSync(e[1],"w");return A.Port("file",r,"w",null,[])}catch(o){throw o instanceof Error?A.Error("file-error",o.message):A.Error("file-error",`fs.openSync("${e[1]}", "w") failed.`)}}),!1,!0),Ga=ee("file-exists?",[{name:"filename"}],(({filename:e},r)=>{M(r);const t=r.getOptions().fs;M(t,Ra),V.String(e);try{return A.Boolean(t.existsSync(e[1]))}catch(n){throw n instanceof Error?A.Error("file-error",n.message):A.Error("file-error","fs.existsSync() failed.")}}),!1,!0),Ha=ee("delete-file",[{name:"filename"}],(({filename:e},r)=>{M(r);const t=r.getOptions().fs;M(t,Ra),V.String(e);try{t.unlinkSync(e[1])}catch(n){throw n instanceof Error?A.Error("file-error",n.message):A.Error("file-error","fs.unlinkSync() failed.")}return A.Undefined()}),!1,!0),Ya=[Ua,Fa,Ja,_a,Xa,Za,Ka,Wa,Ga,Ha],eo=[Qa],ro=[ee("environment",[{name:"sets",type:"variadic"}],(({sets:e},r,t)=>{V.Objects(e),M(r),M(t);const n=I(A.Undefined());return da.body({sets:e},r,n),A.EnvironmentSpec(N(n).env)}),!1,!0),ee("eval",[{name:"expr"},{name:"spec"}],(({expr:e,spec:r},t,n)=>(V.Object(e),V.EnvironmentSpec(r),M(n),O(n,e,{env:r[1]}))),!1,!0)],to=ee("interaction-environment",[],(()=>{const e=I(A.Undefined());return A.EnvironmentSpec(N(e).env)}),!1,!0),no=[to],ao=[ee("load",[{name:"filename"},{name:"spec",type:"optional"}],(({filename:e,spec:r},t,n)=>{M(t),M(n),V.String(e),r?V.EnvironmentSpec(r):r=to.body();const a=gr.body({filename:e},t);return $.CallBuiltIn("eval",a,r)}),!0,!0)],oo="\n  * +  - /  < <=  = >  >= abs  acos and  angle append  apply asin  assoc assq  assv atan\n  begin boolean?  caaaar caaadr  caaar caadar  caaddr caadr  caar cadaar  cadadr cadar\n  caddar cadddr  caddr cadr  call-with-current-continuation  call-with-input-file call-with-output-file\n  call-with-values car  case cdaaar  cdaadr cdaar  cdadar cdaddr  cdadr cdar  cddaar cddadr\n  cddar cdddar  cddddr cdddr  cddr cdr  ceiling char->integer  char-alphabetic? char-ci<=?\n  char-ci<? char-ci=?  char-ci>=? char-ci>?  char-downcase char-lower-case?  char-numeric? char-ready?\n  char-upcase char-upper-case?  char-whitespace? char<=?  char<? char=?  char>=? char>?\n  char? close-input-port  close-output-port complex?  cond cons  cos current-input-port\n  current-output-port define  define-syntax delay  denominator display  do dynamic-wind\n  eof-object? eq?  equal? eqv?  eval even?  exact->inexact exact?  exp expt  floor for-each\n  force gcd  if imag-part  inexact->exact inexact?   input-port? integer->char\n  integer? interaction-environment  lambda lcm  length let\n  let* let-syntax  letrec letrec-syntax  list list->string  list->vector list-ref\n  list-tail list?  load log  magnitude make-polar  make-rectangular make-string\n  make-vector map  max member  memq memv  min modulo  negative? newline  not null-environment\n  null? number->string  number? numerator  odd? open-input-file  open-output-file or\n  output-port? pair?  peek-char positive?  procedure? quasiquote  quote quotient  rational? rationalize\n  read read-char  real-part real?  remainder reverse  round  scheme-report-environment\n  set! set-car!  set-cdr! sin  sqrt string  string->list string->number  string->symbol string-append\n  string-ci<=? string-ci<?  string-ci=? string-ci>=?  string-ci>? string-copy  string-fill! string-length\n  string-ref string-set!  string<=? string<?  string=? string>=?  string>? string?  substring symbol->string\n  symbol? tan  truncate values  vector vector->list  vector-fill! vector-length  vector-ref vector-set!\n  vector? with-input-from-file  with-output-to-file write  write-char zero?\n".split(/(\s|\n)+/).filter((e=>!/^\s*$/.test(e))),io="\n  and  begin  case  cond  do  if  lambda  let  let*  let-syntax  letrec  letrec-syntax  or  quasiquote  quote  set!\n".split(/(\s|\n)+/).filter((e=>!/^\s*$/.test(e))),lo=ee("scheme-report-environment",[{name:"version"}],(({version:e},r,t)=>{if(M(r),M(t),V.Number(e),5!==e[1])throw A.Error("error","scheme-report-environment only supports version 5.");const n=I(A.Undefined());for(const a of oo)r.getProcedureContent(A.Procedure("built-in",a))&&r.defineStatic(N(n).env.static,A.Symbol(a),A.Procedure("built-in",a));return A.EnvironmentSpec(N(n).env)}),!1,!0),so=ee("null-environment",[{name:"version"}],(({version:e},r,t)=>{if(M(r),M(t),V.Number(e),5!==e[1])throw A.Error("error","scheme-report-environment only supports version 5.");const n=I(A.Undefined());for(const a of io)r.getProcedureContent(A.Procedure("built-in",a))&&r.defineStatic(N(n).env.static,A.Symbol(a),A.Procedure("built-in",a));return A.EnvironmentSpec(N(n).env)}),!1,!0),co=re("exact->inexact",xn);co.hidden=!0;const uo=re("inexact->exact",Pn);uo.hidden=!0;const mo=[lo,so,co,uo],po=[...Object.values(we),...Object.values(Le),...Object.values(Qe),...Object.values(tr),...Object.values(ir),...Object.values(yr),...Object.values(at),...Object.values($t),...Object.values(In),...Object.values(ua),...Object.values(ma),...Object.values(xa),...Object.values(Pa),...Object.values(Ea),...Object.values(wr),...Object.values(vr)],fo={"(scheme write)":e=>{Na.forEach((r=>e.setBuiltInProcedure(r)));const r={};return Na.forEach((({name:e})=>r[e]=A.Procedure("built-in",e))),r},"(scheme read)":e=>{Ia.forEach((r=>e.setBuiltInProcedure(r)));const r={};return Ia.forEach((({name:e})=>r[e]=A.Procedure("built-in",e))),r},"(scheme lazy)":e=>{[...$a,...La].forEach((r=>e.setBuiltInProcedure(r)));const r={};return $a.forEach((({name:e})=>r[e]=A.Procedure("built-in",e))),r},"(scheme time)":e=>{[...ka].forEach((r=>e.setBuiltInProcedure(r)));const r={};return ka.forEach((({name:e})=>r[e]=A.Procedure("built-in",e))),r},"(scheme inexact)":e=>{[...za].forEach((r=>e.setBuiltInProcedure(r)));const r={};return za.forEach((({name:e})=>r[e]=A.Procedure("built-in",e))),r},"(scheme case-lambda)":e=>{Va.forEach((r=>e.setBuiltInProcedure(r)));const r={};return Va.forEach((({name:e})=>r[e]=A.Procedure("built-in",e))),r},"(scheme char)":e=>{Ma.forEach((r=>e.setBuiltInProcedure(r)));const r={};return Ma.forEach((({name:e})=>r[e]=A.Procedure("built-in",e))),r},"(scheme cxr)":e=>{Ta.forEach((r=>e.setBuiltInProcedure(r)));const r={};return Ta.forEach((({name:e})=>r[e]=A.Procedure("built-in",e))),r},"(scheme process-context)":e=>{Da.forEach((r=>e.setBuiltInProcedure(r)));const r={};return Da.forEach((({name:e})=>r[e]=A.Procedure("built-in",e))),r},"(scheme file)":e=>{[...Ya,...eo].forEach((r=>e.setBuiltInProcedure(r)));const r={};return Ya.forEach((({name:e})=>r[e]=A.Procedure("built-in",e))),r},"(scheme eval)":e=>{ro.forEach((r=>e.setBuiltInProcedure(r)));const r={};return ro.forEach((({name:e})=>r[e]=A.Procedure("built-in",e))),r},"(scheme repl)":e=>{no.forEach((r=>e.setBuiltInProcedure(r)));const r={};return no.forEach((({name:e})=>r[e]=A.Procedure("built-in",e))),r},"(scheme load)":e=>{ao.forEach((r=>e.setBuiltInProcedure(r)));const r={};return ao.forEach((({name:e})=>r[e]=A.Procedure("built-in",e))),r},"(scheme r5rs)":e=>{mo.forEach((r=>e.setBuiltInProcedure(r)));const r={};for(const t of oo)e.getProcedureContent(A.Procedure("built-in",t))&&(r[t]=A.Procedure("built-in",t));return r}},bo=[],yo=console;class ho{constructor(e){var r,t;c(this,"options"),c(this,"builtins",{jsObject:{},procedure:{},port:{"//input":{},"//output":{write:e=>{var r;(null==(r=null==process?void 0:process.stdout)?void 0:r.write)?process.stdout.write(e):yo.log(e)}},"//error":{write:e=>{var r;(null==(r=null==process?void 0:process.stderr)?void 0:r.write)?process.stderr.write(e):yo.warn(e)}}},static:{"current-input-port":A.Parameter("current-input-port",null),"current-output-port":A.Parameter("current-output-port",null),"current-error-port":A.Parameter("current-error-port",null)},dynamic:{"current-input-port":A.Port("built-in","//input","r",null,""),"current-output-port":A.Port("built-in","//output","w",null,""),"current-error-port":A.Port("built-in","//error","w",null,"")},library:{}}),c(this,"fs",null),this.options=null!=e?e:{},this.fs=null!=(r=null==e?void 0:e.fs)?r:null,bo.forEach((([e,r])=>this.setBuiltInJSObject(e,r))),po.forEach((e=>this.setBuiltInProcedure(e))),Object.keys(fo).forEach((e=>this.setBuiltInLibrary(e,fo[e]))),null==(t=null==e?void 0:e.plugins)||t.forEach((e=>e(this)))}getOptions(){return this.options}setBuiltInProcedure(e,r=!1){const t=A.Procedure("built-in",e.name);return!r&&this.getProcedureContent(t)||(this.builtins.procedure[e.name]=e),t}setBuiltInJSObject(e,r,t=!1){const n=A.JS("built-in",e);return!t&&this.getJSObjectContent(n)||(this.builtins.jsObject[e]=r),n}setBuiltInPort(e,r,t=!1){var n;const a=A.Port("built-in",e,null,null,(null==(n=r.binary)?void 0:n.call(r))?[]:"");return!t&&this.getBuiltInPort(e)||(this.builtins.port[e]=r),a}setBuiltInLibrary(e,r,t=!1){return!t&&this.getBuiltInPort(e)||(this.builtins.library[e]=r,r(this)),A.Symbol(e)}getProcedureContent(e){if(L.Continuation(e))return{parameters:[{name:"arg",evaluate:!0,type:"variadic"}],body:e,isMacro:!1,env:null};if(L.Parameter(e))return{parameters:[],body:e,isMacro:!1,env:null};if("lambda"===e[1]){const[,,r,t,n,a]=e;return{parameters:r,body:t,isMacro:n,env:a}}{const[,,r]=e;if(K.call(this.builtins.procedure,r)){const{parameters:e,body:t,isMacro:n=!1}=this.builtins.procedure[r];return{parameters:e,body:t,isMacro:n,env:null}}return null}}getJSObjectContent(e){if("inline"===e[1])return e[2];{const r=e[2];return K.call(this.builtins.jsObject,r)?this.builtins.jsObject[r]:null}}getBuiltInPort(e){return K.call(this.builtins.port,e)?this.builtins.port[e]:null}getBuiltInLibrary(e){return K.call(this.builtins.library,e)?this.builtins.library[e]:null}defineStatic(e,r,t){const n=r[3]?r[3]:r[1];return e=r[2]?r[2]:e,x(e)[n]=t,n}defineDynamic(e,r,t){return x(e)[r]=t,r}setStatic(e,r,t){const n=r[3]?r[3]:r[1];for(let a=e=r[2]?r[2]:e;null!==a;a=j(a)){const e=x(a);if(K.call(e,n))return e[n]=t}return null}setDynamic(e,r,t){for(let n=e;null!==n;n=j(n)){const e=x(n);if(K.call(e,r))return e[r]=t}return null}getStatic(e,r){const t=r[3]?r[3]:r[1];for(let n=e=r[2]?r[2]:e;null!==n;n=j(n)){const e=x(n);if(K.call(e,t))return e[t]}return K.call(this.builtins.static,t)?this.builtins.static[t]:K.call(this.builtins.procedure,t)&&!this.builtins.procedure[t].hidden?["<procedure>","built-in",t]:null}getDynamic(e,r){for(let t=e;null!==t;t=j(t)){const e=x(t);if(K.call(e,r))return e[r]}return K.call(this.builtins.dynamic,r)?this.builtins.dynamic[r]:null}eval(e){return this.evalAST(he(e))}evalJS(e){return this.evalAST($.Begin(ye(e)))}resume(e,r=A.Undefined()){if(T(e)&&!R(e))throw new Error("The content of envelope is not #SUSPEND# object.");const t=R(e)?e.content[1]:e[1];return this.evalAST($.Begin($.Call(t,r)))}evalAST(e){var r,t,n,a;const o=I(e);let i=null;try{for(let e=o;e;){if(N(e).depth>(null!=(r=this.options.stack)?r:16384))throw new Error("Call-stack overflow.");this.options.beforeExecute&&([e,i]=null!=(t=this.options.beforeExecute(e,i))?t:[e,i]),this.options.debug&&yo.log(`Executing(${null!=(n=e[1].want)?n:"initial"}/depth:${e[1].depth}) ${g(e[1].expr)}`);const[o,l]=this.execute(e,i);if(this.options.debug){const r=o?P(o)===e?"wind":P(e)===o?"unwind":P(o)==P(o)?"transfer":"unknown":"finish";yo.log(`Result: ${l?g(l):l} (${r}).`),o&&this.options.verbose&&yo.log(`Next(${null!=(a=o[1].want)?a:"initial"}/depth:${o[1].depth}) ${g(o[1].expr)}`)}this.options.afterExecute&&this.options.afterExecute(o,l,e,i),[e,i]=[o,l]}}catch(l){if(L.Exception(l)){const[,e,r]=l,[,t,n]=L.Error(r)?r:[null,"exception",g(r)],a=E(e).map((([,{depth:e,want:r,expr:t,info:n}])=>`${e}: ${null!=r?r:"initial"}: ${g(t,{maxdepth:20}).slice(0,100)}: ${JSON.stringify(n)}`)).join("\n")+"\n";throw this.options.debug&&yo.log(`UNHANDLED ERROR: ${t}, ${n}\n${a}`),Object.assign(new Error,{name:t,message:null!=n?n:t,stack:a})}if(L.Object(l)||L.SpecialObject(l)){throw{language:u,version:"0.6.0",content:l}}throw l}if(!i)throw new Error("AST didn't return value");return i}execute(e,r){var t,n;const a=(e=>{const r=N(e),t=r.args;return["#CALL-STACK#",s(l({},r),{args:t?[...t]:null}),P(e)]})(e),o=N(a),{expr:i}=o;try{if(r){if("return"===o.want)return[P(a),r];if("macro"===o.want)return[O(a,r),null]}if(null===o.want){if(r){if(!L.MultiValue(r)||0!==r[1].length)throw A.Error("internal-error",`Call-frame was given a value without any want. "${o.want}"`);r=null}if(L.Symbol(i)){const e=this.getStatic(null!=(t=i[2])?t:N(a).env.static,i);if(e)return[P(a),e];throw A.Error("unbound-variable",`${i[1]} is not defined.`)}if(L.Null(i))throw A.Error("program-error","Evaluating an empty list is an error in Scheme.");if(!L.Pair(i))return[P(a),i];o.want="oper"}if(!L.Pair(i))throw A.Error("internal-error","Illegal status of call-frame. frane.want is not null, but expr is not a <pair>.");if("oper"===o.want)if(r){if(!L.Procedure(r))throw A.Error("not-a-procedure","Operator evaluation didn't return a valid procedure");o.oper=r,o.want="args",r=null}else{if(!L.Procedure(i[1])){if(L.Symbol(i[1])||L.Pair(i[1]))return[B(a,i[1]),null];throw A.Error("invalid-procedure","Operator is not a valid procedure.")}o.oper=i[1],o.want="args"}if(!o.oper)throw A.Error("internal-error","Illegal status of call-frame. frame.want is not null or oper, but oper is still null.");const l=this.getProcedureContent(o.oper);if(!l)throw A.Error("program-error","Operator is not a valid procedure.");const s=l.parameters.filter((e=>!e.type||"head"===e.type)),c=l.parameters.filter((e=>"optional"===e.type)),[m]=l.parameters.filter((e=>"variadic"===e.type)),d=l.parameters.filter((e=>"tail"===e.type));if("args"===o.want){let e;if(r)e=[r],r=null;else{const[r]=G(i);e=r.slice(1)}if(1===e.length&&L.MultiValue(e[0])){const[[,r]]=e;if(r.length<s.length+d.length||!m&&r.length>s.length+d.length+c.length)throw A.Error("arity-error","Length of items in `multiple-value' object does not match the length of parameters.");o.args=r,o.want="return"}else{if(e.length<s.length+d.length||!m&&e.length>s.length+d.length+c.length)throw A.Error("arity-error","Length of arguments does not match the length of parameters.");const r=Math.max(0,e.length-s.length-d.length),t=Math.max(0,e.length-s.length-c.length-d.length),n=[...s,...c.slice(0,r),...Array.from({length:t},(()=>m)),...d];o.args=e.map(((e,r)=>{var t;return(null==(t=n[r].evaluate)||t)&&L.Evaluatable(e)?null:e})),o.want=-1}}if(!o.args)throw A.Error("internal-error","Invalid status of call-frame. frame.want is not null, oper or args, but frame.args is still null.");if("number"==typeof o.want){r&&(o.args[o.want]=r,r=null);for(let e=0,r=o.args[e];e<o.args.length;r=o.args[++e])if(null===r){const r=W(i).slice(1);return o.want=e,[B(a,r[e]),null]}o.want="return"}if(!L.Objects(o.args))throw A.Error("internal-error","Invalid status of call-frame. frame.args contains non-objects.");const p=o.args,f=Math.max(0,p.length-s.length-d.length),b=Math.max(0,p.length-s.length-c.length-d.length),y=[...s,...c.slice(0,f),...Array.from({length:b},(()=>m)),...d];if("return"===o.want){if("function"==typeof l.body){const e=m?{[m.name]:[]}:{};for(let n=0;n<y.length;n++)"variadic"===y[n].type?e[y[n].name].push(p[n]):e[y[n].name]=p[n];let r;const{acceptableJSValue:t=(()=>!0)}=this.options;try{if(r=l.body(e,this,a),!L.Object(r)&&!L.CallStack(r)){if(!t(r))throw A.Error("not-acceptable-js-value",null);r=A.JS("inline",r)}}catch(u){throw L.Object(u)||L.SpecialObject(u)?L.Exception(u)||L.SpecialObject(u)?u:A.Exception(a,u,!1):u instanceof Error?u:A.Exception(a,A.JS("inline",u),!1)}return L.CallStack(r)?[r,null]:l.isMacro&&L.Evaluatable(r)?[O(a,r),null]:[P(a),r]}if(L.Continuation(l.body)){const e=l.body,r=E(a),t=E(e[1]).reverse(),o=new Set(t),i=null!=(n=r.find((e=>o.has(e))))?n:null,s=i?r.slice(0,r.indexOf(i)):r,c=i?t.slice(t.indexOf(i)+1):t,u=1===p.length?p[0]:A.MultiValue(p);for(const n of s){const r=N(n).after;if(r){const t=$.Begin($.Call(r),$.Call(e,A.MultiValue([u])));return[O(n,t,{before:null,after:null}),null]}}for(const n of c){const r=N(n).before;if(r){const t=$.Begin($.Call(r),$.Call(e,A.MultiValue([u])));return[B(n,t),null]}}return[e[1],u]}if(L.Parameter(l.body)){const e=this.getDynamic(N(a).env.dynamic,l.body[1]);if(!e)throw A.Error("unbound-variable","Parameter is not defined.");return[P(a),e]}{const{dynamic:r}=N(e).env,t=C(l.env.static),n=[];for(let e=0;e<y.length;e++)"variadic"!==y[e].type?this.defineStatic(t,A.Symbol(y[e].name),p[e]):n.push(p[e]);return m&&this.defineStatic(t,A.Symbol(m.name),H(n)),l.isMacro?(N(a).want="macro",[B(a,l.body,{env:{static:t,dynamic:r}}),null]):[O(a,l.body,{env:{static:t,dynamic:r}}),null]}}throw A.Error("internal-error",`Illegal status (want) of call-frame: ${o.want}`)}catch(u){if(u=L.Error(u)?A.Exception(a,u,!1):u,L.Exception(u)){const[,e,r,t]=u;if(o.handler){const n=x(o.handler);if(t){const t=A.Continuation(P(e)),a=$.Call(t,$.Call(n,A.MultiValue([r])));return[O(e,a,{handler:j(o.handler)}),null]}{const t=$.Raise($.Call(n,A.MultiValue([r])));return[O(e,t,{handler:j(o.handler)}),null]}}throw u}if(L.JS(u)&&"built-in"===u[1]&&((c=u[2])&&("object"==typeof c||"function"==typeof c)&&"function"==typeof c.then)){const e=A.JSPromiseContinuation(A.Continuation(a),u[2],"pending");throw u[2].then((()=>e[3]="fulfilled"),(()=>e[3]="rejected")),e}throw u}var c}}export{ho as Interpreter,H as arrayToList,V as assert,A as create,ee as defineBuiltInProcedure,re as defineBuiltInProcedureAlias,Z as exitValueFromEnvelope,B as forkCS,$ as forms,ye as fromJS,ie as fromReferentialJSON,L as is,D as isCurrentVersionEnvelope,T as isEnvelope,X as isExitEnvelope,U as isJSPromiseContinuationEnvelope,F as isPromiseEnvelope,R as isSuspendEnvelope,W as listToArray,G as pairToArrayWithEnd,he as parser,J as promiseFromEnvelope,_ as promiseStatusFromEnvelope,Q as suspendValueFromEnvelope,h as toJS,oe as toReferentialJSON,O as transferCS,v as unparser,te as wrapBuiltInProcedure,g as writeObject};
